/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function (status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}



// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
  readAsync,
  readBinary,
  setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }


  /**
   * @license
   * Copyright 2019 The Emscripten Authors
   * SPDX-License-Identifier: MIT
   */

  read_ = function shell_read(filename, binary) {
    if (!nodeFS) nodeFS = require('fs');
    if (!nodePath) nodePath = require('path');
    filename = nodePath['normalize'](filename);
    return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
  };

  readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };




  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function (ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function (status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };



} else
  if (ENVIRONMENT_IS_SHELL) {


    if (typeof read != 'undefined') {
      read_ = function shell_read(f) {
        return read(f);
      };
    }

    readBinary = function readBinary(f) {
      var data;
      if (typeof readbuffer === 'function') {
        return new Uint8Array(readbuffer(f));
      }
      data = read(f, 'binary');
      assert(typeof data === 'object');
      return data;
    };

    if (typeof scriptArgs != 'undefined') {
      arguments_ = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      arguments_ = arguments;
    }

    if (typeof quit === 'function') {
      quit_ = function (status) {
        quit(status);
      };
    }

    if (typeof print !== 'undefined') {
      // Prefer to use print/printErr where they exist, as they usually work better.
      if (typeof console === 'undefined') console = /** @type{!Console} */({});
      console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
      console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr !== 'undefined' ? printErr : print);
    }


  } else

    // Note that this includes Node.js workers when relevant (pthreads is enabled).
    // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
    // ENVIRONMENT_IS_NODE.
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
        scriptDirectory = self.location.href;
      } else if (document.currentScript) { // web
        scriptDirectory = document.currentScript.src;
      }
      // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
      // otherwise, slice off the final part of the url to find the script directory.
      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
      // and scriptDirectory will correctly be replaced with an empty string.
      if (scriptDirectory.indexOf('blob:') !== 0) {
        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1);
      } else {
        scriptDirectory = '';
      }


      // Differentiate the Web Worker from the Node Worker case, as reading must
      // be done differently.
      {


        /**
         * @license
         * Copyright 2019 The Emscripten Authors
         * SPDX-License-Identifier: MIT
         */

        read_ = function shell_read(url) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.send(null);
          return xhr.responseText;
        };

        if (ENVIRONMENT_IS_WORKER) {
          readBinary = function readBinary(url) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            xhr.responseType = 'arraybuffer';
            xhr.send(null);
            return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
          };
        }

        readAsync = function readAsync(url, onload, onerror) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = function xhr_onload() {
            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };




      }

      setWindowTitle = function (title) { document.title = title };
    } else {
      throw new Error('environment detection error');
    }


// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
if (Module['arguments']) arguments_ = Module['arguments']; if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', { configurable: true, get: function () { abort('Module.arguments has been replaced with plain arguments_') } });
if (Module['thisProgram']) thisProgram = Module['thisProgram']; if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', { configurable: true, get: function () { abort('Module.thisProgram has been replaced with plain thisProgram') } });
if (Module['quit']) quit_ = Module['quit']; if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', { configurable: true, get: function () { abort('Module.quit has been replaced with plain quit_') } });

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
assert(typeof Module['TOTAL_MEMORY'] === 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
if (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', { configurable: true, get: function () { abort('Module.read has been replaced with plain read_') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', { configurable: true, get: function () { abort('Module.readAsync has been replaced with plain readAsync') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', { configurable: true, get: function () { abort('Module.readBinary has been replaced with plain readBinary') } });
if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function () { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';




/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;

// stack management, and other functionality that is provided by the compiled code,
// should not be used before it is ready

/** @suppress{duplicate} */
var stackSave;
/** @suppress{duplicate} */
var stackRestore;
/** @suppress{duplicate} */
var stackAlloc;

stackSave = stackRestore = stackAlloc = function () {
  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
};

function staticAlloc(size) {
  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');
}

function dynamicAlloc(size) {
  assert(DYNAMICTOP_PTR);
  var ret = HEAP32[DYNAMICTOP_PTR >> 2];
  var end = (ret + size + 15) & -16;
  assert(end <= HEAP8.length, 'failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');
  HEAP32[DYNAMICTOP_PTR >> 2] = end;
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}





/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function === "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
    // (import "e" "f" (func 0 (type 0)))
    0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
    // (export "f" (func 0 (type 0)))
    0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

  // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < table.length; i++) {
      var item = table.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.


  var ret;
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    ret = freeTableIndexes.pop();
  } else {
    ret = table.length;
    // Grow the table
    try {
      table.grow(1);
    } catch (err) {
      if (!(err instanceof RangeError)) {
        throw err;
      }
      throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
    }
  }

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunctionWasm(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {
  assert(typeof func !== 'undefined');

  return addFunctionWasm(func, sig);
}

function removeFunction(index) {
  removeFunctionWasm(index);
}



var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low >>> 0))) + ((+((high >>> 0))) * 4294967296.0)) : ((+((low >>> 0))) + ((+((high | 0))) * 4294967296.0));
}

/** @param {Array=} args */
function dynCall(sig, ptr, args) {
  if (args && args.length) {
    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
    assert(args.length === sig.substring(1).replace(/j/g, '--').length);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    assert(sig.length == 1);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function (value) {
  tempRet0 = value;
};

var getTempRet0 = function () {
  return tempRet0;
};

function getCompilerSetting(name) {
  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';
}

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;



/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


var wasmBinary; if (Module['wasmBinary']) wasmBinary = Module['wasmBinary']; if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', { configurable: true, get: function () { abort('Module.wasmBinary has been replaced with plain wasmBinary') } });
var noExitRuntime; if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime']; if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', { configurable: true, get: function () { abort('Module.noExitRuntime has been replaced with plain noExitRuntime') } });


if (typeof WebAssembly !== 'object') {
  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit
  if (noSafe) {
    switch (type) {
      case 'i1': HEAP8[((ptr) >> 0)] = value; break;
      case 'i8': HEAP8[((ptr) >> 0)] = value; break;
      case 'i16': HEAP16[((ptr) >> 1)] = value; break;
      case 'i32': HEAP32[((ptr) >> 2)] = value; break;
      case 'i64': (tempI64 = [value >>> 0, (tempDouble = value, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], HEAP32[((ptr) >> 2)] = tempI64[0], HEAP32[(((ptr) + (4)) >> 2)] = tempI64[1]); break;
      case 'float': HEAPF32[((ptr) >> 2)] = value; break;
      case 'double': HEAPF64[((ptr) >> 3)] = value; break;
      default: abort('invalid type for setValue: ' + type);
    }
  } else {
    switch (type) {
      case 'i1': SAFE_HEAP_STORE(((ptr) | 0), ((value) | 0), 1); break;
      case 'i8': SAFE_HEAP_STORE(((ptr) | 0), ((value) | 0), 1); break;
      case 'i16': SAFE_HEAP_STORE(((ptr) | 0), ((value) | 0), 2); break;
      case 'i32': SAFE_HEAP_STORE(((ptr) | 0), ((value) | 0), 4); break;
      case 'i64': (tempI64 = [value >>> 0, (tempDouble = value, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], SAFE_HEAP_STORE(((ptr) | 0), ((tempI64[0]) | 0), 4), SAFE_HEAP_STORE((((ptr) + (4)) | 0), ((tempI64[1]) | 0), 4)); break;
      case 'float': SAFE_HEAP_STORE_D(((ptr) | 0), Math_fround(value), 4); break;
      case 'double': SAFE_HEAP_STORE_D(((ptr) | 0), (+(value)), 8); break;
      default: abort('invalid type for setValue: ' + type);
    }
  }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit
  if (noSafe) {
    switch (type) {
      case 'i1': return HEAP8[((ptr) >> 0)];
      case 'i8': return HEAP8[((ptr) >> 0)];
      case 'i16': return HEAP16[((ptr) >> 1)];
      case 'i32': return HEAP32[((ptr) >> 2)];
      case 'i64': return HEAP32[((ptr) >> 2)];
      case 'float': return HEAPF32[((ptr) >> 2)];
      case 'double': return HEAPF64[((ptr) >> 3)];
      default: abort('invalid type for getValue: ' + type);
    }
  } else {
    switch (type) {
      case 'i1': return ((SAFE_HEAP_LOAD(((ptr) | 0), 1, 0)) | 0);
      case 'i8': return ((SAFE_HEAP_LOAD(((ptr) | 0), 1, 0)) | 0);
      case 'i16': return ((SAFE_HEAP_LOAD(((ptr) | 0), 2, 0)) | 0);
      case 'i32': return ((SAFE_HEAP_LOAD(((ptr) | 0), 4, 0)) | 0);
      case 'i64': return ((SAFE_HEAP_LOAD(((ptr) | 0), 8, 0)) | 0);
      case 'float': return Math_fround(SAFE_HEAP_LOAD_D(((ptr) | 0), 4, 0));
      case 'double': return (+(SAFE_HEAP_LOAD_D(((ptr) | 0), 8, 0)));
      default: abort('invalid type for getValue: ' + type);
    }
  }
  return null;
}


/** @param {number|boolean=} isFloat */
function getSafeHeapType(bytes, isFloat) {
  switch (bytes) {
    case 1: return 'i8';
    case 2: return 'i16';
    case 4: return isFloat ? 'float' : 'i32';
    case 8: return 'double';
    default: assert(0);
  }
}


/** @param {number|boolean=} isFloat */
function SAFE_HEAP_STORE(dest, value, bytes, isFloat) {
  if (dest <= 0) abort('segmentation fault storing ' + bytes + ' bytes to address ' + dest);
  if (dest % bytes !== 0) abort('alignment error storing to address ' + dest + ', which was expected to be aligned to a multiple of ' + bytes);
  if (dest + bytes > HEAPU32[DYNAMICTOP_PTR >> 2]) abort('segmentation fault, exceeded the top of the available dynamic heap when storing ' + bytes + ' bytes to address ' + dest + '. DYNAMICTOP=' + HEAP32[DYNAMICTOP_PTR >> 2]);
  assert(DYNAMICTOP_PTR);
  assert(HEAP32[DYNAMICTOP_PTR >> 2] <= HEAP8.length);
  setValue(dest, value, getSafeHeapType(bytes, isFloat), 1);
}
function SAFE_HEAP_STORE_D(dest, value, bytes) {
  SAFE_HEAP_STORE(dest, value, bytes, true);
}

/** @param {number|boolean=} isFloat */
function SAFE_HEAP_LOAD(dest, bytes, unsigned, isFloat) {
  if (dest <= 0) abort('segmentation fault loading ' + bytes + ' bytes from address ' + dest);
  if (dest % bytes !== 0) abort('alignment error loading from address ' + dest + ', which was expected to be aligned to a multiple of ' + bytes);
  if (dest + bytes > HEAPU32[DYNAMICTOP_PTR >> 2]) abort('segmentation fault, exceeded the top of the available dynamic heap when loading ' + bytes + ' bytes from address ' + dest + '. DYNAMICTOP=' + HEAP32[DYNAMICTOP_PTR >> 2]);
  assert(DYNAMICTOP_PTR);
  assert(HEAP32[DYNAMICTOP_PTR >> 2] <= HEAP8.length);
  var type = getSafeHeapType(bytes, isFloat);
  var ret = getValue(dest, type, 1);
  if (unsigned) ret = unSign(ret, parseInt(type.substr(1), 10), 1);
  return ret;
}
function SAFE_HEAP_LOAD_D(dest, bytes, unsigned) {
  return SAFE_HEAP_LOAD(dest, bytes, unsigned, true);
}

function SAFE_FT_MASK(value, mask) {
  var ret = value & mask;
  if (ret !== value) {
    abort('Function table mask error: function pointer is ' + value + ' which is masked by ' + mask + ', the likely cause of this is that the function pointer is being called by the wrong type.');
  }
  return ret;
}

function segfault() {
  abort('segmentation fault');
}
function alignfault() {
  abort('alignment fault');
}
function ftfault() {
  abort('Function table mask error');
}



// Wasm globals

var wasmMemory;

// In fastcomp asm.js, we don't need a wasm Table at all.
// In the wasm backend, we polyfill the WebAssembly object,
// so this creates a (non-native-wasm) table for us.
var wasmTable = new WebAssembly.Table({
  'initial': 354,
  'maximum': 354 + 0,
  'element': 'anyfunc'
});


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function (str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function (arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  return function () {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
      stackAlloc,
      dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr) >> 2)] = 0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++) >> 0)] = 0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */(slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret + i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}



/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = ((SAFE_HEAP_LOAD(((ptr++) | 0), 1, 1)) | 0);
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = ((SAFE_HEAP_LOAD((((ptr) + (i * 2)) | 0), 2, 0)) | 0);
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length * 2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    SAFE_HEAP_STORE(((outPtr) | 0), ((codeUnit) | 0), 2);
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  SAFE_HEAP_STORE(((outPtr) | 0), ((0) | 0), 2);
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length * 2;
}

function UTF32ToString(ptr) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = ((SAFE_HEAP_LOAD((((ptr) + (i * 4)) | 0), 4, 0)) | 0);
    if (utf32 == 0) return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    SAFE_HEAP_STORE(((outPtr) | 0), ((codeUnit) | 0), 4);
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  SAFE_HEAP_STORE(((outPtr) | 0), ((0) | 0), 4);
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);
    SAFE_HEAP_STORE(((buffer++) | 0), ((str.charCodeAt(i)) | 0), 1);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) SAFE_HEAP_STORE(((buffer) | 0), ((0) | 0), 1);
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
  /** @type {ArrayBuffer} */
  buffer,
  /** @type {Int8Array} */
  HEAP8,
  /** @type {Uint8Array} */
  HEAPU8,
  /** @type {Int16Array} */
  HEAP16,
  /** @type {Uint16Array} */
  HEAPU16,
  /** @type {Int32Array} */
  HEAP32,
  /** @type {Uint32Array} */
  HEAPU32,
  /** @type {Float32Array} */
  HEAPF32,
  /** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var STATIC_BASE = 1024,
  STACK_BASE = 10218224,
  STACKTOP = STACK_BASE,
  STACK_MAX = 4975344,
  DYNAMIC_BASE = 10218224,
  DYNAMICTOP_PTR = 4975184;

assert(STACK_BASE % 16 === 0, 'stack must start aligned');
assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');



var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 536870912; if (!Object.getOwnPropertyDescriptor(Module, 'INITIAL_MEMORY')) Object.defineProperty(Module, 'INITIAL_MEMORY', { configurable: true, get: function () { abort('Module.INITIAL_MEMORY has been replaced with plain INITIAL_INITIAL_MEMORY') } });

assert(INITIAL_INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,
  'JS engine does not provide full typed array support');



/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




// In standalone mode, the wasm creates the memory, and the user can't provide it.
// In non-standalone/normal mode, we create the memory here.

/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm
// memory is created in the wasm, not in JS.)

if (Module['wasmMemory']) {
  wasmMemory = Module['wasmMemory'];
} else {
  wasmMemory = new WebAssembly.Memory({
    'initial': INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
    ,
    'maximum': 2147483648 / WASM_PAGE_SIZE
  });
}


if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_INITIAL_MEMORY = buffer.byteLength;
assert(INITIAL_INITIAL_MEMORY % WASM_PAGE_SIZE === 0);
assert(65536 % WASM_PAGE_SIZE === 0);
updateGlobalBufferAndViews(buffer);

HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  assert((STACK_MAX & 3) == 0);
  // The stack grows downwards
  HEAPU32[(STACK_MAX >> 2) + 1] = 0x2135467;
  HEAPU32[(STACK_MAX >> 2) + 2] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  HEAP32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  var cookie1 = HEAPU32[(STACK_MAX >> 2) + 1];
  var cookie2 = HEAPU32[(STACK_MAX >> 2) + 2];
  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));
  }
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

function abortStackOverflow(allocSize) {
  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');
}




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Endianness check (note: assumes compiler arch was little-endian)
(function () {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';
})();

function abortFnPtrError(ptr, sig) {
  abort("Invalid function pointer " + ptr + " called with signature '" + sig + "'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.");
}



function callRuntimeCallbacks(callbacks) {
  while (callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback(Module); // Pass the module as the first argument.
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__ = []; // functions called before the runtime is initialized
var __ATINIT__ = []; // functions called during startup
var __ATMAIN__ = []; // functions called when main() is to be run
var __ATEXIT__ = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  checkStackCookie();
  assert(!runtimeInitialized);
  runtimeInitialized = true;
  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
  TTY.init();
  PIPEFS.root = FS.mount(PIPEFS, {}, null);
  SOCKFS.root = FS.mount(SOCKFS, {}, null);
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  FS.ignorePermissions = false;
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  checkStackCookie();
  runtimeExited = true;
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

/** @param {number|boolean=} ignore */
function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2 * Math.abs(1 << (bits - 1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
    : Math.pow(2, bits) + value;
}
/** @param {number|boolean=} ignore */
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits - 1)) // abs is needed if bits == 32
    : Math.pow(2, bits - 1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
    // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
    // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function () {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  out(what);
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  var output = 'abort(' + what + ') at ' + stackTrace();
  what = output;

  // Throw a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  throw new WebAssembly.RuntimeError(what);
}


var memoryInitializer = null;


/**
 * @license
 * Copyright 2015 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */







/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

function hasPrefix(str, prefix) {
  return String.prototype.startsWith ?
    str.startsWith(prefix) :
    str.indexOf(prefix) === 0;
}

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return hasPrefix(filename, fileURIPrefix);
}



var wasmBinaryFile = 'rnnoise_demo.wasm';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }

    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, and have the Fetch api, use that;
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function'
    // Let's not use fetch to get objects over file:// as it's most likely Cordova which doesn't support fetch for file://
    && !isFileURI(wasmBinaryFile)
  ) {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function (resolve, reject) {
    resolve(getBinary());
  });
}


var wasmOffsetConverter;

/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

function WasmOffsetConverter(wasmBytes, wasmModule) {
  // This class parses a WASM binary file, and constructs a mapping from
  // function indices to the start of their code in the binary file, as well
  // as parsing the name section to allow conversion of offsets to function names.
  //
  // The main purpose of this module is to enable the conversion of function
  // index and offset from start of function to an offset into the WASM binary.
  // This is needed to look up the WASM source map as well as generate
  // consistent program counter representations given v8's non-standard
  // WASM stack trace format.
  //
  // v8 bug: https://crbug.com/v8/9172
  //
  // This code is also used to check if the candidate source map offset is
  // actually part of the same function as the offset we are looking for,
  // as well as providing the function names for a given offset.

  // current byte offset into the WASM binary, as we parse it
  // the first section starts at offset 8.
  var offset = 8;

  // the index of the next function we see in the binary
  var funcidx = 0;

  // map from function index to byte offset in WASM binary
  this.offset_map = {};
  this.func_starts = [];

  // map from function index to names in WASM binary
  this.name_map = {};

  // number of imported functions this module has
  this.import_functions = 0;

  // the buffer unsignedLEB128 will read from.
  var buffer = wasmBytes;

  function unsignedLEB128() {
    // consumes an unsigned LEB128 integer starting at `offset`.
    // changes `offset` to immediately after the integer
    var result = 0;
    var shift = 0;
    do {
      var byte = buffer[offset++];
      result += (byte & 0x7F) << shift;
      shift += 7;
    } while (byte & 0x80);
    return result;
  }

  function skipLimits() {
    var flags = unsignedLEB128();
    unsignedLEB128(); // initial size
    var hasMax = (flags & 1) != 0;
    if (hasMax) {
      unsignedLEB128();
    }
  }

  binary_parse:
  while (offset < buffer.length) {
    var start = offset;
    var type = buffer[offset++];
    var end = unsignedLEB128() + offset;
    switch (type) {
      case 2: // import section
        // we need to find all function imports and increment funcidx for each one
        // since functions defined in the module are numbered after all imports
        var count = unsignedLEB128();

        while (count-- > 0) {
          // skip module
          offset = unsignedLEB128() + offset;
          // skip name
          offset = unsignedLEB128() + offset;

          switch (buffer[offset++]) {
            case 0: // function import
              ++funcidx;
              unsignedLEB128(); // skip function type
              break;
            case 1: // table import
              ++offset; // FIXME: should be SLEB128
              skipLimits();
              break;
            case 2: // memory import
              skipLimits();
              break;
            case 3: // global import
              offset += 2; // skip type id byte and mutability byte
              break;
            default: throw 'bad import kind';
          }
        }
        this.import_functions = funcidx;
        break;
      case 10: // code section
        var count = unsignedLEB128();
        while (count-- > 0) {
          var size = unsignedLEB128();
          this.offset_map[funcidx++] = offset;
          this.func_starts.push(offset);
          offset += size;
        }
        break binary_parse;
    }
    offset = end;
  }

  var sections = WebAssembly.Module.customSections(wasmModule, "name");
  for (var i = 0; i < sections.length; ++i) {
    buffer = new Uint8Array(sections[i]);
    if (buffer[0] != 1) // not a function name section
      continue;
    offset = 1;
    unsignedLEB128(); // skip byte count
    var count = unsignedLEB128();
    while (count-- > 0) {
      var index = unsignedLEB128();
      var length = unsignedLEB128();
      this.name_map[index] = UTF8ArrayToString(buffer, offset, length);
      offset += length;
    }
  }
}

WasmOffsetConverter.prototype.convert = function (funcidx, offset) {
  return this.offset_map[funcidx] + offset;
}

WasmOffsetConverter.prototype.getIndex = function (offset) {
  var lo = 0;
  var hi = this.func_starts.length;
  var mid;

  while (lo < hi) {
    mid = Math.floor((lo + hi) / 2);
    if (this.func_starts[mid] > offset) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return lo + this.import_functions - 1;
}

WasmOffsetConverter.prototype.isSameFunc = function (offset1, offset2) {
  return this.getIndex(offset1) == this.getIndex(offset2);
}

WasmOffsetConverter.prototype.getName = function (offset) {
  var index = this.getIndex(offset);
  return this.name_map[index] || ('wasm-function[' + index + ']');
}



// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');


  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }

  addRunDependency('offset-converter');

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function (binary) {
      var result = WebAssembly.instantiate(binary, info);
      result.then(function (instance) {
        wasmOffsetConverter = new WasmOffsetConverter(binary, instance.module);
        removeRunDependency('offset-converter');
      });
      return result;
    }).then(receiver, function (reason) {
      err('failed to asynchronously prepare wasm: ' + reason);
      abort(reason);
    });
  }

  // Prefer streaming instantiation if available.
  function instantiateAsync() {
    if (!wasmBinary &&
      typeof WebAssembly.instantiateStreaming === 'function' &&
      !isDataURI(wasmBinaryFile) &&
      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
      !isFileURI(wasmBinaryFile) &&
      typeof fetch === 'function') {
      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        // This doesn't actually do another request, it only copies the Response object.
        // Copying lets us consume it independently of WebAssembly.instantiateStreaming.
        Promise.all([response.clone().arrayBuffer(), result]).then(function (results) {
          wasmOffsetConverter = new WasmOffsetConverter(new Uint8Array(results[0]), results[1].module);
          removeRunDependency('offset-converter');
        });
        return result.then(receiveInstantiatedSource, function (reason) {
          // We expect the most common failure cause to be a bad MIME type for the binary,
          // in which case falling back to ArrayBuffer instantiation should work.
          err('wasm streaming compile failed: ' + reason);
          err('falling back to ArrayBuffer instantiation');
          instantiateArrayBuffer(receiveInstantiatedSource);
        });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiatedSource);
    }
  }
  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch (e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}


// Globals used by JS i64 conversions
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  278985: function () { return _emscripten_with_builtin_malloc(function () { return allocateUTF8(Module['UBSAN_OPTIONS'] || 0); }); },
  279479: function () { return STACK_BASE; },
  279502: function () { return STACK_MAX; },
  280561: function () { var setting = Module['printWithColors']; if (setting != null) { return setting; } else { return ENVIRONMENT_IS_NODE && process.stderr.isTTY; } }
};

function _emscripten_asm_const_iii(code, sigPtr, argbuf) {
  var args = readAsmConstArgs(sigPtr, argbuf);
  return ASM_CONSTS[code].apply(null, args);
}



// STATICTOP = STATIC_BASE + 4974320;
/* global initializers */  __ATINIT__.push({ func: function () { ___wasm_call_ctors() } });




/* no memory initializer */
// {{PRE_LIBRARY}}


function demangle(func) {
  warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
  return func;
}
Module["demangle"] = demangle;

function demangleAll(text) {
  var regex =
    /\b_Z[\w\d_]+/g;
  return text.replace(regex,
    function (x) {
      var y = demangle(x);
      return x === y ? x : (y + ' [' + x + ']');
    });
}
Module["demangleAll"] = demangleAll;

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error();
    } catch (e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}
Module["jsStackTrace"] = jsStackTrace;

function stackTrace() {
  var js = jsStackTrace();
  if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
  return demangleAll(js);
}
Module["stackTrace"] = stackTrace;

/** @type {function(...*):?} */
function __Z18__wasi_syscall_rett(
) {
  err('missing function: _Z18__wasi_syscall_rett'); abort(-1);
}
Module["__Z18__wasi_syscall_rett"] = __Z18__wasi_syscall_rett;

/** @type {function(...*):?} */
function __ZN11__sanitizer15__clock_gettimeEiPv(
) {
  err('missing function: _ZN11__sanitizer15__clock_gettimeEiPv'); abort(-1);
}
Module["__ZN11__sanitizer15__clock_gettimeEiPv"] = __ZN11__sanitizer15__clock_gettimeEiPv;

/** @type {function(...*):?} */
function __ZN11__sanitizer17SymbolizerProcess25StartSymbolizerSubprocessEv(
) {
  err('missing function: _ZN11__sanitizer17SymbolizerProcess25StartSymbolizerSubprocessEv'); abort(-1);
}
Module["__ZN11__sanitizer17SymbolizerProcess25StartSymbolizerSubprocessEv"] = __ZN11__sanitizer17SymbolizerProcess25StartSymbolizerSubprocessEv;



var _emscripten_get_now; if (ENVIRONMENT_IS_NODE) {
  _emscripten_get_now = function () {
    var t = process['hrtime']();
    return t[0] * 1e3 + t[1] / 1e6;
  };
} else if (typeof dateNow !== 'undefined') {
  _emscripten_get_now = dateNow;
} else _emscripten_get_now = function () { return performance.now(); }
  ;
Module["_emscripten_get_now"] = _emscripten_get_now;

var _emscripten_get_now_is_monotonic = true;;
Module["_emscripten_get_now_is_monotonic"] = _emscripten_get_now_is_monotonic;

function setErrNo(value) {
  SAFE_HEAP_STORE(((___errno_location()) | 0), ((value) | 0), 4);
  return value;
}
Module["setErrNo"] = setErrNo; function _clock_gettime(clk_id, tp) {
  // int clock_gettime(clockid_t clk_id, struct timespec *tp);
  var now;
  if (clk_id === 0) {
    now = Date.now();
  } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
    now = _emscripten_get_now();
  } else {
    setErrNo(28);
    return -1;
  }
  SAFE_HEAP_STORE(((tp) | 0), (((now / 1000) | 0) | 0), 4); // seconds
  SAFE_HEAP_STORE((((tp) + (4)) | 0), ((((now % 1000) * 1000 * 1000) | 0) | 0), 4); // nanoseconds
  return 0;
}
Module["_clock_gettime"] = _clock_gettime; function ___clock_gettime(a0, a1
) {
  return _clock_gettime(a0, a1);
}
Module["___clock_gettime"] = ___clock_gettime;

function ___handle_stack_overflow() {
  abort('stack overflow')
}
Module["___handle_stack_overflow"] = ___handle_stack_overflow;

function ___map_file(pathname, size) {
  setErrNo(63);
  return -1;
}
Module["___map_file"] = ___map_file;

function ___sys__newselect(nfds, readfds, writefds, exceptfds, timeout) {
  // readfds are supported,
  // writefds checks socket open status
  // exceptfds not supported
  // timeout is always 0 - fully async
  assert(nfds <= 64, 'nfds must be less than or equal to 64');  // fd sets have 64 bits // TODO: this could be 1024 based on current musl headers
  assert(!exceptfds, 'exceptfds not supported');

  var total = 0;

  var srcReadLow = (readfds ? ((SAFE_HEAP_LOAD(((readfds) | 0), 4, 0)) | 0) : 0),
    srcReadHigh = (readfds ? ((SAFE_HEAP_LOAD((((readfds) + (4)) | 0), 4, 0)) | 0) : 0);
  var srcWriteLow = (writefds ? ((SAFE_HEAP_LOAD(((writefds) | 0), 4, 0)) | 0) : 0),
    srcWriteHigh = (writefds ? ((SAFE_HEAP_LOAD((((writefds) + (4)) | 0), 4, 0)) | 0) : 0);
  var srcExceptLow = (exceptfds ? ((SAFE_HEAP_LOAD(((exceptfds) | 0), 4, 0)) | 0) : 0),
    srcExceptHigh = (exceptfds ? ((SAFE_HEAP_LOAD((((exceptfds) + (4)) | 0), 4, 0)) | 0) : 0);

  var dstReadLow = 0,
    dstReadHigh = 0;
  var dstWriteLow = 0,
    dstWriteHigh = 0;
  var dstExceptLow = 0,
    dstExceptHigh = 0;

  var allLow = (readfds ? ((SAFE_HEAP_LOAD(((readfds) | 0), 4, 0)) | 0) : 0) |
    (writefds ? ((SAFE_HEAP_LOAD(((writefds) | 0), 4, 0)) | 0) : 0) |
    (exceptfds ? ((SAFE_HEAP_LOAD(((exceptfds) | 0), 4, 0)) | 0) : 0);
  var allHigh = (readfds ? ((SAFE_HEAP_LOAD((((readfds) + (4)) | 0), 4, 0)) | 0) : 0) |
    (writefds ? ((SAFE_HEAP_LOAD((((writefds) + (4)) | 0), 4, 0)) | 0) : 0) |
    (exceptfds ? ((SAFE_HEAP_LOAD((((exceptfds) + (4)) | 0), 4, 0)) | 0) : 0);

  var check = function (fd, low, high, val) {
    return (fd < 32 ? (low & val) : (high & val));
  };

  for (var fd = 0; fd < nfds; fd++) {
    var mask = 1 << (fd % 32);
    if (!(check(fd, allLow, allHigh, mask))) {
      continue;  // index isn't in the set
    }

    var stream = FS.getStream(fd);
    if (!stream) throw new FS.ErrnoError(8);

    var flags = SYSCALLS.DEFAULT_POLLMASK;

    if (stream.stream_ops.poll) {
      flags = stream.stream_ops.poll(stream);
    }

    if ((flags & 1) && check(fd, srcReadLow, srcReadHigh, mask)) {
      fd < 32 ? (dstReadLow = dstReadLow | mask) : (dstReadHigh = dstReadHigh | mask);
      total++;
    }
    if ((flags & 4) && check(fd, srcWriteLow, srcWriteHigh, mask)) {
      fd < 32 ? (dstWriteLow = dstWriteLow | mask) : (dstWriteHigh = dstWriteHigh | mask);
      total++;
    }
    if ((flags & 2) && check(fd, srcExceptLow, srcExceptHigh, mask)) {
      fd < 32 ? (dstExceptLow = dstExceptLow | mask) : (dstExceptHigh = dstExceptHigh | mask);
      total++;
    }
  }

  if (readfds) {
    SAFE_HEAP_STORE(((readfds) | 0), ((dstReadLow) | 0), 4);
    SAFE_HEAP_STORE((((readfds) + (4)) | 0), ((dstReadHigh) | 0), 4);
  }
  if (writefds) {
    SAFE_HEAP_STORE(((writefds) | 0), ((dstWriteLow) | 0), 4);
    SAFE_HEAP_STORE((((writefds) + (4)) | 0), ((dstWriteHigh) | 0), 4);
  }
  if (exceptfds) {
    SAFE_HEAP_STORE(((exceptfds) | 0), ((dstExceptLow) | 0), 4);
    SAFE_HEAP_STORE((((exceptfds) + (4)) | 0), ((dstExceptHigh) | 0), 4);
  }

  return total;
}
Module["___sys__newselect"] = ___sys__newselect;



var PATH = {
  splitPath: function (filename) {
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    return splitPathRe.exec(filename).slice(1);
  }, normalizeArray: function (parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
      for (; up; up--) {
        parts.unshift('..');
      }
    }
    return parts;
  }, normalize: function (path) {
    var isAbsolute = path.charAt(0) === '/',
      trailingSlash = path.substr(-1) === '/';
    // Normalize the path
    path = PATH.normalizeArray(path.split('/').filter(function (p) {
      return !!p;
    }), !isAbsolute).join('/');
    if (!path && !isAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }
    return (isAbsolute ? '/' : '') + path;
  }, dirname: function (path) {
    var result = PATH.splitPath(path),
      root = result[0],
      dir = result[1];
    if (!root && !dir) {
      // No dirname whatsoever
      return '.';
    }
    if (dir) {
      // It has a dirname, strip trailing slash
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  }, basename: function (path) {
    // EMSCRIPTEN return '/'' for '/', not an empty string
    if (path === '/') return '/';
    var lastSlash = path.lastIndexOf('/');
    if (lastSlash === -1) return path;
    return path.substr(lastSlash + 1);
  }, extname: function (path) {
    return PATH.splitPath(path)[3];
  }, join: function () {
    var paths = Array.prototype.slice.call(arguments, 0);
    return PATH.normalize(paths.join('/'));
  }, join2: function (l, r) {
    return PATH.normalize(l + '/' + r);
  }
};
Module["PATH"] = PATH;


var PATH_FS = {
  resolve: function () {
    var resolvedPath = '',
      resolvedAbsolute = false;
    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments[i] : FS.cwd();
      // Skip empty and invalid entries
      if (typeof path !== 'string') {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        return ''; // an invalid portion invalidates the whole thing
      }
      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function (p) {
      return !!p;
    }), !resolvedAbsolute).join('/');
    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  }, relative: function (from, to) {
    from = PATH_FS.resolve(from).substr(1);
    to = PATH_FS.resolve(to).substr(1);
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }
      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }
    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('/');
  }
};
Module["PATH_FS"] = PATH_FS;

var TTY = {
  ttys: [], init: function () {
    // https://github.com/emscripten-core/emscripten/pull/1555
    // if (ENVIRONMENT_IS_NODE) {
    //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
    //   // device, it always assumes it's a TTY device. because of this, we're forcing
    //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
    //   // with text files until FS.init can be refactored.
    //   process['stdin']['setEncoding']('utf8');
    // }
  }, shutdown: function () {
    // https://github.com/emscripten-core/emscripten/pull/1555
    // if (ENVIRONMENT_IS_NODE) {
    //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
    //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
    //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
    //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
    //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
    //   process['stdin']['pause']();
    // }
  }, register: function (dev, ops) {
    TTY.ttys[dev] = { input: [], output: [], ops: ops };
    FS.registerDevice(dev, TTY.stream_ops);
  }, stream_ops: {
    open: function (stream) {
      var tty = TTY.ttys[stream.node.rdev];
      if (!tty) {
        throw new FS.ErrnoError(43);
      }
      stream.tty = tty;
      stream.seekable = false;
    }, close: function (stream) {
      // flush any pending line data
      stream.tty.ops.flush(stream.tty);
    }, flush: function (stream) {
      stream.tty.ops.flush(stream.tty);
    }, read: function (stream, buffer, offset, length, pos /* ignored */) {
      if (!stream.tty || !stream.tty.ops.get_char) {
        throw new FS.ErrnoError(60);
      }
      var bytesRead = 0;
      for (var i = 0; i < length; i++) {
        var result;
        try {
          result = stream.tty.ops.get_char(stream.tty);
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (result === undefined && bytesRead === 0) {
          throw new FS.ErrnoError(6);
        }
        if (result === null || result === undefined) break;
        bytesRead++;
        buffer[offset + i] = result;
      }
      if (bytesRead) {
        stream.node.timestamp = Date.now();
      }
      return bytesRead;
    }, write: function (stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.put_char) {
        throw new FS.ErrnoError(60);
      }
      try {
        for (var i = 0; i < length; i++) {
          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
        }
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
      if (length) {
        stream.node.timestamp = Date.now();
      }
      return i;
    }
  }, default_tty_ops: {
    get_char: function (tty) {
      if (!tty.input.length) {
        var result = null;
        if (ENVIRONMENT_IS_NODE) {
          // we will read data by chunks of BUFSIZE
          var BUFSIZE = 256;
          var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
          var bytesRead = 0;

          try {
            bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
          } catch (e) {
            // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
            // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
            if (e.toString().indexOf('EOF') != -1) bytesRead = 0;
            else throw e;
          }

          if (bytesRead > 0) {
            result = buf.slice(0, bytesRead).toString('utf-8');
          } else {
            result = null;
          }
        } else
          if (typeof window != 'undefined' &&
            typeof window.prompt == 'function') {
            // Browser.
            result = window.prompt('Input: ');  // returns null on cancel
            if (result !== null) {
              result += '\n';
            }
          } else if (typeof readline == 'function') {
            // Command line.
            result = readline();
            if (result !== null) {
              result += '\n';
            }
          }
        if (!result) {
          return null;
        }
        tty.input = intArrayFromString(result, true);
      }
      return tty.input.shift();
    }, put_char: function (tty, val) {
      if (val === null || val === 10) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
      }
    }, flush: function (tty) {
      if (tty.output && tty.output.length > 0) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    }
  }, default_tty1_ops: {
    put_char: function (tty, val) {
      if (val === null || val === 10) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    }, flush: function (tty) {
      if (tty.output && tty.output.length > 0) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    }
  }
};
Module["TTY"] = TTY;

var MEMFS = {
  ops_table: null, mount: function (mount) {
    return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
  }, createNode: function (parent, name, mode, dev) {
    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
      // no supported
      throw new FS.ErrnoError(63);
    }
    if (!MEMFS.ops_table) {
      MEMFS.ops_table = {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek
          }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
    }
    var node = FS.createNode(parent, name, mode, dev);
    if (FS.isDir(node.mode)) {
      node.node_ops = MEMFS.ops_table.dir.node;
      node.stream_ops = MEMFS.ops_table.dir.stream;
      node.contents = {};
    } else if (FS.isFile(node.mode)) {
      node.node_ops = MEMFS.ops_table.file.node;
      node.stream_ops = MEMFS.ops_table.file.stream;
      node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
      // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
      // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
      // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
      node.contents = null;
    } else if (FS.isLink(node.mode)) {
      node.node_ops = MEMFS.ops_table.link.node;
      node.stream_ops = MEMFS.ops_table.link.stream;
    } else if (FS.isChrdev(node.mode)) {
      node.node_ops = MEMFS.ops_table.chrdev.node;
      node.stream_ops = MEMFS.ops_table.chrdev.stream;
    }
    node.timestamp = Date.now();
    // add the new node to the parent
    if (parent) {
      parent.contents[name] = node;
    }
    return node;
  }, getFileDataAsRegularArray: function (node) {
    if (node.contents && node.contents.subarray) {
      var arr = [];
      for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
      return arr; // Returns a copy of the original data.
    }
    return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
  }, getFileDataAsTypedArray: function (node) {
    if (!node.contents) return new Uint8Array(0);
    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
    return new Uint8Array(node.contents);
  }, expandFileStorage: function (node, newCapacity) {
    var prevCapacity = node.contents ? node.contents.length : 0;
    if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
    // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
    // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
    // avoid overshooting the allocation cap by a very large margin.
    var CAPACITY_DOUBLING_MAX = 1024 * 1024;
    newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
    var oldContents = node.contents;
    node.contents = new Uint8Array(newCapacity); // Allocate new storage.
    if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
    return;
  }, resizeFileStorage: function (node, newSize) {
    if (node.usedBytes == newSize) return;
    if (newSize == 0) {
      node.contents = null; // Fully decommit when requesting a resize to zero.
      node.usedBytes = 0;
      return;
    }
    if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
      var oldContents = node.contents;
      node.contents = new Uint8Array(newSize); // Allocate new storage.
      if (oldContents) {
        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
      }
      node.usedBytes = newSize;
      return;
    }
    // Backing with a JS array.
    if (!node.contents) node.contents = [];
    if (node.contents.length > newSize) node.contents.length = newSize;
    else while (node.contents.length < newSize) node.contents.push(0);
    node.usedBytes = newSize;
  }, node_ops: {
    getattr: function (node) {
      var attr = {};
      // device numbers reuse inode numbers.
      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
      attr.ino = node.id;
      attr.mode = node.mode;
      attr.nlink = 1;
      attr.uid = 0;
      attr.gid = 0;
      attr.rdev = node.rdev;
      if (FS.isDir(node.mode)) {
        attr.size = 4096;
      } else if (FS.isFile(node.mode)) {
        attr.size = node.usedBytes;
      } else if (FS.isLink(node.mode)) {
        attr.size = node.link.length;
      } else {
        attr.size = 0;
      }
      attr.atime = new Date(node.timestamp);
      attr.mtime = new Date(node.timestamp);
      attr.ctime = new Date(node.timestamp);
      // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
      //       but this is not required by the standard.
      attr.blksize = 4096;
      attr.blocks = Math.ceil(attr.size / attr.blksize);
      return attr;
    }, setattr: function (node, attr) {
      if (attr.mode !== undefined) {
        node.mode = attr.mode;
      }
      if (attr.timestamp !== undefined) {
        node.timestamp = attr.timestamp;
      }
      if (attr.size !== undefined) {
        MEMFS.resizeFileStorage(node, attr.size);
      }
    }, lookup: function (parent, name) {
      throw FS.genericErrors[44];
    }, mknod: function (parent, name, mode, dev) {
      return MEMFS.createNode(parent, name, mode, dev);
    }, rename: function (old_node, new_dir, new_name) {
      // if we're overwriting a directory at new_name, make sure it's empty.
      if (FS.isDir(old_node.mode)) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          for (var i in new_node.contents) {
            throw new FS.ErrnoError(55);
          }
        }
      }
      // do the internal rewiring
      delete old_node.parent.contents[old_node.name];
      old_node.name = new_name;
      new_dir.contents[new_name] = old_node;
      old_node.parent = new_dir;
    }, unlink: function (parent, name) {
      delete parent.contents[name];
    }, rmdir: function (parent, name) {
      var node = FS.lookupNode(parent, name);
      for (var i in node.contents) {
        throw new FS.ErrnoError(55);
      }
      delete parent.contents[name];
    }, readdir: function (node) {
      var entries = ['.', '..'];
      for (var key in node.contents) {
        if (!node.contents.hasOwnProperty(key)) {
          continue;
        }
        entries.push(key);
      }
      return entries;
    }, symlink: function (parent, newname, oldpath) {
      var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
      node.link = oldpath;
      return node;
    }, readlink: function (node) {
      if (!FS.isLink(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      return node.link;
    }
  }, stream_ops: {
    read: function (stream, buffer, offset, length, position) {
      var contents = stream.node.contents;
      if (position >= stream.node.usedBytes) return 0;
      var size = Math.min(stream.node.usedBytes - position, length);
      assert(size >= 0);
      if (size > 8 && contents.subarray) { // non-trivial, and typed array
        buffer.set(contents.subarray(position, position + size), offset);
      } else {
        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
      }
      return size;
    }, write: function (stream, buffer, offset, length, position, canOwn) {
      // The data buffer should be a typed array view
      assert(!(buffer instanceof ArrayBuffer));
      // If the buffer is located in main memory (HEAP), and if
      // memory can grow, we can't hold on to references of the
      // memory buffer, as they may get invalidated. That means we
      // need to do copy its contents.
      if (buffer.buffer === HEAP8.buffer) {
        // FIXME: this is inefficient as the file packager may have
        //        copied the data into memory already - we may want to
        //        integrate more there and let the file packager loading
        //        code be able to query if memory growth is on or off.
        if (canOwn) {
          warnOnce('file packager has copied file data into memory, but in memory growth we are forced to copy it again (see --no-heap-copy)');
        }
        canOwn = false;
      }

      if (!length) return 0;
      var node = stream.node;
      node.timestamp = Date.now();

      if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
        if (canOwn) {
          assert(position === 0, 'canOwn must imply no weird position inside the file');
          node.contents = buffer.subarray(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
          node.contents = buffer.slice(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
          node.contents.set(buffer.subarray(offset, offset + length), position);
          return length;
        }
      }

      // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
      MEMFS.expandFileStorage(node, position + length);
      if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
      else {
        for (var i = 0; i < length; i++) {
          node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
        }
      }
      node.usedBytes = Math.max(node.usedBytes, position + length);
      return length;
    }, llseek: function (stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          position += stream.node.usedBytes;
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    }, allocate: function (stream, offset, length) {
      MEMFS.expandFileStorage(stream.node, offset + length);
      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
    }, mmap: function (stream, buffer, offset, length, position, prot, flags) {
      // The data buffer should be a typed array view
      assert(!(buffer instanceof ArrayBuffer));
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr;
      var allocated;
      var contents = stream.node.contents;
      // Only make a new copy when MAP_PRIVATE is specified.
      if (!(flags & 2) &&
        contents.buffer === buffer.buffer) {
        // We can't emulate MAP_SHARED when the file is not backed by the buffer
        // we're mapping to (e.g. the HEAP buffer).
        allocated = false;
        ptr = contents.byteOffset;
      } else {
        // Try to avoid unnecessary slices.
        if (position > 0 || position + length < contents.length) {
          if (contents.subarray) {
            contents = contents.subarray(position, position + length);
          } else {
            contents = Array.prototype.slice.call(contents, position, position + length);
          }
        }
        allocated = true;
        // malloc() can lead to growing the heap. If targeting the heap, we need to
        // re-acquire the heap buffer object in case growth had occurred.
        var fromHeap = (buffer.buffer == HEAP8.buffer);
        ptr = _malloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        (fromHeap ? HEAP8 : buffer).set(contents, ptr);
      }
      return { ptr: ptr, allocated: allocated };
    }, msync: function (stream, buffer, offset, length, mmapFlags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (mmapFlags & 2) {
        // MAP_PRIVATE calls need not to be synced back to underlying fs
        return 0;
      }

      var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
      // should we check if bytesWritten and length are the same?
      return 0;
    }
  }
};
Module["MEMFS"] = MEMFS;

var ERRNO_MESSAGES = { 0: "Success", 1: "Arg list too long", 2: "Permission denied", 3: "Address already in use", 4: "Address not available", 5: "Address family not supported by protocol family", 6: "No more processes", 7: "Socket already connected", 8: "Bad file number", 9: "Trying to read unreadable message", 10: "Mount device busy", 11: "Operation canceled", 12: "No children", 13: "Connection aborted", 14: "Connection refused", 15: "Connection reset by peer", 16: "File locking deadlock error", 17: "Destination address required", 18: "Math arg out of domain of func", 19: "Quota exceeded", 20: "File exists", 21: "Bad address", 22: "File too large", 23: "Host is unreachable", 24: "Identifier removed", 25: "Illegal byte sequence", 26: "Connection already in progress", 27: "Interrupted system call", 28: "Invalid argument", 29: "I/O error", 30: "Socket is already connected", 31: "Is a directory", 32: "Too many symbolic links", 33: "Too many open files", 34: "Too many links", 35: "Message too long", 36: "Multihop attempted", 37: "File or path name too long", 38: "Network interface is not configured", 39: "Connection reset by network", 40: "Network is unreachable", 41: "Too many open files in system", 42: "No buffer space available", 43: "No such device", 44: "No such file or directory", 45: "Exec format error", 46: "No record locks available", 47: "The link has been severed", 48: "Not enough core", 49: "No message of desired type", 50: "Protocol not available", 51: "No space left on device", 52: "Function not implemented", 53: "Socket is not connected", 54: "Not a directory", 55: "Directory not empty", 56: "State not recoverable", 57: "Socket operation on non-socket", 59: "Not a typewriter", 60: "No such device or address", 61: "Value too large for defined data type", 62: "Previous owner died", 63: "Not super-user", 64: "Broken pipe", 65: "Protocol error", 66: "Unknown protocol", 67: "Protocol wrong type for socket", 68: "Math result not representable", 69: "Read only file system", 70: "Illegal seek", 71: "No such process", 72: "Stale file handle", 73: "Connection timed out", 74: "Text file busy", 75: "Cross-device link", 100: "Device not a stream", 101: "Bad font file fmt", 102: "Invalid slot", 103: "Invalid request code", 104: "No anode", 105: "Block device required", 106: "Channel number out of range", 107: "Level 3 halted", 108: "Level 3 reset", 109: "Link number out of range", 110: "Protocol driver not attached", 111: "No CSI structure available", 112: "Level 2 halted", 113: "Invalid exchange", 114: "Invalid request descriptor", 115: "Exchange full", 116: "No data (for no delay io)", 117: "Timer expired", 118: "Out of streams resources", 119: "Machine is not on the network", 120: "Package not installed", 121: "The object is remote", 122: "Advertise error", 123: "Srmount error", 124: "Communication error on send", 125: "Cross mount point (not really error)", 126: "Given log. name not unique", 127: "f.d. invalid for this operation", 128: "Remote address changed", 129: "Can   access a needed shared lib", 130: "Accessing a corrupted shared lib", 131: ".lib section in a.out corrupted", 132: "Attempting to link in too many libs", 133: "Attempting to exec a shared library", 135: "Streams pipe error", 136: "Too many users", 137: "Socket type not supported", 138: "Not supported", 139: "Protocol family not supported", 140: "Can't send after socket shutdown", 141: "Too many references", 142: "Host is down", 148: "No medium (in tape drive)", 156: "Level 2 not synchronized" };
Module["ERRNO_MESSAGES"] = ERRNO_MESSAGES;

var ERRNO_CODES = { EPERM: 63, ENOENT: 44, ESRCH: 71, EINTR: 27, EIO: 29, ENXIO: 60, E2BIG: 1, ENOEXEC: 45, EBADF: 8, ECHILD: 12, EAGAIN: 6, EWOULDBLOCK: 6, ENOMEM: 48, EACCES: 2, EFAULT: 21, ENOTBLK: 105, EBUSY: 10, EEXIST: 20, EXDEV: 75, ENODEV: 43, ENOTDIR: 54, EISDIR: 31, EINVAL: 28, ENFILE: 41, EMFILE: 33, ENOTTY: 59, ETXTBSY: 74, EFBIG: 22, ENOSPC: 51, ESPIPE: 70, EROFS: 69, EMLINK: 34, EPIPE: 64, EDOM: 18, ERANGE: 68, ENOMSG: 49, EIDRM: 24, ECHRNG: 106, EL2NSYNC: 156, EL3HLT: 107, EL3RST: 108, ELNRNG: 109, EUNATCH: 110, ENOCSI: 111, EL2HLT: 112, EDEADLK: 16, ENOLCK: 46, EBADE: 113, EBADR: 114, EXFULL: 115, ENOANO: 104, EBADRQC: 103, EBADSLT: 102, EDEADLOCK: 16, EBFONT: 101, ENOSTR: 100, ENODATA: 116, ETIME: 117, ENOSR: 118, ENONET: 119, ENOPKG: 120, EREMOTE: 121, ENOLINK: 47, EADV: 122, ESRMNT: 123, ECOMM: 124, EPROTO: 65, EMULTIHOP: 36, EDOTDOT: 125, EBADMSG: 9, ENOTUNIQ: 126, EBADFD: 127, EREMCHG: 128, ELIBACC: 129, ELIBBAD: 130, ELIBSCN: 131, ELIBMAX: 132, ELIBEXEC: 133, ENOSYS: 52, ENOTEMPTY: 55, ENAMETOOLONG: 37, ELOOP: 32, EOPNOTSUPP: 138, EPFNOSUPPORT: 139, ECONNRESET: 15, ENOBUFS: 42, EAFNOSUPPORT: 5, EPROTOTYPE: 67, ENOTSOCK: 57, ENOPROTOOPT: 50, ESHUTDOWN: 140, ECONNREFUSED: 14, EADDRINUSE: 3, ECONNABORTED: 13, ENETUNREACH: 40, ENETDOWN: 38, ETIMEDOUT: 73, EHOSTDOWN: 142, EHOSTUNREACH: 23, EINPROGRESS: 26, EALREADY: 7, EDESTADDRREQ: 17, EMSGSIZE: 35, EPROTONOSUPPORT: 66, ESOCKTNOSUPPORT: 137, EADDRNOTAVAIL: 4, ENETRESET: 39, EISCONN: 30, ENOTCONN: 53, ETOOMANYREFS: 141, EUSERS: 136, EDQUOT: 19, ESTALE: 72, ENOTSUP: 138, ENOMEDIUM: 148, EILSEQ: 25, EOVERFLOW: 61, ECANCELED: 11, ENOTRECOVERABLE: 56, EOWNERDEAD: 62, ESTRPIPE: 135 };
Module["ERRNO_CODES"] = ERRNO_CODES; var FS = {
  root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, handleFSError: function (e) {
    if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
    return setErrNo(e.errno);
  }, lookupPath: function (path, opts) {
    path = PATH_FS.resolve(FS.cwd(), path);
    opts = opts || {};

    if (!path) return { path: '', node: null };

    var defaults = {
      follow_mount: true,
      recurse_count: 0
    };
    for (var key in defaults) {
      if (opts[key] === undefined) {
        opts[key] = defaults[key];
      }
    }

    if (opts.recurse_count > 8) {  // max recursive lookup of 8
      throw new FS.ErrnoError(32);
    }

    // split the path
    var parts = PATH.normalizeArray(path.split('/').filter(function (p) {
      return !!p;
    }), false);

    // start at the root
    var current = FS.root;
    var current_path = '/';

    for (var i = 0; i < parts.length; i++) {
      var islast = (i === parts.length - 1);
      if (islast && opts.parent) {
        // stop resolving
        break;
      }

      current = FS.lookupNode(current, parts[i]);
      current_path = PATH.join2(current_path, parts[i]);

      // jump to the mount's root node if this is a mountpoint
      if (FS.isMountpoint(current)) {
        if (!islast || (islast && opts.follow_mount)) {
          current = current.mounted.root;
        }
      }

      // by default, lookupPath will not follow a symlink if it is the final path component.
      // setting opts.follow = true will override this behavior.
      if (!islast || opts.follow) {
        var count = 0;
        while (FS.isLink(current.mode)) {
          var link = FS.readlink(current_path);
          current_path = PATH_FS.resolve(PATH.dirname(current_path), link);

          var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
          current = lookup.node;

          if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
            throw new FS.ErrnoError(32);
          }
        }
      }
    }

    return { path: current_path, node: current };
  }, getPath: function (node) {
    var path;
    while (true) {
      if (FS.isRoot(node)) {
        var mount = node.mount.mountpoint;
        if (!path) return mount;
        return mount[mount.length - 1] !== '/' ? mount + '/' + path : mount + path;
      }
      path = path ? node.name + '/' + path : node.name;
      node = node.parent;
    }
  }, hashName: function (parentid, name) {
    var hash = 0;


    for (var i = 0; i < name.length; i++) {
      hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
    }
    return ((parentid + hash) >>> 0) % FS.nameTable.length;
  }, hashAddNode: function (node) {
    var hash = FS.hashName(node.parent.id, node.name);
    node.name_next = FS.nameTable[hash];
    FS.nameTable[hash] = node;
  }, hashRemoveNode: function (node) {
    var hash = FS.hashName(node.parent.id, node.name);
    if (FS.nameTable[hash] === node) {
      FS.nameTable[hash] = node.name_next;
    } else {
      var current = FS.nameTable[hash];
      while (current) {
        if (current.name_next === node) {
          current.name_next = node.name_next;
          break;
        }
        current = current.name_next;
      }
    }
  }, lookupNode: function (parent, name) {
    var errCode = FS.mayLookup(parent);
    if (errCode) {
      throw new FS.ErrnoError(errCode, parent);
    }
    var hash = FS.hashName(parent.id, name);
    for (var node = FS.nameTable[hash]; node; node = node.name_next) {
      var nodeName = node.name;
      if (node.parent.id === parent.id && nodeName === name) {
        return node;
      }
    }
    // if we failed to find it in the cache, call into the VFS
    return FS.lookup(parent, name);
  }, createNode: function (parent, name, mode, rdev) {
    var node = new FS.FSNode(parent, name, mode, rdev);

    FS.hashAddNode(node);

    return node;
  }, destroyNode: function (node) {
    FS.hashRemoveNode(node);
  }, isRoot: function (node) {
    return node === node.parent;
  }, isMountpoint: function (node) {
    return !!node.mounted;
  }, isFile: function (mode) {
    return (mode & 61440) === 32768;
  }, isDir: function (mode) {
    return (mode & 61440) === 16384;
  }, isLink: function (mode) {
    return (mode & 61440) === 40960;
  }, isChrdev: function (mode) {
    return (mode & 61440) === 8192;
  }, isBlkdev: function (mode) {
    return (mode & 61440) === 24576;
  }, isFIFO: function (mode) {
    return (mode & 61440) === 4096;
  }, isSocket: function (mode) {
    return (mode & 49152) === 49152;
  }, flagModes: { "r": 0, "rs": 1052672, "r+": 2, "w": 577, "wx": 705, "xw": 705, "w+": 578, "wx+": 706, "xw+": 706, "a": 1089, "ax": 1217, "xa": 1217, "a+": 1090, "ax+": 1218, "xa+": 1218 }, modeStringToFlags: function (str) {
    var flags = FS.flagModes[str];
    if (typeof flags === 'undefined') {
      throw new Error('Unknown file open mode: ' + str);
    }
    return flags;
  }, flagsToPermissionString: function (flag) {
    var perms = ['r', 'w', 'rw'][flag & 3];
    if ((flag & 512)) {
      perms += 'w';
    }
    return perms;
  }, nodePermissions: function (node, perms) {
    if (FS.ignorePermissions) {
      return 0;
    }
    // return 0 if any user, group or owner bits are set.
    if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
      return 2;
    } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
      return 2;
    } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
      return 2;
    }
    return 0;
  }, mayLookup: function (dir) {
    var errCode = FS.nodePermissions(dir, 'x');
    if (errCode) return errCode;
    if (!dir.node_ops.lookup) return 2;
    return 0;
  }, mayCreate: function (dir, name) {
    try {
      var node = FS.lookupNode(dir, name);
      return 20;
    } catch (e) {
    }
    return FS.nodePermissions(dir, 'wx');
  }, mayDelete: function (dir, name, isdir) {
    var node;
    try {
      node = FS.lookupNode(dir, name);
    } catch (e) {
      return e.errno;
    }
    var errCode = FS.nodePermissions(dir, 'wx');
    if (errCode) {
      return errCode;
    }
    if (isdir) {
      if (!FS.isDir(node.mode)) {
        return 54;
      }
      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
        return 10;
      }
    } else {
      if (FS.isDir(node.mode)) {
        return 31;
      }
    }
    return 0;
  }, mayOpen: function (node, flags) {
    if (!node) {
      return 44;
    }
    if (FS.isLink(node.mode)) {
      return 32;
    } else if (FS.isDir(node.mode)) {
      if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
        (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
        return 31;
      }
    }
    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
  }, MAX_OPEN_FDS: 4096, nextfd: function (fd_start, fd_end) {
    fd_start = fd_start || 0;
    fd_end = fd_end || FS.MAX_OPEN_FDS;
    for (var fd = fd_start; fd <= fd_end; fd++) {
      if (!FS.streams[fd]) {
        return fd;
      }
    }
    throw new FS.ErrnoError(33);
  }, getStream: function (fd) {
    return FS.streams[fd];
  }, createStream: function (stream, fd_start, fd_end) {
    if (!FS.FSStream) {
      FS.FSStream = /** @constructor */ function () { };
      FS.FSStream.prototype = {
        object: {
          get: function () { return this.node; },
          set: function (val) { this.node = val; }
        },
        isRead: {
          get: function () { return (this.flags & 2097155) !== 1; }
        },
        isWrite: {
          get: function () { return (this.flags & 2097155) !== 0; }
        },
        isAppend: {
          get: function () { return (this.flags & 1024); }
        }
      };
    }
    // clone it, so we can return an instance of FSStream
    var newStream = new FS.FSStream();
    for (var p in stream) {
      newStream[p] = stream[p];
    }
    stream = newStream;
    var fd = FS.nextfd(fd_start, fd_end);
    stream.fd = fd;
    FS.streams[fd] = stream;
    return stream;
  }, closeStream: function (fd) {
    FS.streams[fd] = null;
  }, chrdev_stream_ops: {
    open: function (stream) {
      var device = FS.getDevice(stream.node.rdev);
      // override node's stream ops with the device's
      stream.stream_ops = device.stream_ops;
      // forward the open call
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
    }, llseek: function () {
      throw new FS.ErrnoError(70);
    }
  }, major: function (dev) {
    return ((dev) >> 8);
  }, minor: function (dev) {
    return ((dev) & 0xff);
  }, makedev: function (ma, mi) {
    return ((ma) << 8 | (mi));
  }, registerDevice: function (dev, ops) {
    FS.devices[dev] = { stream_ops: ops };
  }, getDevice: function (dev) {
    return FS.devices[dev];
  }, getMounts: function (mount) {
    var mounts = [];
    var check = [mount];

    while (check.length) {
      var m = check.pop();

      mounts.push(m);

      check.push.apply(check, m.mounts);
    }

    return mounts;
  }, syncfs: function (populate, callback) {
    if (typeof (populate) === 'function') {
      callback = populate;
      populate = false;
    }

    FS.syncFSRequests++;

    if (FS.syncFSRequests > 1) {
      err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
    }

    var mounts = FS.getMounts(FS.root.mount);
    var completed = 0;

    function doCallback(errCode) {
      assert(FS.syncFSRequests > 0);
      FS.syncFSRequests--;
      return callback(errCode);
    }

    function done(errCode) {
      if (errCode) {
        if (!done.errored) {
          done.errored = true;
          return doCallback(errCode);
        }
        return;
      }
      if (++completed >= mounts.length) {
        doCallback(null);
      }
    };

    // sync all mounts
    mounts.forEach(function (mount) {
      if (!mount.type.syncfs) {
        return done(null);
      }
      mount.type.syncfs(mount, populate, done);
    });
  }, mount: function (type, opts, mountpoint) {
    if (typeof type === 'string') {
      // The filesystem was not included, and instead we have an error
      // message stored in the variable.
      throw type;
    }
    var root = mountpoint === '/';
    var pseudo = !mountpoint;
    var node;

    if (root && FS.root) {
      throw new FS.ErrnoError(10);
    } else if (!root && !pseudo) {
      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

      mountpoint = lookup.path;  // use the absolute path
      node = lookup.node;

      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }

      if (!FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
    }

    var mount = {
      type: type,
      opts: opts,
      mountpoint: mountpoint,
      mounts: []
    };

    // create a root node for the fs
    var mountRoot = type.mount(mount);
    mountRoot.mount = mount;
    mount.root = mountRoot;

    if (root) {
      FS.root = mountRoot;
    } else if (node) {
      // set as a mountpoint
      node.mounted = mount;

      // add the new mount to the current mount's children
      if (node.mount) {
        node.mount.mounts.push(mount);
      }
    }

    return mountRoot;
  }, unmount: function (mountpoint) {
    var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

    if (!FS.isMountpoint(lookup.node)) {
      throw new FS.ErrnoError(28);
    }

    // destroy the nodes for this mount, and all its child mounts
    var node = lookup.node;
    var mount = node.mounted;
    var mounts = FS.getMounts(mount);

    Object.keys(FS.nameTable).forEach(function (hash) {
      var current = FS.nameTable[hash];

      while (current) {
        var next = current.name_next;

        if (mounts.indexOf(current.mount) !== -1) {
          FS.destroyNode(current);
        }

        current = next;
      }
    });

    // no longer a mountpoint
    node.mounted = null;

    // remove this mount from the child mounts
    var idx = node.mount.mounts.indexOf(mount);
    assert(idx !== -1);
    node.mount.mounts.splice(idx, 1);
  }, lookup: function (parent, name) {
    return parent.node_ops.lookup(parent, name);
  }, mknod: function (path, mode, dev) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    if (!name || name === '.' || name === '..') {
      throw new FS.ErrnoError(28);
    }
    var errCode = FS.mayCreate(parent, name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.mknod) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.mknod(parent, name, mode, dev);
  }, create: function (path, mode) {
    mode = mode !== undefined ? mode : 438 /* 0666 */;
    mode &= 4095;
    mode |= 32768;
    return FS.mknod(path, mode, 0);
  }, mkdir: function (path, mode) {
    mode = mode !== undefined ? mode : 511 /* 0777 */;
    mode &= 511 | 512;
    mode |= 16384;
    return FS.mknod(path, mode, 0);
  }, mkdirTree: function (path, mode) {
    var dirs = path.split('/');
    var d = '';
    for (var i = 0; i < dirs.length; ++i) {
      if (!dirs[i]) continue;
      d += '/' + dirs[i];
      try {
        FS.mkdir(d, mode);
      } catch (e) {
        if (e.errno != 20) throw e;
      }
    }
  }, mkdev: function (path, mode, dev) {
    if (typeof (dev) === 'undefined') {
      dev = mode;
      mode = 438 /* 0666 */;
    }
    mode |= 8192;
    return FS.mknod(path, mode, dev);
  }, symlink: function (oldpath, newpath) {
    if (!PATH_FS.resolve(oldpath)) {
      throw new FS.ErrnoError(44);
    }
    var lookup = FS.lookupPath(newpath, { parent: true });
    var parent = lookup.node;
    if (!parent) {
      throw new FS.ErrnoError(44);
    }
    var newname = PATH.basename(newpath);
    var errCode = FS.mayCreate(parent, newname);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.symlink) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.symlink(parent, newname, oldpath);
  }, rename: function (old_path, new_path) {
    var old_dirname = PATH.dirname(old_path);
    var new_dirname = PATH.dirname(new_path);
    var old_name = PATH.basename(old_path);
    var new_name = PATH.basename(new_path);
    // parents must exist
    var lookup, old_dir, new_dir;
    try {
      lookup = FS.lookupPath(old_path, { parent: true });
      old_dir = lookup.node;
      lookup = FS.lookupPath(new_path, { parent: true });
      new_dir = lookup.node;
    } catch (e) {
      throw new FS.ErrnoError(10);
    }
    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
    // need to be part of the same mount
    if (old_dir.mount !== new_dir.mount) {
      throw new FS.ErrnoError(75);
    }
    // source must exist
    var old_node = FS.lookupNode(old_dir, old_name);
    // old path should not be an ancestor of the new path
    var relative = PATH_FS.relative(old_path, new_dirname);
    if (relative.charAt(0) !== '.') {
      throw new FS.ErrnoError(28);
    }
    // new path should not be an ancestor of the old path
    relative = PATH_FS.relative(new_path, old_dirname);
    if (relative.charAt(0) !== '.') {
      throw new FS.ErrnoError(55);
    }
    // see if the new path already exists
    var new_node;
    try {
      new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {
      // not fatal
    }
    // early out if nothing needs to change
    if (old_node === new_node) {
      return;
    }
    // we'll need to delete the old entry
    var isdir = FS.isDir(old_node.mode);
    var errCode = FS.mayDelete(old_dir, old_name, isdir);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    // need delete permissions if we'll be overwriting.
    // need create permissions if new doesn't already exist.
    errCode = new_node ?
      FS.mayDelete(new_dir, new_name, isdir) :
      FS.mayCreate(new_dir, new_name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!old_dir.node_ops.rename) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
      throw new FS.ErrnoError(10);
    }
    // if we are going to change the parent, check write permissions
    if (new_dir !== old_dir) {
      errCode = FS.nodePermissions(old_dir, 'w');
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    try {
      if (FS.trackingDelegate['willMovePath']) {
        FS.trackingDelegate['willMovePath'](old_path, new_path);
      }
    } catch (e) {
      err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
    }
    // remove the node from the lookup hash
    FS.hashRemoveNode(old_node);
    // do the underlying fs rename
    try {
      old_dir.node_ops.rename(old_node, new_dir, new_name);
    } catch (e) {
      throw e;
    } finally {
      // add the node back to the hash (in case node_ops.rename
      // changed its name)
      FS.hashAddNode(old_node);
    }
    try {
      if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
    } catch (e) {
      err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
    }
  }, rmdir: function (path) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, true);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.rmdir) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    try {
      if (FS.trackingDelegate['willDeletePath']) {
        FS.trackingDelegate['willDeletePath'](path);
      }
    } catch (e) {
      err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
    }
    parent.node_ops.rmdir(parent, name);
    FS.destroyNode(node);
    try {
      if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
    } catch (e) {
      err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
    }
  }, readdir: function (path) {
    var lookup = FS.lookupPath(path, { follow: true });
    var node = lookup.node;
    if (!node.node_ops.readdir) {
      throw new FS.ErrnoError(54);
    }
    return node.node_ops.readdir(node);
  }, unlink: function (path) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, false);
    if (errCode) {
      // According to POSIX, we should map EISDIR to EPERM, but
      // we instead do what Linux does (and we must, as we use
      // the musl linux libc).
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.unlink) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    try {
      if (FS.trackingDelegate['willDeletePath']) {
        FS.trackingDelegate['willDeletePath'](path);
      }
    } catch (e) {
      err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
    }
    parent.node_ops.unlink(parent, name);
    FS.destroyNode(node);
    try {
      if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
    } catch (e) {
      err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
    }
  }, readlink: function (path) {
    var lookup = FS.lookupPath(path);
    var link = lookup.node;
    if (!link) {
      throw new FS.ErrnoError(44);
    }
    if (!link.node_ops.readlink) {
      throw new FS.ErrnoError(28);
    }
    return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
  }, stat: function (path, dontFollow) {
    var lookup = FS.lookupPath(path, { follow: !dontFollow });
    var node = lookup.node;
    if (!node) {
      throw new FS.ErrnoError(44);
    }
    if (!node.node_ops.getattr) {
      throw new FS.ErrnoError(63);
    }
    return node.node_ops.getattr(node);
  }, lstat: function (path) {
    return FS.stat(path, true);
  }, chmod: function (path, mode, dontFollow) {
    var node;
    if (typeof path === 'string') {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    node.node_ops.setattr(node, {
      mode: (mode & 4095) | (node.mode & ~4095),
      timestamp: Date.now()
    });
  }, lchmod: function (path, mode) {
    FS.chmod(path, mode, true);
  }, fchmod: function (fd, mode) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    FS.chmod(stream.node, mode);
  }, chown: function (path, uid, gid, dontFollow) {
    var node;
    if (typeof path === 'string') {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    node.node_ops.setattr(node, {
      timestamp: Date.now()
      // we ignore the uid / gid for now
    });
  }, lchown: function (path, uid, gid) {
    FS.chown(path, uid, gid, true);
  }, fchown: function (fd, uid, gid) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    FS.chown(stream.node, uid, gid);
  }, truncate: function (path, len) {
    if (len < 0) {
      throw new FS.ErrnoError(28);
    }
    var node;
    if (typeof path === 'string') {
      var lookup = FS.lookupPath(path, { follow: true });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isDir(node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!FS.isFile(node.mode)) {
      throw new FS.ErrnoError(28);
    }
    var errCode = FS.nodePermissions(node, 'w');
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    node.node_ops.setattr(node, {
      size: len,
      timestamp: Date.now()
    });
  }, ftruncate: function (fd, len) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(28);
    }
    FS.truncate(stream.node, len);
  }, utime: function (path, atime, mtime) {
    var lookup = FS.lookupPath(path, { follow: true });
    var node = lookup.node;
    node.node_ops.setattr(node, {
      timestamp: Math.max(atime, mtime)
    });
  }, open: function (path, flags, mode, fd_start, fd_end) {
    if (path === "") {
      throw new FS.ErrnoError(44);
    }
    flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
    mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
    if ((flags & 64)) {
      mode = (mode & 4095) | 32768;
    } else {
      mode = 0;
    }
    var node;
    if (typeof path === 'object') {
      node = path;
    } else {
      path = PATH.normalize(path);
      try {
        var lookup = FS.lookupPath(path, {
          follow: !(flags & 131072)
        });
        node = lookup.node;
      } catch (e) {
        // ignore
      }
    }
    // perhaps we need to create the node
    var created = false;
    if ((flags & 64)) {
      if (node) {
        // if O_CREAT and O_EXCL are set, error out if the node already exists
        if ((flags & 128)) {
          throw new FS.ErrnoError(20);
        }
      } else {
        // node doesn't exist, try to create it
        node = FS.mknod(path, mode, 0);
        created = true;
      }
    }
    if (!node) {
      throw new FS.ErrnoError(44);
    }
    // can't truncate a device
    if (FS.isChrdev(node.mode)) {
      flags &= ~512;
    }
    // if asked only for a directory, then this must be one
    if ((flags & 65536) && !FS.isDir(node.mode)) {
      throw new FS.ErrnoError(54);
    }
    // check permissions, if this is not a file we just created now (it is ok to
    // create and write to a file with read-only permissions; it is read-only
    // for later use)
    if (!created) {
      var errCode = FS.mayOpen(node, flags);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    // do truncation if necessary
    if ((flags & 512)) {
      FS.truncate(node, 0);
    }
    // we've already handled these, don't pass down to the underlying vfs
    flags &= ~(128 | 512 | 131072);

    // register the stream with the filesystem
    var stream = FS.createStream({
      node: node,
      path: FS.getPath(node),  // we want the absolute path to the node
      flags: flags,
      seekable: true,
      position: 0,
      stream_ops: node.stream_ops,
      // used by the file family libc calls (fopen, fwrite, ferror, etc.)
      ungotten: [],
      error: false
    }, fd_start, fd_end);
    // call the new stream's open function
    if (stream.stream_ops.open) {
      stream.stream_ops.open(stream);
    }
    if (Module['logReadFiles'] && !(flags & 1)) {
      if (!FS.readFiles) FS.readFiles = {};
      if (!(path in FS.readFiles)) {
        FS.readFiles[path] = 1;
        err("FS.trackingDelegate error on read file: " + path);
      }
    }
    try {
      if (FS.trackingDelegate['onOpenFile']) {
        var trackingFlags = 0;
        if ((flags & 2097155) !== 1) {
          trackingFlags |= FS.tracking.openFlags.READ;
        }
        if ((flags & 2097155) !== 0) {
          trackingFlags |= FS.tracking.openFlags.WRITE;
        }
        FS.trackingDelegate['onOpenFile'](path, trackingFlags);
      }
    } catch (e) {
      err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
    }
    return stream;
  }, close: function (stream) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (stream.getdents) stream.getdents = null; // free readdir state
    try {
      if (stream.stream_ops.close) {
        stream.stream_ops.close(stream);
      }
    } catch (e) {
      throw e;
    } finally {
      FS.closeStream(stream.fd);
    }
    stream.fd = null;
  }, isClosed: function (stream) {
    return stream.fd === null;
  }, llseek: function (stream, offset, whence) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (!stream.seekable || !stream.stream_ops.llseek) {
      throw new FS.ErrnoError(70);
    }
    if (whence != 0 && whence != 1 && whence != 2) {
      throw new FS.ErrnoError(28);
    }
    stream.position = stream.stream_ops.llseek(stream, offset, whence);
    stream.ungotten = [];
    return stream.position;
  }, read: function (stream, buffer, offset, length, position) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.read) {
      throw new FS.ErrnoError(28);
    }
    var seeking = typeof position !== 'undefined';
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
    if (!seeking) stream.position += bytesRead;
    return bytesRead;
  }, write: function (stream, buffer, offset, length, position, canOwn) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.write) {
      throw new FS.ErrnoError(28);
    }
    if (stream.seekable && stream.flags & 1024) {
      // seek to the end before writing in append mode
      FS.llseek(stream, 0, 2);
    }
    var seeking = typeof position !== 'undefined';
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
    if (!seeking) stream.position += bytesWritten;
    try {
      if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
    } catch (e) {
      err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
    }
    return bytesWritten;
  }, allocate: function (stream, offset, length) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (offset < 0 || length <= 0) {
      throw new FS.ErrnoError(28);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(8);
    }
    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(43);
    }
    if (!stream.stream_ops.allocate) {
      throw new FS.ErrnoError(138);
    }
    stream.stream_ops.allocate(stream, offset, length);
  }, mmap: function (stream, buffer, offset, length, position, prot, flags) {
    // User requests writing to file (prot & PROT_WRITE != 0).
    // Checking if we have permissions to write to the file unless
    // MAP_PRIVATE flag is set. According to POSIX spec it is possible
    // to write to file opened in read-only mode with MAP_PRIVATE flag,
    // as all modifications will be visible only in the memory of
    // the current process.
    if ((prot & 2) !== 0
      && (flags & 2) === 0
      && (stream.flags & 2097155) !== 2) {
      throw new FS.ErrnoError(2);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(2);
    }
    if (!stream.stream_ops.mmap) {
      throw new FS.ErrnoError(43);
    }
    return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
  }, msync: function (stream, buffer, offset, length, mmapFlags) {
    if (!stream || !stream.stream_ops.msync) {
      return 0;
    }
    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
  }, munmap: function (stream) {
    return 0;
  }, ioctl: function (stream, cmd, arg) {
    if (!stream.stream_ops.ioctl) {
      throw new FS.ErrnoError(59);
    }
    return stream.stream_ops.ioctl(stream, cmd, arg);
  }, readFile: function (path, opts) {
    opts = opts || {};
    opts.flags = opts.flags || 'r';
    opts.encoding = opts.encoding || 'binary';
    if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
      throw new Error('Invalid encoding type "' + opts.encoding + '"');
    }
    var ret;
    var stream = FS.open(path, opts.flags);
    var stat = FS.stat(path);
    var length = stat.size;
    var buf = new Uint8Array(length);
    FS.read(stream, buf, 0, length, 0);
    if (opts.encoding === 'utf8') {
      ret = UTF8ArrayToString(buf, 0);
    } else if (opts.encoding === 'binary') {
      ret = buf;
    }
    FS.close(stream);
    return ret;
  }, writeFile: function (path, data, opts) {
    opts = opts || {};
    opts.flags = opts.flags || 'w';
    var stream = FS.open(path, opts.flags, opts.mode);
    if (typeof data === 'string') {
      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
    } else if (ArrayBuffer.isView(data)) {
      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
    } else {
      throw new Error('Unsupported data type');
    }
    FS.close(stream);
  }, cwd: function () {
    return FS.currentPath;
  }, chdir: function (path) {
    var lookup = FS.lookupPath(path, { follow: true });
    if (lookup.node === null) {
      throw new FS.ErrnoError(44);
    }
    if (!FS.isDir(lookup.node.mode)) {
      throw new FS.ErrnoError(54);
    }
    var errCode = FS.nodePermissions(lookup.node, 'x');
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    FS.currentPath = lookup.path;
  }, createDefaultDirectories: function () {
    FS.mkdir('/tmp');
    FS.mkdir('/home');
    FS.mkdir('/home/web_user');
  }, createDefaultDevices: function () {
    // create /dev
    FS.mkdir('/dev');
    // setup /dev/null
    FS.registerDevice(FS.makedev(1, 3), {
      read: function () { return 0; },
      write: function (stream, buffer, offset, length, pos) { return length; }
    });
    FS.mkdev('/dev/null', FS.makedev(1, 3));
    // setup /dev/tty and /dev/tty1
    // stderr needs to print output using Module['printErr']
    // so we register a second tty just for it.
    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
    FS.mkdev('/dev/tty', FS.makedev(5, 0));
    FS.mkdev('/dev/tty1', FS.makedev(6, 0));
    // setup /dev/[u]random
    var random_device;
    if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
      // for modern web browsers
      var randomBuffer = new Uint8Array(1);
      random_device = function () { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
    } else
      if (ENVIRONMENT_IS_NODE) {
        // for nodejs with or without crypto support included
        try {
          var crypto_module = require('crypto');
          // nodejs has crypto support
          random_device = function () { return crypto_module['randomBytes'](1)[0]; };
        } catch (e) {
          // nodejs doesn't have crypto support
        }
      } else { }
    if (!random_device) {
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      random_device = function () { abort("no cryptographic support found for random_device. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"); };
    }
    FS.createDevice('/dev', 'random', random_device);
    FS.createDevice('/dev', 'urandom', random_device);
    // we're not going to emulate the actual shm device,
    // just create the tmp dirs that reside in it commonly
    FS.mkdir('/dev/shm');
    FS.mkdir('/dev/shm/tmp');
  }, createSpecialDirectories: function () {
    // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
    FS.mkdir('/proc');
    FS.mkdir('/proc/self');
    FS.mkdir('/proc/self/fd');
    FS.mount({
      mount: function () {
        var node = FS.createNode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);
        node.node_ops = {
          lookup: function (parent, name) {
            var fd = +name;
            var stream = FS.getStream(fd);
            if (!stream) throw new FS.ErrnoError(8);
            var ret = {
              parent: null,
              mount: { mountpoint: 'fake' },
              node_ops: { readlink: function () { return stream.path } }
            };
            ret.parent = ret; // make it look like a simple root node
            return ret;
          }
        };
        return node;
      }
    }, {}, '/proc/self/fd');
  }, createStandardStreams: function () {
    // TODO deprecate the old functionality of a single
    // input / output callback and that utilizes FS.createDevice
    // and instead require a unique set of stream ops

    // by default, we symlink the standard streams to the
    // default tty devices. however, if the standard streams
    // have been overwritten we create a unique device for
    // them instead.
    if (Module['stdin']) {
      FS.createDevice('/dev', 'stdin', Module['stdin']);
    } else {
      FS.symlink('/dev/tty', '/dev/stdin');
    }
    if (Module['stdout']) {
      FS.createDevice('/dev', 'stdout', null, Module['stdout']);
    } else {
      FS.symlink('/dev/tty', '/dev/stdout');
    }
    if (Module['stderr']) {
      FS.createDevice('/dev', 'stderr', null, Module['stderr']);
    } else {
      FS.symlink('/dev/tty1', '/dev/stderr');
    }

    // open default streams for the stdin, stdout and stderr devices
    var stdin = FS.open('/dev/stdin', 'r');
    var stdout = FS.open('/dev/stdout', 'w');
    var stderr = FS.open('/dev/stderr', 'w');
    assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
    assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
    assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
  }, ensureErrnoError: function () {
    if (FS.ErrnoError) return;
    FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
      this.node = node;
      this.setErrno = /** @this{Object} */ function (errno) {
        this.errno = errno;
        for (var key in ERRNO_CODES) {
          if (ERRNO_CODES[key] === errno) {
            this.code = key;
            break;
          }
        }
      };
      this.setErrno(errno);
      this.message = ERRNO_MESSAGES[errno];

      // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
      // now ensures it shows what we want.
      if (this.stack) {
        // Define the stack property for Node.js 4, which otherwise errors on the next line.
        Object.defineProperty(this, "stack", { value: (new Error).stack, writable: true });
        this.stack = demangleAll(this.stack);
      }
    };
    FS.ErrnoError.prototype = new Error();
    FS.ErrnoError.prototype.constructor = FS.ErrnoError;
    // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
    [44].forEach(function (code) {
      FS.genericErrors[code] = new FS.ErrnoError(code);
      FS.genericErrors[code].stack = '<generic error, no stack>';
    });
  }, staticInit: function () {
    FS.ensureErrnoError();

    FS.nameTable = new Array(4096);

    FS.mount(MEMFS, {}, '/');

    FS.createDefaultDirectories();
    FS.createDefaultDevices();
    FS.createSpecialDirectories();

    FS.filesystems = {
      'MEMFS': MEMFS,
    };
  }, init: function (input, output, error) {
    assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
    FS.init.initialized = true;

    FS.ensureErrnoError();

    // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
    Module['stdin'] = input || Module['stdin'];
    Module['stdout'] = output || Module['stdout'];
    Module['stderr'] = error || Module['stderr'];

    FS.createStandardStreams();
  }, quit: function () {
    FS.init.initialized = false;
    // force-flush all streams, so we get musl std streams printed out
    var fflush = Module['_fflush'];
    if (fflush) fflush(0);
    // close all of our streams
    for (var i = 0; i < FS.streams.length; i++) {
      var stream = FS.streams[i];
      if (!stream) {
        continue;
      }
      FS.close(stream);
    }
  }, getMode: function (canRead, canWrite) {
    var mode = 0;
    if (canRead) mode |= 292 | 73;
    if (canWrite) mode |= 146;
    return mode;
  }, joinPath: function (parts, forceRelative) {
    var path = PATH.join.apply(null, parts);
    if (forceRelative && path[0] == '/') path = path.substr(1);
    return path;
  }, absolutePath: function (relative, base) {
    return PATH_FS.resolve(base, relative);
  }, standardizePath: function (path) {
    return PATH.normalize(path);
  }, findObject: function (path, dontResolveLastLink) {
    var ret = FS.analyzePath(path, dontResolveLastLink);
    if (ret.exists) {
      return ret.object;
    } else {
      setErrNo(ret.error);
      return null;
    }
  }, analyzePath: function (path, dontResolveLastLink) {
    // operate from within the context of the symlink's target
    try {
      var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
      path = lookup.path;
    } catch (e) {
    }
    var ret = {
      isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
      parentExists: false, parentPath: null, parentObject: null
    };
    try {
      var lookup = FS.lookupPath(path, { parent: true });
      ret.parentExists = true;
      ret.parentPath = lookup.path;
      ret.parentObject = lookup.node;
      ret.name = PATH.basename(path);
      lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
      ret.exists = true;
      ret.path = lookup.path;
      ret.object = lookup.node;
      ret.name = lookup.node.name;
      ret.isRoot = lookup.path === '/';
    } catch (e) {
      ret.error = e.errno;
    };
    return ret;
  }, createFolder: function (parent, name, canRead, canWrite) {
    var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
    var mode = FS.getMode(canRead, canWrite);
    return FS.mkdir(path, mode);
  }, createPath: function (parent, path, canRead, canWrite) {
    parent = typeof parent === 'string' ? parent : FS.getPath(parent);
    var parts = path.split('/').reverse();
    while (parts.length) {
      var part = parts.pop();
      if (!part) continue;
      var current = PATH.join2(parent, part);
      try {
        FS.mkdir(current);
      } catch (e) {
        // ignore EEXIST
      }
      parent = current;
    }
    return current;
  }, createFile: function (parent, name, properties, canRead, canWrite) {
    var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
    var mode = FS.getMode(canRead, canWrite);
    return FS.create(path, mode);
  }, createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {
    var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
    var mode = FS.getMode(canRead, canWrite);
    var node = FS.create(path, mode);
    if (data) {
      if (typeof data === 'string') {
        var arr = new Array(data.length);
        for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
        data = arr;
      }
      // make sure we can write to the file
      FS.chmod(node, mode | 146);
      var stream = FS.open(node, 'w');
      FS.write(stream, data, 0, data.length, 0, canOwn);
      FS.close(stream);
      FS.chmod(node, mode);
    }
    return node;
  }, createDevice: function (parent, name, input, output) {
    var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
    var mode = FS.getMode(!!input, !!output);
    if (!FS.createDevice.major) FS.createDevice.major = 64;
    var dev = FS.makedev(FS.createDevice.major++, 0);
    // Create a fake device that a set of stream ops to emulate
    // the old behavior.
    FS.registerDevice(dev, {
      open: function (stream) {
        stream.seekable = false;
      },
      close: function (stream) {
        // flush any pending line data
        if (output && output.buffer && output.buffer.length) {
          output(10);
        }
      },
      read: function (stream, buffer, offset, length, pos /* ignored */) {
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = input();
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === undefined && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === undefined) break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function (stream, buffer, offset, length, pos) {
        for (var i = 0; i < length; i++) {
          try {
            output(buffer[offset + i]);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    });
    return FS.mkdev(path, mode, dev);
  }, createLink: function (parent, name, target, canRead, canWrite) {
    var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
    return FS.symlink(target, path);
  }, forceLoadFile: function (obj) {
    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
    var success = true;
    if (typeof XMLHttpRequest !== 'undefined') {
      throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
    } else if (read_) {
      // Command-line.
      try {
        // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
        //          read() will try to parse UTF8.
        obj.contents = intArrayFromString(read_(obj.url), true);
        obj.usedBytes = obj.contents.length;
      } catch (e) {
        success = false;
      }
    } else {
      throw new Error('Cannot load without read() or XMLHttpRequest.');
    }
    if (!success) setErrNo(29);
    return success;
  }, createLazyFile: function (parent, name, url, canRead, canWrite) {
    // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
    /** @constructor */
    function LazyUint8Array() {
      this.lengthKnown = false;
      this.chunks = []; // Loaded chunks. Index is the chunk number
    }
    LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
      if (idx > this.length - 1 || idx < 0) {
        return undefined;
      }
      var chunkOffset = idx % this.chunkSize;
      var chunkNum = (idx / this.chunkSize) | 0;
      return this.getter(chunkNum)[chunkOffset];
    };
    LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
      this.getter = getter;
    };
    LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
      // Find length
      var xhr = new XMLHttpRequest();
      xhr.open('HEAD', url, false);
      xhr.send(null);
      if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
      var datalength = Number(xhr.getResponseHeader("Content-length"));
      var header;
      var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
      var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";

      var chunkSize = 1024 * 1024; // Chunk size in bytes

      if (!hasByteServing) chunkSize = datalength;

      // Function to get a range from the remote URL.
      var doXHR = (function (from, to) {
        if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
        if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");

        // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);

        // Some hints to the browser that we want binary data.
        if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType('text/plain; charset=x-user-defined');
        }

        xhr.send(null);
        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        if (xhr.response !== undefined) {
          return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
        } else {
          return intArrayFromString(xhr.responseText || '', true);
        }
      });
      var lazyArray = this;
      lazyArray.setDataGetter(function (chunkNum) {
        var start = chunkNum * chunkSize;
        var end = (chunkNum + 1) * chunkSize - 1; // including this byte
        end = Math.min(end, datalength - 1); // if datalength-1 is selected, this is the last block
        if (typeof (lazyArray.chunks[chunkNum]) === "undefined") {
          lazyArray.chunks[chunkNum] = doXHR(start, end);
        }
        if (typeof (lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
        return lazyArray.chunks[chunkNum];
      });

      if (usesGzip || !datalength) {
        // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
        chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
        datalength = this.getter(0).length;
        chunkSize = datalength;
        out("LazyFiles on gzip forces download of the whole file when length is accessed");
      }

      this._length = datalength;
      this._chunkSize = chunkSize;
      this.lengthKnown = true;
    };
    if (typeof XMLHttpRequest !== 'undefined') {
      if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
      var lazyArray = new LazyUint8Array();
      Object.defineProperties(lazyArray, {
        length: {
          get: /** @this{Object} */ function () {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
        },
        chunkSize: {
          get: /** @this{Object} */ function () {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
      });

      var properties = { isDevice: false, contents: lazyArray };
    } else {
      var properties = { isDevice: false, url: url };
    }

    var node = FS.createFile(parent, name, properties, canRead, canWrite);
    // This is a total hack, but I want to get this lazy file code out of the
    // core of MEMFS. If we want to keep this lazy file concept I feel it should
    // be its own thin LAZYFS proxying calls to MEMFS.
    if (properties.contents) {
      node.contents = properties.contents;
    } else if (properties.url) {
      node.contents = null;
      node.url = properties.url;
    }
    // Add a function that defers querying the file size until it is asked the first time.
    Object.defineProperties(node, {
      usedBytes: {
        get: /** @this {FSNode} */ function () { return this.contents.length; }
      }
    });
    // override each stream op with one that tries to force load the lazy file first
    var stream_ops = {};
    var keys = Object.keys(node.stream_ops);
    keys.forEach(function (key) {
      var fn = node.stream_ops[key];
      stream_ops[key] = function forceLoadLazyFile() {
        if (!FS.forceLoadFile(node)) {
          throw new FS.ErrnoError(29);
        }
        return fn.apply(null, arguments);
      };
    });
    // use a custom read function
    stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
      if (!FS.forceLoadFile(node)) {
        throw new FS.ErrnoError(29);
      }
      var contents = stream.node.contents;
      if (position >= contents.length)
        return 0;
      var size = Math.min(contents.length - position, length);
      assert(size >= 0);
      if (contents.slice) { // normal array
        for (var i = 0; i < size; i++) {
          buffer[offset + i] = contents[position + i];
        }
      } else {
        for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
          buffer[offset + i] = contents.get(position + i);
        }
      }
      return size;
    };
    node.stream_ops = stream_ops;
    return node;
  }, createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
    Browser.init(); // XXX perhaps this method should move onto Browser?
    // TODO we should allow people to just pass in a complete filename instead
    // of parent and name being that we just join them anyways
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
    function processData(byteArray) {
      function finish(byteArray) {
        if (preFinish) preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
        }
        if (onload) onload();
        removeRunDependency(dep);
      }
      var handled = false;
      Module['preloadPlugins'].forEach(function (plugin) {
        if (handled) return;
        if (plugin['canHandle'](fullname)) {
          plugin['handle'](byteArray, fullname, finish, function () {
            if (onerror) onerror();
            removeRunDependency(dep);
          });
          handled = true;
        }
      });
      if (!handled) finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == 'string') {
      Browser.asyncLoad(url, function (byteArray) {
        processData(byteArray);
      }, onerror);
    } else {
      processData(url);
    }
  }, indexedDB: function () {
    return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
  }, DB_NAME: function () {
    return 'EM_FS_' + window.location.pathname;
  }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function (paths, onload, onerror) {
    onload = onload || function () { };
    onerror = onerror || function () { };
    var indexedDB = FS.indexedDB();
    try {
      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
    } catch (e) {
      return onerror(e);
    }
    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
      out('creating db');
      var db = openRequest.result;
      db.createObjectStore(FS.DB_STORE_NAME);
    };
    openRequest.onsuccess = function openRequest_onsuccess() {
      var db = openRequest.result;
      var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
      var files = transaction.objectStore(FS.DB_STORE_NAME);
      var ok = 0, fail = 0, total = paths.length;
      function finish() {
        if (fail == 0) onload(); else onerror();
      }
      paths.forEach(function (path) {
        var putRequest = files.put(FS.analyzePath(path).object.contents, path);
        putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
        putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
      });
      transaction.onerror = onerror;
    };
    openRequest.onerror = onerror;
  }, loadFilesFromDB: function (paths, onload, onerror) {
    onload = onload || function () { };
    onerror = onerror || function () { };
    var indexedDB = FS.indexedDB();
    try {
      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
    } catch (e) {
      return onerror(e);
    }
    openRequest.onupgradeneeded = onerror; // no database to load from
    openRequest.onsuccess = function openRequest_onsuccess() {
      var db = openRequest.result;
      try {
        var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
      } catch (e) {
        onerror(e);
        return;
      }
      var files = transaction.objectStore(FS.DB_STORE_NAME);
      var ok = 0, fail = 0, total = paths.length;
      function finish() {
        if (fail == 0) onload(); else onerror();
      }
      paths.forEach(function (path) {
        var getRequest = files.get(path);
        getRequest.onsuccess = function getRequest_onsuccess() {
          if (FS.analyzePath(path).exists) {
            FS.unlink(path);
          }
          FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
          ok++;
          if (ok + fail == total) finish();
        };
        getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
      });
      transaction.onerror = onerror;
    };
    openRequest.onerror = onerror;
  }
};
Module["FS"] = FS; var SYSCALLS = {
  mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function (dirfd, path) {
    if (path[0] !== '/') {
      // relative path
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = FS.getStream(dirfd);
        if (!dirstream) throw new FS.ErrnoError(8);
        dir = dirstream.path;
      }
      path = PATH.join2(dir, path);
    }
    return path;
  }, doStat: function (func, path, buf) {
    try {
      var stat = func(path);
    } catch (e) {
      if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
        // an error occurred while trying to look up the path; we should just report ENOTDIR
        return -54;
      }
      throw e;
    }
    SAFE_HEAP_STORE(((buf) | 0), ((stat.dev) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (4)) | 0), ((0) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (8)) | 0), ((stat.ino) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (12)) | 0), ((stat.mode) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (16)) | 0), ((stat.nlink) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (20)) | 0), ((stat.uid) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (24)) | 0), ((stat.gid) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (28)) | 0), ((stat.rdev) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (32)) | 0), ((0) | 0), 4);
    (tempI64 = [stat.size >>> 0, (tempDouble = stat.size, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], SAFE_HEAP_STORE((((buf) + (40)) | 0), ((tempI64[0]) | 0), 4), SAFE_HEAP_STORE((((buf) + (44)) | 0), ((tempI64[1]) | 0), 4));
    SAFE_HEAP_STORE((((buf) + (48)) | 0), ((4096) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (52)) | 0), ((stat.blocks) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (56)) | 0), (((stat.atime.getTime() / 1000) | 0) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (60)) | 0), ((0) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (64)) | 0), (((stat.mtime.getTime() / 1000) | 0) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (68)) | 0), ((0) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (72)) | 0), (((stat.ctime.getTime() / 1000) | 0) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (76)) | 0), ((0) | 0), 4);
    (tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], SAFE_HEAP_STORE((((buf) + (80)) | 0), ((tempI64[0]) | 0), 4), SAFE_HEAP_STORE((((buf) + (84)) | 0), ((tempI64[1]) | 0), 4));
    return 0;
  }, doMsync: function (addr, stream, len, flags, offset) {
    var buffer = HEAPU8.slice(addr, addr + len);
    FS.msync(stream, buffer, offset, len, flags);
  }, doMkdir: function (path, mode) {
    // remove a trailing slash, if one - /a/b/ has basename of '', but
    // we want to create b in the context of this function
    path = PATH.normalize(path);
    if (path[path.length - 1] === '/') path = path.substr(0, path.length - 1);
    FS.mkdir(path, mode, 0);
    return 0;
  }, doMknod: function (path, mode, dev) {
    // we don't want this in the JS API as it uses mknod to create all nodes.
    switch (mode & 61440) {
      case 32768:
      case 8192:
      case 24576:
      case 4096:
      case 49152:
        break;
      default: return -28;
    }
    FS.mknod(path, mode, dev);
    return 0;
  }, doReadlink: function (path, buf, bufsize) {
    if (bufsize <= 0) return -28;
    var ret = FS.readlink(path);

    var len = Math.min(bufsize, lengthBytesUTF8(ret));
    var endChar = HEAP8[buf + len];
    stringToUTF8(ret, buf, bufsize + 1);
    // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
    // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
    HEAP8[buf + len] = endChar;

    return len;
  }, doAccess: function (path, amode) {
    if (amode & ~7) {
      // need a valid mode
      return -28;
    }
    var node;
    var lookup = FS.lookupPath(path, { follow: true });
    node = lookup.node;
    if (!node) {
      return -44;
    }
    var perms = '';
    if (amode & 4) perms += 'r';
    if (amode & 2) perms += 'w';
    if (amode & 1) perms += 'x';
    if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
      return -2;
    }
    return 0;
  }, doDup: function (path, flags, suggestFD) {
    var suggest = FS.getStream(suggestFD);
    if (suggest) FS.close(suggest);
    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
  }, doReadv: function (stream, iov, iovcnt, offset) {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = ((SAFE_HEAP_LOAD((((iov) + (i * 8)) | 0), 4, 0)) | 0);
      var len = ((SAFE_HEAP_LOAD((((iov) + (i * 8 + 4)) | 0), 4, 0)) | 0);
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0) return -1;
      ret += curr;
      if (curr < len) break; // nothing more to read
    }
    return ret;
  }, doWritev: function (stream, iov, iovcnt, offset) {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = ((SAFE_HEAP_LOAD((((iov) + (i * 8)) | 0), 4, 0)) | 0);
      var len = ((SAFE_HEAP_LOAD((((iov) + (i * 8 + 4)) | 0), 4, 0)) | 0);
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0) return -1;
      ret += curr;
    }
    return ret;
  }, varargs: undefined, get: function () {
    assert(SYSCALLS.varargs != undefined);
    SYSCALLS.varargs += 4;
    var ret = ((SAFE_HEAP_LOAD((((SYSCALLS.varargs) - (4)) | 0), 4, 0)) | 0);
    return ret;
  }, getStr: function (ptr) {
    var ret = UTF8ToString(ptr);
    return ret;
  }, getStreamFromFD: function (fd) {
    var stream = FS.getStream(fd);
    if (!stream) throw new FS.ErrnoError(8);
    return stream;
  }, get64: function (low, high) {
    if (low >= 0) assert(high === 0);
    else assert(high === -1);
    return low;
  }
};
Module["SYSCALLS"] = SYSCALLS; function ___sys_access(path, amode) {
  try {

    path = SYSCALLS.getStr(path);
    return SYSCALLS.doAccess(path, amode);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_access"] = ___sys_access;

function ___sys_acct(filename) {
  return -52; // unsupported features
}
Module["___sys_acct"] = ___sys_acct;

function ___sys_chdir(path) {
  try {

    path = SYSCALLS.getStr(path);
    FS.chdir(path);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_chdir"] = ___sys_chdir;

function ___sys_chmod(path, mode) {
  try {

    path = SYSCALLS.getStr(path);
    FS.chmod(path, mode);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_chmod"] = ___sys_chmod;

function ___sys_chown32(path, owner, group) {
  try {

    path = SYSCALLS.getStr(path);
    FS.chown(path, owner, group);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_chown32"] = ___sys_chown32;

function ___sys_dup(fd) {
  try {

    var old = SYSCALLS.getStreamFromFD(fd);
    return FS.open(old.path, old.flags, 0).fd;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_dup"] = ___sys_dup;

function ___sys_dup2(oldfd, suggestFD) {
  try {

    var old = SYSCALLS.getStreamFromFD(oldfd);
    if (old.fd === suggestFD) return suggestFD;
    return SYSCALLS.doDup(old.path, old.flags, suggestFD);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_dup2"] = ___sys_dup2;

function ___sys_dup3(fd, suggestFD, flags) {
  try {

    var old = SYSCALLS.getStreamFromFD(fd);
    assert(!flags);
    if (old.fd === suggestFD) return -28;
    return SYSCALLS.doDup(old.path, old.flags, suggestFD);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_dup3"] = ___sys_dup3;

function ___sys_exit_group(status) {
  exit(status);
  return 0;
}
Module["___sys_exit_group"] = ___sys_exit_group;

function ___sys_fadvise64_64(fd, offset, len, advice) {
  return 0; // your advice is important to us (but we can't use it)
}
Module["___sys_fadvise64_64"] = ___sys_fadvise64_64;

function ___sys_fallocate(fd, mode, off_low, off_high, len_low, len_high) {
  try {



    var stream = SYSCALLS.getStreamFromFD(fd)
    var offset = SYSCALLS.get64(off_low, off_high);
    var len = SYSCALLS.get64(len_low, len_high);
    assert(mode === 0);
    FS.allocate(stream, offset, len);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fallocate"] = ___sys_fallocate;

function ___sys_fchdir(fd) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.chdir(stream.path);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fchdir"] = ___sys_fchdir;

function ___sys_fchmod(fd, mode) {
  try {

    FS.fchmod(fd, mode);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fchmod"] = ___sys_fchmod;

function ___sys_fchmodat(dirfd, path, mode, varargs) {
SYSCALLS.varargs = varargs;
  try {

    path = SYSCALLS.getStr(path);
    path = SYSCALLS.calculateAt(dirfd, path);
    mode = SYSCALLS.get();
    FS.chmod(path, mode);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fchmodat"] = ___sys_fchmodat;

function ___sys_fchown32(fd, owner, group) {
  try {

    FS.fchown(fd, owner, group);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fchown32"] = ___sys_fchown32;

function ___sys_fchownat(dirfd, path, owner, group, flags) {
  try {

    path = SYSCALLS.getStr(path);
    assert(flags === 0);
    path = SYSCALLS.calculateAt(dirfd, path);
    FS.chown(path, owner, group);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fchownat"] = ___sys_fchownat;

function ___sys_fcntl64(fd, cmd, varargs) {
SYSCALLS.varargs = varargs;
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (cmd) {
      case 0: {
        var arg = SYSCALLS.get();
        if (arg < 0) {
          return -28;
        }
        var newStream;
        newStream = FS.open(stream.path, stream.flags, 0, arg);
        return newStream.fd;
      }
      case 1:
      case 2:
        return 0;  // FD_CLOEXEC makes no sense for a single process.
      case 3:
        return stream.flags;
      case 4: {
        var arg = SYSCALLS.get();
        stream.flags |= arg;
        return 0;
      }
      case 12:
        /* case 12: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {

          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          SAFE_HEAP_STORE((((arg) + (offset)) | 0), ((2) | 0), 2);
          return 0;
        }
      case 13:
      case 14:
        /* case 13: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 14: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */


        return 0; // Pretend that the locking is successful.
      case 16:
      case 8:
        return -28; // These are for sockets. We don't have them fully implemented yet.
      case 9:
        // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
        setErrNo(28);
        return -1;
      default: {
        return -28;
      }
    }
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fcntl64"] = ___sys_fcntl64;

function ___sys_fdatasync(fd) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    return 0; // we can't do anything synchronously; the in-memory FS is already synced to
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fdatasync"] = ___sys_fdatasync;

function ___sys_fstat64(fd, buf) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    return SYSCALLS.doStat(FS.stat, stream.path, buf);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fstat64"] = ___sys_fstat64;

function ___sys_fstatat64(dirfd, path, buf, flags) {
  try {

    path = SYSCALLS.getStr(path);
    var nofollow = flags & 256;
    flags = flags & (~256);
    assert(!flags, flags);
    path = SYSCALLS.calculateAt(dirfd, path);
    return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fstatat64"] = ___sys_fstatat64;

function ___sys_fstatfs64(fd, size, buf) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    return ___sys_statfs64(0, size, buf);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_fstatfs64"] = ___sys_fstatfs64;

function ___sys_ftruncate64(fd, zero, low, high) {
  try {

    var length = SYSCALLS.get64(low, high);
    FS.ftruncate(fd, length);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_ftruncate64"] = ___sys_ftruncate64;

function ___sys_getcwd(buf, size) {
  try {

    if (size === 0) return -28;
    var cwd = FS.cwd();
    var cwdLengthInBytes = lengthBytesUTF8(cwd);
    if (size < cwdLengthInBytes + 1) return -68;
    stringToUTF8(cwd, buf, size);
    return buf;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_getcwd"] = ___sys_getcwd;

function ___sys_getdents64(fd, dirp, count) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd)
    if (!stream.getdents) {
      stream.getdents = FS.readdir(stream.path);
    }

    var struct_size = 280;
    var pos = 0;
    var off = FS.llseek(stream, 0, 1);

    var idx = Math.floor(off / struct_size);

    while (idx < stream.getdents.length && pos + struct_size <= count) {
      var id;
      var type;
      var name = stream.getdents[idx];
      if (name[0] === '.') {
        id = 1;
        type = 4; // DT_DIR
      } else {
        var child = FS.lookupNode(stream.node, name);
        id = child.id;
        type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
          FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
            FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
              8;                             // DT_REG, regular file.
      }
      (tempI64 = [id >>> 0, (tempDouble = id, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], SAFE_HEAP_STORE(((dirp + pos) | 0), ((tempI64[0]) | 0), 4), SAFE_HEAP_STORE((((dirp + pos) + (4)) | 0), ((tempI64[1]) | 0), 4));
      (tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], SAFE_HEAP_STORE((((dirp + pos) + (8)) | 0), ((tempI64[0]) | 0), 4), SAFE_HEAP_STORE((((dirp + pos) + (12)) | 0), ((tempI64[1]) | 0), 4));
      SAFE_HEAP_STORE((((dirp + pos) + (16)) | 0), ((280) | 0), 2);
      SAFE_HEAP_STORE((((dirp + pos) + (18)) | 0), ((type) | 0), 1);
      stringToUTF8(name, dirp + pos + 19, 256);
      pos += struct_size;
      idx += 1;
    }
    FS.llseek(stream, idx * struct_size, 0);
    return pos;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_getdents64"] = ___sys_getdents64;

function ___sys_getegid32() {
  return 0;
}
Module["___sys_getegid32"] = ___sys_getegid32;

function ___sys_geteuid32(
) {
  return ___sys_getegid32();
}
Module["___sys_geteuid32"] = ___sys_geteuid32;

function ___sys_getgid32(
) {
  return ___sys_getegid32();
}
Module["___sys_getgid32"] = ___sys_getgid32;

function ___sys_getgroups32(size, list) {
  if (size < 1) return -28;
  SAFE_HEAP_STORE(((list) | 0), ((0) | 0), 4);
  return 1;
}
Module["___sys_getgroups32"] = ___sys_getgroups32;

function ___sys_getpgid(pid) {
  if (pid && pid !== 42) return -71;
  return 42;
}
Module["___sys_getpgid"] = ___sys_getpgid;

function ___sys_getpid() {
  return 42;
}
Module["___sys_getpid"] = ___sys_getpid;

function ___sys_getppid() {
  return 1;
}
Module["___sys_getppid"] = ___sys_getppid;

function ___sys_getpriority() {
  return 0;
}
Module["___sys_getpriority"] = ___sys_getpriority;

function ___sys_getresgid32(ruid, euid, suid) {
  SAFE_HEAP_STORE(((ruid) | 0), ((0) | 0), 4);
  SAFE_HEAP_STORE(((euid) | 0), ((0) | 0), 4);
  SAFE_HEAP_STORE(((suid) | 0), ((0) | 0), 4);
  return 0;
}
Module["___sys_getresgid32"] = ___sys_getresgid32;

function ___sys_getresuid32(a0, a1, a2
) {
  return ___sys_getresgid32(a0, a1, a2);
}
Module["___sys_getresuid32"] = ___sys_getresuid32;

function ___sys_getrusage(who, usage) {
  try {

    _memset(usage, 0, 136);
    SAFE_HEAP_STORE(((usage) | 0), ((1) | 0), 4); // fake some values
    SAFE_HEAP_STORE((((usage) + (4)) | 0), ((2) | 0), 4);
    SAFE_HEAP_STORE((((usage) + (8)) | 0), ((3) | 0), 4);
    SAFE_HEAP_STORE((((usage) + (12)) | 0), ((4) | 0), 4);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_getrusage"] = ___sys_getrusage;

function ___sys_getsid(pid) {
  if (pid && pid !== 42) return -71;
  return 42;
}
Module["___sys_getsid"] = ___sys_getsid;

function ___sys_getuid32(
) {
  return ___sys_getegid32();
}
Module["___sys_getuid32"] = ___sys_getuid32;

function ___sys_ioctl(fd, op, varargs) {
SYSCALLS.varargs = varargs;
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (op) {
      case 21509:
      case 21505: {
        if (!stream.tty) return -59;
        return 0;
      }
      case 21510:
      case 21511:
      case 21512:
      case 21506:
      case 21507:
      case 21508: {
        if (!stream.tty) return -59;
        return 0; // no-op, not actually adjusting terminal settings
      }
      case 21519: {
        if (!stream.tty) return -59;
        var argp = SYSCALLS.get();
        SAFE_HEAP_STORE(((argp) | 0), ((0) | 0), 4);
        return 0;
      }
      case 21520: {
        if (!stream.tty) return -59;
        return -28; // not supported
      }
      case 21531: {
        var argp = SYSCALLS.get();
        return FS.ioctl(stream, op, argp);
      }
      case 21523: {
        // TODO: in theory we should write to the winsize struct that gets
        // passed in, but for now musl doesn't read anything on it
        if (!stream.tty) return -59;
        return 0;
      }
      case 21524: {
        // TODO: technically, this ioctl call should change the window size.
        // but, since emscripten doesn't have any concept of a terminal window
        // yet, we'll just silently throw it away as we do TIOCGWINSZ
        if (!stream.tty) return -59;
        return 0;
      }
      default: abort('bad ioctl syscall ' + op);
    }
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_ioctl"] = ___sys_ioctl;

function ___sys_lchown32(path, owner, group) {
  try {

    path = SYSCALLS.getStr(path);
    FS.chown(path, owner, group); // XXX we ignore the 'l' aspect, and do the same as chown
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_lchown32"] = ___sys_lchown32;

function ___sys_link(oldpath, newpath) {
  return -34; // no hardlinks for us
}
Module["___sys_link"] = ___sys_link;

function ___sys_linkat(olddirfd, oldpath, newdirfd, newpath, flags) {
  return -34; // no hardlinks for us
}
Module["___sys_linkat"] = ___sys_linkat;

function ___sys_lstat64(path, buf) {
  try {

    path = SYSCALLS.getStr(path);
    return SYSCALLS.doStat(FS.lstat, path, buf);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_lstat64"] = ___sys_lstat64;

function ___sys_madvise1(addr, length, advice) {
  return 0; // advice is welcome, but ignored
}
Module["___sys_madvise1"] = ___sys_madvise1;

function ___sys_mincore(addr, length, vec) {
  return -52; // unsupported feature
}
Module["___sys_mincore"] = ___sys_mincore;

function ___sys_mkdir(path, mode) {
  try {

    path = SYSCALLS.getStr(path);
    return SYSCALLS.doMkdir(path, mode);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_mkdir"] = ___sys_mkdir;

function ___sys_mkdirat(dirfd, path, mode) {
  try {

    path = SYSCALLS.getStr(path);
    path = SYSCALLS.calculateAt(dirfd, path);
    return SYSCALLS.doMkdir(path, mode);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_mkdirat"] = ___sys_mkdirat;

function ___sys_mknod(path, mode, dev) {
  try {

    path = SYSCALLS.getStr(path);
    return SYSCALLS.doMknod(path, mode, dev);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_mknod"] = ___sys_mknod;

function ___sys_mknodat(dirfd, path, mode, dev) {
  try {

    path = SYSCALLS.getStr(path);
    path = SYSCALLS.calculateAt(dirfd, path);
    return SYSCALLS.doMknod(path, mode, dev);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_mknodat"] = ___sys_mknodat;

function ___sys_mlock(addr, len) {
  return 0;
}
Module["___sys_mlock"] = ___sys_mlock;

function ___sys_mlockall(flags) {
  return 0;
}
Module["___sys_mlockall"] = ___sys_mlockall;


function syscallMmap2(addr, len, prot, flags, fd, off) {
  off <<= 12; // undo pgoffset
  var ptr;
  var allocated = false;

  // addr argument must be page aligned if MAP_FIXED flag is set.
  if ((flags & 16) !== 0 && (addr % 16384) !== 0) {
    return -28;
  }

  // MAP_ANONYMOUS (aka MAP_ANON) isn't actually defined by POSIX spec,
  // but it is widely used way to allocate memory pages on Linux, BSD and Mac.
  // In this case fd argument is ignored.
  if ((flags & 32) !== 0) {
    ptr = _memalign(16384, len);
    if (!ptr) return -48;
    _memset(ptr, 0, len);
    allocated = true;
  } else {
    var info = FS.getStream(fd);
    if (!info) return -8;
    var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags);
    ptr = res.ptr;
    allocated = res.allocated;
  }
  SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, prot: prot, flags: flags, offset: off };
  return ptr;
}
Module["syscallMmap2"] = syscallMmap2; function ___sys_mmap2(addr, len, prot, flags, fd, off) {
  try {

    return syscallMmap2(addr, len, prot, flags, fd, off);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_mmap2"] = ___sys_mmap2;

function ___sys_mprotect(addr, len, size) {
  return 0; // let's not and say we did
}
Module["___sys_mprotect"] = ___sys_mprotect;

function ___sys_mremap(old_addr, old_size, new_size, flags) {
  return -48; // never succeed
}
Module["___sys_mremap"] = ___sys_mremap;

function ___sys_msync(addr, len, flags) {
  try {

    var info = SYSCALLS.mappings[addr];
    if (!info) return 0;
    SYSCALLS.doMsync(addr, FS.getStream(info.fd), len, info.flags, 0);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_msync"] = ___sys_msync;

function ___sys_munlock(addr, len) {
  return 0;
}
Module["___sys_munlock"] = ___sys_munlock;

function ___sys_munlockall() {
  return 0;
}
Module["___sys_munlockall"] = ___sys_munlockall;


function syscallMunmap(addr, len) {
  if ((addr | 0) === -1 || len === 0) {
    return -28;
  }
  // TODO: support unmmap'ing parts of allocations
  var info = SYSCALLS.mappings[addr];
  if (!info) return 0;
  if (len === info.len) {
    var stream = FS.getStream(info.fd);
    if (info.prot & 2) {
      SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);
    }
    FS.munmap(stream);
    SYSCALLS.mappings[addr] = null;
    if (info.allocated) {
      _free(info.malloc);
    }
  }
  return 0;
}
Module["syscallMunmap"] = syscallMunmap; function ___sys_munmap(addr, len) {
  try {

    return syscallMunmap(addr, len);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_munmap"] = ___sys_munmap;

function ___sys_nice(inc) {
  return -63; // no meaning to nice for our single-process environment
}
Module["___sys_nice"] = ___sys_nice;

function ___sys_open(path, flags, varargs) {
SYSCALLS.varargs = varargs;
  try {

    var pathname = SYSCALLS.getStr(path);
    var mode = SYSCALLS.get();
    var stream = FS.open(pathname, flags, mode);
    return stream.fd;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_open"] = ___sys_open;

function ___sys_openat(dirfd, path, flags, varargs) {
SYSCALLS.varargs = varargs;
  try {

    path = SYSCALLS.getStr(path);
    path = SYSCALLS.calculateAt(dirfd, path);
    var mode = SYSCALLS.get();
    return FS.open(path, flags, mode).fd;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_openat"] = ___sys_openat;

function ___sys_pause() {
  return -27; // we can't pause
}
Module["___sys_pause"] = ___sys_pause;


var PIPEFS = {
  BUCKET_BUFFER_SIZE: 8192, mount: function (mount) {
    // Do not pollute the real root directory or its child nodes with pipes
    // Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
    return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
  }, createPipe: function () {
    var pipe = {
      buckets: []
    };

    pipe.buckets.push({
      buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
      offset: 0,
      roffset: 0
    });

    var rName = PIPEFS.nextname();
    var wName = PIPEFS.nextname();
    var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
    var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);

    rNode.pipe = pipe;
    wNode.pipe = pipe;

    var readableStream = FS.createStream({
      path: rName,
      node: rNode,
      flags: FS.modeStringToFlags('r'),
      seekable: false,
      stream_ops: PIPEFS.stream_ops
    });
    rNode.stream = readableStream;

    var writableStream = FS.createStream({
      path: wName,
      node: wNode,
      flags: FS.modeStringToFlags('w'),
      seekable: false,
      stream_ops: PIPEFS.stream_ops
    });
    wNode.stream = writableStream;

    return {
      readable_fd: readableStream.fd,
      writable_fd: writableStream.fd
    };
  }, stream_ops: {
    poll: function (stream) {
      var pipe = stream.node.pipe;

      if ((stream.flags & 2097155) === 1) {
        return (256 | 4);
      } else {
        if (pipe.buckets.length > 0) {
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            if (bucket.offset - bucket.roffset > 0) {
              return (64 | 1);
            }
          }
        }
      }

      return 0;
    }, ioctl: function (stream, request, varargs) {
      return ERRNO_CODES.EINVAL;
    }, fsync: function (stream) {
      return ERRNO_CODES.EINVAL;
    }, read: function (stream, buffer, offset, length, position /* ignored */) {
      var pipe = stream.node.pipe;
      var currentLength = 0;

      for (var i = 0; i < pipe.buckets.length; i++) {
        var bucket = pipe.buckets[i];
        currentLength += bucket.offset - bucket.roffset;
      }

      assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
      var data = buffer.subarray(offset, offset + length);

      if (length <= 0) {
        return 0;
      }
      if (currentLength == 0) {
        // Behave as if the read end is always non-blocking
        throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
      }
      var toRead = Math.min(currentLength, length);

      var totalRead = toRead;
      var toRemove = 0;

      for (var i = 0; i < pipe.buckets.length; i++) {
        var currBucket = pipe.buckets[i];
        var bucketSize = currBucket.offset - currBucket.roffset;

        if (toRead <= bucketSize) {
          var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
          if (toRead < bucketSize) {
            tmpSlice = tmpSlice.subarray(0, toRead);
            currBucket.roffset += toRead;
          } else {
            toRemove++;
          }
          data.set(tmpSlice);
          break;
        } else {
          var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
          data.set(tmpSlice);
          data = data.subarray(tmpSlice.byteLength);
          toRead -= tmpSlice.byteLength;
          toRemove++;
        }
      }

      if (toRemove && toRemove == pipe.buckets.length) {
        // Do not generate excessive garbage in use cases such as
        // write several bytes, read everything, write several bytes, read everything...
        toRemove--;
        pipe.buckets[toRemove].offset = 0;
        pipe.buckets[toRemove].roffset = 0;
      }

      pipe.buckets.splice(0, toRemove);

      return totalRead;
    }, write: function (stream, buffer, offset, length, position /* ignored */) {
      var pipe = stream.node.pipe;

      assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
      var data = buffer.subarray(offset, offset + length);

      var dataLen = data.byteLength;
      if (dataLen <= 0) {
        return 0;
      }

      var currBucket = null;

      if (pipe.buckets.length == 0) {
        currBucket = {
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: 0,
          roffset: 0
        };
        pipe.buckets.push(currBucket);
      } else {
        currBucket = pipe.buckets[pipe.buckets.length - 1];
      }

      assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);

      var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
      if (freeBytesInCurrBuffer >= dataLen) {
        currBucket.buffer.set(data, currBucket.offset);
        currBucket.offset += dataLen;
        return dataLen;
      } else if (freeBytesInCurrBuffer > 0) {
        currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
        currBucket.offset += freeBytesInCurrBuffer;
        data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
      }

      var numBuckets = (data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE) | 0;
      var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;

      for (var i = 0; i < numBuckets; i++) {
        var newBucket = {
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: PIPEFS.BUCKET_BUFFER_SIZE,
          roffset: 0
        };
        pipe.buckets.push(newBucket);
        newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
        data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
      }

      if (remElements > 0) {
        var newBucket = {
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: data.byteLength,
          roffset: 0
        };
        pipe.buckets.push(newBucket);
        newBucket.buffer.set(data);
      }

      return dataLen;
    }, close: function (stream) {
      var pipe = stream.node.pipe;
      pipe.buckets = null;
    }
  }, nextname: function () {
    if (!PIPEFS.nextname.current) {
      PIPEFS.nextname.current = 0;
    }
    return 'pipe[' + (PIPEFS.nextname.current++) + ']';
  }
};
Module["PIPEFS"] = PIPEFS; function ___sys_pipe(fdPtr) {
  try {

    if (fdPtr == 0) {
      throw new FS.ErrnoError(21);
    }

    var res = PIPEFS.createPipe();

    SAFE_HEAP_STORE(((fdPtr) | 0), ((res.readable_fd) | 0), 4);
    SAFE_HEAP_STORE((((fdPtr) + (4)) | 0), ((res.writable_fd) | 0), 4);

    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_pipe"] = ___sys_pipe;

function ___sys_pipe2(fds, flags) {
  return -52; // unsupported feature
}
Module["___sys_pipe2"] = ___sys_pipe2;

function ___sys_poll(fds, nfds, timeout) {
  try {

    var nonzero = 0;
    for (var i = 0; i < nfds; i++) {
      var pollfd = fds + 8 * i;
      var fd = ((SAFE_HEAP_LOAD(((pollfd) | 0), 4, 0)) | 0);
      var events = ((SAFE_HEAP_LOAD((((pollfd) + (4)) | 0), 2, 0)) | 0);
      var mask = 32;
      var stream = FS.getStream(fd);
      if (stream) {
        mask = SYSCALLS.DEFAULT_POLLMASK;
        if (stream.stream_ops.poll) {
          mask = stream.stream_ops.poll(stream);
        }
      }
      mask &= events | 8 | 16;
      if (mask) nonzero++;
      SAFE_HEAP_STORE((((pollfd) + (6)) | 0), ((mask) | 0), 2);
    }
    return nonzero;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_poll"] = ___sys_poll;

function ___sys_pread64(fd, buf, count, zero, low, high) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd)
    var offset = SYSCALLS.get64(low, high);
    return FS.read(stream, HEAP8, buf, count, offset);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_pread64"] = ___sys_pread64;

function ___sys_preadv(fd, iov, iovcnt, low, high) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    return SYSCALLS.doReadv(stream, iov, iovcnt, offset);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_preadv"] = ___sys_preadv;

function ___sys_prlimit64(pid, resource, new_limit, old_limit) {
  try {

    if (old_limit) { // just report no limits
      SAFE_HEAP_STORE(((old_limit) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
      SAFE_HEAP_STORE((((old_limit) + (4)) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
      SAFE_HEAP_STORE((((old_limit) + (8)) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
      SAFE_HEAP_STORE((((old_limit) + (12)) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
    }
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_prlimit64"] = ___sys_prlimit64;

function ___sys_pselect6() {
  return -52; // unsupported feature
}
Module["___sys_pselect6"] = ___sys_pselect6;

function ___sys_pwrite64(fd, buf, count, zero, low, high) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd)
    var offset = SYSCALLS.get64(low, high);
    return FS.write(stream, HEAP8, buf, count, offset);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_pwrite64"] = ___sys_pwrite64;

function ___sys_pwritev(fd, iov, iovcnt, low, high) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    var offset = SYSCALLS.get64(low, high);
    return SYSCALLS.doWritev(stream, iov, iovcnt, offset);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_pwritev"] = ___sys_pwritev;

function ___sys_read(fd, buf, count) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    return FS.read(stream, HEAP8, buf, count);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_read"] = ___sys_read;

function ___sys_readlink(path, buf, bufsize) {
  try {

    path = SYSCALLS.getStr(path);
    return SYSCALLS.doReadlink(path, buf, bufsize);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_readlink"] = ___sys_readlink;

function ___sys_readlinkat(dirfd, path, buf, bufsize) {
  try {

    path = SYSCALLS.getStr(path);
    path = SYSCALLS.calculateAt(dirfd, path);
    return SYSCALLS.doReadlink(path, buf, bufsize);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_readlinkat"] = ___sys_readlinkat;

function ___sys_recvmmsg(sockfd, msgvec, vlen, flags) {
  return 0;
}
Module["___sys_recvmmsg"] = ___sys_recvmmsg;

function ___sys_rename(old_path, new_path) {
  try {

    old_path = SYSCALLS.getStr(old_path);
    new_path = SYSCALLS.getStr(new_path);
    FS.rename(old_path, new_path);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_rename"] = ___sys_rename;

function ___sys_renameat(olddirfd, oldpath, newdirfd, newpath) {
  try {

    oldpath = SYSCALLS.getStr(oldpath);
    newpath = SYSCALLS.getStr(newpath);
    oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
    newpath = SYSCALLS.calculateAt(newdirfd, newpath);
    FS.rename(oldpath, newpath);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_renameat"] = ___sys_renameat;

function ___sys_rmdir(path) {
  try {

    path = SYSCALLS.getStr(path);
    FS.rmdir(path);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_rmdir"] = ___sys_rmdir;

function ___sys_sendmmsg(sockfd, msg, flags) {
  return 0;
}
Module["___sys_sendmmsg"] = ___sys_sendmmsg;

function ___sys_setdomainname(name, size) {
  return -63;
}
Module["___sys_setdomainname"] = ___sys_setdomainname;

function ___sys_setpgid(pid, pgid) {
  if (pid && pid !== 42) return -71;
  if (pgid && pgid !== 42) return -63;
  return 0;
}
Module["___sys_setpgid"] = ___sys_setpgid;

function ___sys_setpriority() {
  return -63;
}
Module["___sys_setpriority"] = ___sys_setpriority;

function ___sys_setrlimit(varargs) {
  return 0; // no-op
}
Module["___sys_setrlimit"] = ___sys_setrlimit;

function ___sys_setsid() {
  return 0; // no-op
}
Module["___sys_setsid"] = ___sys_setsid;


var SOCKFS = {
  mount: function (mount) {
    // If Module['websocket'] has already been defined (e.g. for configuring
    // the subprotocol/url) use that, if not initialise it to a new object.
    Module['websocket'] = (Module['websocket'] &&
      ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};

    // Add the Event registration mechanism to the exported websocket configuration
    // object so we can register network callbacks from native JavaScript too.
    // For more documentation see system/include/emscripten/emscripten.h
    Module['websocket']._callbacks = {};
    Module['websocket']['on'] = /** @this{Object} */ function (event, callback) {
      if ('function' === typeof callback) {
        this._callbacks[event] = callback;
      }
      return this;
    };

    Module['websocket'].emit = /** @this{Object} */ function (event, param) {
      if ('function' === typeof this._callbacks[event]) {
        this._callbacks[event].call(this, param);
      }
    };

    // If debug is enabled register simple default logging callbacks for each Event.

    return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
  }, createSocket: function (family, type, protocol) {
    var streaming = type == 1;
    if (protocol) {
      assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
    }

    // create our internal socket structure
    var sock = {
      family: family,
      type: type,
      protocol: protocol,
      server: null,
      error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
      peers: {},
      pending: [],
      recv_queue: [],
      sock_ops: SOCKFS.websocket_sock_ops
    };

    // create the filesystem node to store the socket structure
    var name = SOCKFS.nextname();
    var node = FS.createNode(SOCKFS.root, name, 49152, 0);
    node.sock = sock;

    // and the wrapping stream that enables library functions such
    // as read and write to indirectly interact with the socket
    var stream = FS.createStream({
      path: name,
      node: node,
      flags: FS.modeStringToFlags('r+'),
      seekable: false,
      stream_ops: SOCKFS.stream_ops
    });

    // map the new stream to the socket structure (sockets have a 1:1
    // relationship with a stream)
    sock.stream = stream;

    return sock;
  }, getSocket: function (fd) {
    var stream = FS.getStream(fd);
    if (!stream || !FS.isSocket(stream.node.mode)) {
      return null;
    }
    return stream.node.sock;
  }, stream_ops: {
    poll: function (stream) {
      var sock = stream.node.sock;
      return sock.sock_ops.poll(sock);
    }, ioctl: function (stream, request, varargs) {
      var sock = stream.node.sock;
      return sock.sock_ops.ioctl(sock, request, varargs);
    }, read: function (stream, buffer, offset, length, position /* ignored */) {
      var sock = stream.node.sock;
      var msg = sock.sock_ops.recvmsg(sock, length);
      if (!msg) {
        // socket is closed
        return 0;
      }
      buffer.set(msg.buffer, offset);
      return msg.buffer.length;
    }, write: function (stream, buffer, offset, length, position /* ignored */) {
      var sock = stream.node.sock;
      return sock.sock_ops.sendmsg(sock, buffer, offset, length);
    }, close: function (stream) {
      var sock = stream.node.sock;
      sock.sock_ops.close(sock);
    }
  }, nextname: function () {
    if (!SOCKFS.nextname.current) {
      SOCKFS.nextname.current = 0;
    }
    return 'socket[' + (SOCKFS.nextname.current++) + ']';
  }, websocket_sock_ops: {
    createPeer: function (sock, addr, port) {
      var ws;

      if (typeof addr === 'object') {
        ws = addr;
        addr = null;
        port = null;
      }

      if (ws) {
        // for sockets that've already connected (e.g. we're the server)
        // we can inspect the _socket property for the address
        if (ws._socket) {
          addr = ws._socket.remoteAddress;
          port = ws._socket.remotePort;
        }
        // if we're just now initializing a connection to the remote,
        // inspect the url property
        else {
          var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
          if (!result) {
            throw new Error('WebSocket URL must be in the format ws(s)://address:port');
          }
          addr = result[1];
          port = parseInt(result[2], 10);
        }
      } else {
        // create the actual websocket object and connect
        try {
          // runtimeConfig gets set to true if WebSocket runtime configuration is available.
          var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));

          // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
          // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
          var url = 'ws:#'.replace('#', '//');

          if (runtimeConfig) {
            if ('string' === typeof Module['websocket']['url']) {
              url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
            }
          }

          if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
            var parts = addr.split('/');
            url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
          }

          // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
          var subProtocols = 'binary'; // The default value is 'binary'

          if (runtimeConfig) {
            if ('string' === typeof Module['websocket']['subprotocol']) {
              subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
            }
          }

          // The default WebSocket options
          var opts = undefined;

          if (subProtocols !== 'null') {
            // The regex trims the string (removes spaces at the beginning and end, then splits the string by
            // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
            subProtocols = subProtocols.replace(/^ +| +$/g, "").split(/ *, */);

            // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
            opts = ENVIRONMENT_IS_NODE ? { 'protocol': subProtocols.toString() } : subProtocols;
          }

          // some webservers (azure) does not support subprotocol header
          if (runtimeConfig && null === Module['websocket']['subprotocol']) {
            subProtocols = 'null';
            opts = undefined;
          }

          // If node we use the ws library.
          var WebSocketConstructor;
          if (ENVIRONMENT_IS_NODE) {
            WebSocketConstructor = /** @type{(typeof WebSocket)} */(require('ws'));
          } else {
            WebSocketConstructor = WebSocket;
          }
          ws = new WebSocketConstructor(url, opts);
          ws.binaryType = 'arraybuffer';
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
        }
      }


      var peer = {
        addr: addr,
        port: port,
        socket: ws,
        dgram_send_queue: []
      };

      SOCKFS.websocket_sock_ops.addPeer(sock, peer);
      SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);

      // if this is a bound dgram socket, send the port number first to allow
      // us to override the ephemeral port reported to us by remotePort on the
      // remote end.
      if (sock.type === 2 && typeof sock.sport !== 'undefined') {
        peer.dgram_send_queue.push(new Uint8Array([
          255, 255, 255, 255,
          'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
          ((sock.sport & 0xff00) >> 8), (sock.sport & 0xff)
        ]));
      }

      return peer;
    }, getPeer: function (sock, addr, port) {
      return sock.peers[addr + ':' + port];
    }, addPeer: function (sock, peer) {
      sock.peers[peer.addr + ':' + peer.port] = peer;
    }, removePeer: function (sock, peer) {
      delete sock.peers[peer.addr + ':' + peer.port];
    }, handlePeerEvents: function (sock, peer) {
      var first = true;

      var handleOpen = function () {

        Module['websocket'].emit('open', sock.stream.fd);

        try {
          var queued = peer.dgram_send_queue.shift();
          while (queued) {
            peer.socket.send(queued);
            queued = peer.dgram_send_queue.shift();
          }
        } catch (e) {
          // not much we can do here in the way of proper error handling as we've already
          // lied and said this data was sent. shut it down.
          peer.socket.close();
        }
      };

      function handleMessage(data) {
        if (typeof data === 'string') {
          var encoder = new TextEncoder(); // should be utf-8
          data = encoder.encode(data); // make a typed array from the string
        } else {
          assert(data.byteLength !== undefined); // must receive an ArrayBuffer
          if (data.byteLength == 0) {
            // An empty ArrayBuffer will emit a pseudo disconnect event
            // as recv/recvmsg will return zero which indicates that a socket
            // has performed a shutdown although the connection has not been disconnected yet.
            return;
          } else {
            data = new Uint8Array(data); // make a typed array view on the array buffer
          }
        }


        // if this is the port message, override the peer's port with it
        var wasfirst = first;
        first = false;
        if (wasfirst &&
          data.length === 10 &&
          data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
          data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
          // update the peer's port and it's key in the peer map
          var newport = ((data[8] << 8) | data[9]);
          SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          peer.port = newport;
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          return;
        }

        sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
        Module['websocket'].emit('message', sock.stream.fd);
      };

      if (ENVIRONMENT_IS_NODE) {
        peer.socket.on('open', handleOpen);
        peer.socket.on('message', function (data, flags) {
          if (!flags.binary) {
            return;
          }
          handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
        });
        peer.socket.on('close', function () {
          Module['websocket'].emit('close', sock.stream.fd);
        });
        peer.socket.on('error', function (error) {
          // Although the ws library may pass errors that may be more descriptive than
          // ECONNREFUSED they are not necessarily the expected error code e.g. 
          // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
          // is still probably the most useful thing to do.
          sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
          Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
          // don't throw
        });
      } else {
        peer.socket.onopen = handleOpen;
        peer.socket.onclose = function () {
          Module['websocket'].emit('close', sock.stream.fd);
        };
        peer.socket.onmessage = function peer_socket_onmessage(event) {
          handleMessage(event.data);
        };
        peer.socket.onerror = function (error) {
          // The WebSocket spec only allows a 'simple event' to be thrown on error,
          // so we only really know as much as ECONNREFUSED.
          sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
          Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
        };
      }
    }, poll: function (sock) {
      if (sock.type === 1 && sock.server) {
        // listen sockets should only say they're available for reading
        // if there are pending clients.
        return sock.pending.length ? (64 | 1) : 0;
      }

      var mask = 0;
      var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
        SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
        null;

      if (sock.recv_queue.length ||
        !dest ||  // connection-less sockets are always ready to read
        (dest && dest.socket.readyState === dest.socket.CLOSING) ||
        (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
        mask |= (64 | 1);
      }

      if (!dest ||  // connection-less sockets are always ready to write
        (dest && dest.socket.readyState === dest.socket.OPEN)) {
        mask |= 4;
      }

      if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
        (dest && dest.socket.readyState === dest.socket.CLOSED)) {
        mask |= 16;
      }

      return mask;
    }, ioctl: function (sock, request, arg) {
      switch (request) {
        case 21531:
          var bytes = 0;
          if (sock.recv_queue.length) {
            bytes = sock.recv_queue[0].data.length;
          }
          SAFE_HEAP_STORE(((arg) | 0), ((bytes) | 0), 4);
          return 0;
        default:
          return ERRNO_CODES.EINVAL;
      }
    }, close: function (sock) {
      // if we've spawned a listen server, close it
      if (sock.server) {
        try {
          sock.server.close();
        } catch (e) {
        }
        sock.server = null;
      }
      // close any peer connections
      var peers = Object.keys(sock.peers);
      for (var i = 0; i < peers.length; i++) {
        var peer = sock.peers[peers[i]];
        try {
          peer.socket.close();
        } catch (e) {
        }
        SOCKFS.websocket_sock_ops.removePeer(sock, peer);
      }
      return 0;
    }, bind: function (sock, addr, port) {
      if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
      }
      sock.saddr = addr;
      sock.sport = port;
      // in order to emulate dgram sockets, we need to launch a listen server when
      // binding on a connection-less socket
      // note: this is only required on the server side
      if (sock.type === 2) {
        // close the existing server if it exists
        if (sock.server) {
          sock.server.close();
          sock.server = null;
        }
        // swallow error operation not supported error that occurs when binding in the
        // browser where this isn't supported
        try {
          sock.sock_ops.listen(sock, 0);
        } catch (e) {
          if (!(e instanceof FS.ErrnoError)) throw e;
          if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
        }
      }
    }, connect: function (sock, addr, port) {
      if (sock.server) {
        throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
      }

      // TODO autobind
      // if (!sock.addr && sock.type == 2) {
      // }

      // early out if we're already connected / in the middle of connecting
      if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
        var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
        if (dest) {
          if (dest.socket.readyState === dest.socket.CONNECTING) {
            throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
          } else {
            throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
          }
        }
      }

      // add the socket to our peer list and set our
      // destination address / port to match
      var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
      sock.daddr = peer.addr;
      sock.dport = peer.port;

      // always "fail" in non-blocking mode
      throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
    }, listen: function (sock, backlog) {
      if (!ENVIRONMENT_IS_NODE) {
        throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
      }
      if (sock.server) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already listening
      }
      var WebSocketServer = require('ws').Server;
      var host = sock.saddr;
      sock.server = new WebSocketServer({
        host: host,
        port: sock.sport
        // TODO support backlog
      });
      Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.

      sock.server.on('connection', function (ws) {
        if (sock.type === 1) {
          var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);

          // create a peer on the new socket
          var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
          newsock.daddr = peer.addr;
          newsock.dport = peer.port;

          // push to queue for accept to pick up
          sock.pending.push(newsock);
          Module['websocket'].emit('connection', newsock.stream.fd);
        } else {
          // create a peer on the listen socket so calling sendto
          // with the listen socket and an address will resolve
          // to the correct client
          SOCKFS.websocket_sock_ops.createPeer(sock, ws);
          Module['websocket'].emit('connection', sock.stream.fd);
        }
      });
      sock.server.on('closed', function () {
        Module['websocket'].emit('close', sock.stream.fd);
        sock.server = null;
      });
      sock.server.on('error', function (error) {
        // Although the ws library may pass errors that may be more descriptive than
        // ECONNREFUSED they are not necessarily the expected error code e.g. 
        // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
        // is still probably the most useful thing to do. This error shouldn't
        // occur in a well written app as errors should get trapped in the compiled
        // app's own getaddrinfo call.
        sock.error = ERRNO_CODES.EHOSTUNREACH; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
        Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
        // don't throw
      });
    }, accept: function (listensock) {
      if (!listensock.server) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
      var newsock = listensock.pending.shift();
      newsock.stream.flags = listensock.stream.flags;
      return newsock;
    }, getname: function (sock, peer) {
      var addr, port;
      if (peer) {
        if (sock.daddr === undefined || sock.dport === undefined) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
        }
        addr = sock.daddr;
        port = sock.dport;
      } else {
        // TODO saddr and sport will be set for bind()'d UDP sockets, but what
        // should we be returning for TCP sockets that've been connect()'d?
        addr = sock.saddr || 0;
        port = sock.sport || 0;
      }
      return { addr: addr, port: port };
    }, sendmsg: function (sock, buffer, offset, length, addr, port) {
      if (sock.type === 2) {
        // connection-less sockets will honor the message address,
        // and otherwise fall back to the bound destination address
        if (addr === undefined || port === undefined) {
          addr = sock.daddr;
          port = sock.dport;
        }
        // if there was no address to fall back to, error out
        if (addr === undefined || port === undefined) {
          throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
        }
      } else {
        // connection-based sockets will only use the bound
        addr = sock.daddr;
        port = sock.dport;
      }

      // find the peer for the destination address
      var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);

      // early out if not connected with a connection-based socket
      if (sock.type === 1) {
        if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
        } else if (dest.socket.readyState === dest.socket.CONNECTING) {
          throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
        }
      }

      // create a copy of the incoming data to send, as the WebSocket API
      // doesn't work entirely with an ArrayBufferView, it'll just send
      // the entire underlying buffer
      if (ArrayBuffer.isView(buffer)) {
        offset += buffer.byteOffset;
        buffer = buffer.buffer;
      }

      var data;
      data = buffer.slice(offset, offset + length);

      // if we're emulating a connection-less dgram socket and don't have
      // a cached connection, queue the buffer to send upon connect and
      // lie, saying the data was sent now.
      if (sock.type === 2) {
        if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
          // if we're not connected, open a new connection
          if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          }
          dest.dgram_send_queue.push(data);
          return length;
        }
      }

      try {
        // send the actual data
        dest.socket.send(data);
        return length;
      } catch (e) {
        throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
      }
    }, recvmsg: function (sock, length) {
      // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
      if (sock.type === 1 && sock.server) {
        // tcp servers should not be recv()'ing on the listen socket
        throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
      }

      var queued = sock.recv_queue.shift();
      if (!queued) {
        if (sock.type === 1) {
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);

          if (!dest) {
            // if we have a destination address but are not connected, error out
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }
          else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
            // return null if the socket has closed
            return null;
          }
          else {
            // else, our socket is in a valid state but truly has nothing available
            throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
          }
        } else {
          throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
        }
      }

      // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
      // requeued TCP data it'll be an ArrayBufferView
      var queuedLength = queued.data.byteLength || queued.data.length;
      var queuedOffset = queued.data.byteOffset || 0;
      var queuedBuffer = queued.data.buffer || queued.data;
      var bytesRead = Math.min(length, queuedLength);
      var res = {
        buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
        addr: queued.addr,
        port: queued.port
      };


      // push back any unread data for TCP connections
      if (sock.type === 1 && bytesRead < queuedLength) {
        var bytesRemaining = queuedLength - bytesRead;
        queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
        sock.recv_queue.unshift(queued);
      }

      return res;
    }
  }
};
Module["SOCKFS"] = SOCKFS;


function __inet_pton4_raw(str) {
  var b = str.split('.');
  for (var i = 0; i < 4; i++) {
    var tmp = Number(b[i]);
    if (isNaN(tmp)) return null;
    b[i] = tmp;
  }
  return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
}
Module["__inet_pton4_raw"] = __inet_pton4_raw;


/** @suppress {checkTypes} */
function jstoi_q(str) {
  return parseInt(str);
}
Module["jstoi_q"] = jstoi_q; function __inet_pton6_raw(str) {
  var words;
  var w, offset, z, i;
  /* http://home.deds.nl/~aeron/regex/ */
  var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
  var parts = [];
  if (!valid6regx.test(str)) {
    return null;
  }
  if (str === "::") {
    return [0, 0, 0, 0, 0, 0, 0, 0];
  }
  // Z placeholder to keep track of zeros when splitting the string on ":"
  if (str.indexOf("::") === 0) {
    str = str.replace("::", "Z:"); // leading zeros case
  } else {
    str = str.replace("::", ":Z:");
  }

  if (str.indexOf(".") > 0) {
    // parse IPv4 embedded stress
    str = str.replace(new RegExp('[.]', 'g'), ":");
    words = str.split(":");
    words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
    words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
    words = words.slice(0, words.length - 2);
  } else {
    words = str.split(":");
  }

  offset = 0; z = 0;
  for (w = 0; w < words.length; w++) {
    if (typeof words[w] === 'string') {
      if (words[w] === 'Z') {
        // compressed zeros - write appropriate number of zero words
        for (z = 0; z < (8 - words.length + 1); z++) {
          parts[w + z] = 0;
        }
        offset = z - 1;
      } else {
        // parse hex to field to 16-bit value and write it in network byte-order
        parts[w + offset] = _htons(parseInt(words[w], 16));
      }
    } else {
      // parsed IPv4 words
      parts[w + offset] = words[w];
    }
  }
  return [
    (parts[1] << 16) | parts[0],
    (parts[3] << 16) | parts[2],
    (parts[5] << 16) | parts[4],
    (parts[7] << 16) | parts[6]
  ];
}
Module["__inet_pton6_raw"] = __inet_pton6_raw; var DNS = {
  address_map: { id: 1, addrs: {}, names: {} }, lookup_name: function (name) {
    // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
    var res = __inet_pton4_raw(name);
    if (res !== null) {
      return name;
    }
    res = __inet_pton6_raw(name);
    if (res !== null) {
      return name;
    }

    // See if this name is already mapped.
    var addr;

    if (DNS.address_map.addrs[name]) {
      addr = DNS.address_map.addrs[name];
    } else {
      var id = DNS.address_map.id++;
      assert(id < 65535, 'exceeded max address mappings of 65535');

      addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);

      DNS.address_map.names[addr] = name;
      DNS.address_map.addrs[name] = addr;
    }

    return addr;
  }, lookup_addr: function (addr) {
    if (DNS.address_map.names[addr]) {
      return DNS.address_map.names[addr];
    }

    return null;
  }
};
Module["DNS"] = DNS;


var Sockets = { BUFFER_SIZE: 10240, MAX_BUFFER_SIZE: 10485760, nextFd: 1, fds: {}, nextport: 1, maxport: 65535, peer: null, connections: {}, portmap: {}, localAddr: 4261412874, addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034] };
Module["Sockets"] = Sockets;

function __inet_ntop4_raw(addr) {
  return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
}
Module["__inet_ntop4_raw"] = __inet_ntop4_raw;

function __inet_ntop6_raw(ints) {
  //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
  //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
  //  128-bits are split into eight 16-bit words
  //  stored in network byte order (big-endian)
  //  |                80 bits               | 16 |      32 bits        |
  //  +-----------------------------------------------------------------+
  //  |               10 bytes               |  2 |      4 bytes        |
  //  +--------------------------------------+--------------------------+
  //  +               5 words                |  1 |      2 words        |
  //  +--------------------------------------+--------------------------+
  //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
  //  +--------------------------------------+----+---------------------+
  //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
  //  +--------------------------------------+----+---------------------+
  var str = "";
  var word = 0;
  var longest = 0;
  var lastzero = 0;
  var zstart = 0;
  var len = 0;
  var i = 0;
  var parts = [
    ints[0] & 0xffff,
    (ints[0] >> 16),
    ints[1] & 0xffff,
    (ints[1] >> 16),
    ints[2] & 0xffff,
    (ints[2] >> 16),
    ints[3] & 0xffff,
    (ints[3] >> 16)
  ];

  // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses

  var hasipv4 = true;
  var v4part = "";
  // check if the 10 high-order bytes are all zeros (first 5 words)
  for (i = 0; i < 5; i++) {
    if (parts[i] !== 0) { hasipv4 = false; break; }
  }

  if (hasipv4) {
    // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
    v4part = __inet_ntop4_raw(parts[6] | (parts[7] << 16));
    // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
    if (parts[5] === -1) {
      str = "::ffff:";
      str += v4part;
      return str;
    }
    // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
    if (parts[5] === 0) {
      str = "::";
      //special case IPv6 addresses
      if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
      if (v4part === "0.0.0.1") v4part = "1";// loopback address
      str += v4part;
      return str;
    }
  }

  // Handle all other IPv6 addresses

  // first run to find the longest contiguous zero words
  for (word = 0; word < 8; word++) {
    if (parts[word] === 0) {
      if (word - lastzero > 1) {
        len = 0;
      }
      lastzero = word;
      len++;
    }
    if (len > longest) {
      longest = len;
      zstart = word - longest + 1;
    }
  }

  for (word = 0; word < 8; word++) {
    if (longest > 1) {
      // compress contiguous zeros - to produce "::"
      if (parts[word] === 0 && word >= zstart && word < (zstart + longest)) {
        if (word === zstart) {
          str += ":";
          if (zstart === 0) str += ":"; //leading zeros case
        }
        continue;
      }
    }
    // converts 16-bit words from big-endian to little-endian before converting to hex string
    str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
    str += word < 7 ? ":" : "";
  }
  return str;
}
Module["__inet_ntop6_raw"] = __inet_ntop6_raw; function __read_sockaddr(sa, salen) {
  // family / port offsets are common to both sockaddr_in and sockaddr_in6
  var family = ((SAFE_HEAP_LOAD(((sa) | 0), 2, 0)) | 0);
  var port = _ntohs(((SAFE_HEAP_LOAD((((sa) + (2)) | 0), 2, 1)) | 0));
  var addr;

  switch (family) {
    case 2:
      if (salen !== 16) {
        return { errno: 28 };
      }
      addr = ((SAFE_HEAP_LOAD((((sa) + (4)) | 0), 4, 0)) | 0);
      addr = __inet_ntop4_raw(addr);
      break;
    case 10:
      if (salen !== 28) {
        return { errno: 28 };
      }
      addr = [
        ((SAFE_HEAP_LOAD((((sa) + (8)) | 0), 4, 0)) | 0),
        ((SAFE_HEAP_LOAD((((sa) + (12)) | 0), 4, 0)) | 0),
        ((SAFE_HEAP_LOAD((((sa) + (16)) | 0), 4, 0)) | 0),
        ((SAFE_HEAP_LOAD((((sa) + (20)) | 0), 4, 0)) | 0)
      ];
      addr = __inet_ntop6_raw(addr);
      break;
    default:
      return { errno: 5 };
  }

  return { family: family, addr: addr, port: port };
}
Module["__read_sockaddr"] = __read_sockaddr;

function __write_sockaddr(sa, family, addr, port) {
  switch (family) {
    case 2:
      addr = __inet_pton4_raw(addr);
      SAFE_HEAP_STORE(((sa) | 0), ((family) | 0), 2);
      SAFE_HEAP_STORE((((sa) + (4)) | 0), ((addr) | 0), 4);
      SAFE_HEAP_STORE((((sa) + (2)) | 0), ((_htons(port)) | 0), 2);
      break;
    case 10:
      addr = __inet_pton6_raw(addr);
      SAFE_HEAP_STORE(((sa) | 0), ((family) | 0), 4);
      SAFE_HEAP_STORE((((sa) + (8)) | 0), ((addr[0]) | 0), 4);
      SAFE_HEAP_STORE((((sa) + (12)) | 0), ((addr[1]) | 0), 4);
      SAFE_HEAP_STORE((((sa) + (16)) | 0), ((addr[2]) | 0), 4);
      SAFE_HEAP_STORE((((sa) + (20)) | 0), ((addr[3]) | 0), 4);
      SAFE_HEAP_STORE((((sa) + (2)) | 0), ((_htons(port)) | 0), 2);
      SAFE_HEAP_STORE((((sa) + (4)) | 0), ((0) | 0), 4);
      SAFE_HEAP_STORE((((sa) + (24)) | 0), ((0) | 0), 4);
      break;
    default:
      return { errno: 5 };
  }
  // kind of lame, but let's match _read_sockaddr's interface
  return {};
}
Module["__write_sockaddr"] = __write_sockaddr; function ___sys_socketcall(call, socketvararg) {
  try {

    // socketcalls pass the rest of the arguments in a struct
    SYSCALLS.varargs = socketvararg;

    var getSocketFromFD = function () {
      var socket = SOCKFS.getSocket(SYSCALLS.get());
      if (!socket) throw new FS.ErrnoError(8);
      return socket;
    };
    /** @param {boolean=} allowNull */
    var getSocketAddress = function (allowNull) {
      var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();
      if (allowNull && addrp === 0) return null;
      var info = __read_sockaddr(addrp, addrlen);
      if (info.errno) throw new FS.ErrnoError(info.errno);
      info.addr = DNS.lookup_addr(info.addr) || info.addr;
      return info;
    };

    switch (call) {
      case 1: { // socket
        var domain = SYSCALLS.get(), type = SYSCALLS.get(), protocol = SYSCALLS.get();
        var sock = SOCKFS.createSocket(domain, type, protocol);
        assert(sock.stream.fd < 64); // XXX ? select() assumes socket fd values are in 0..63
        return sock.stream.fd;
      }
      case 2: { // bind
        var sock = getSocketFromFD(), info = getSocketAddress();
        sock.sock_ops.bind(sock, info.addr, info.port);
        return 0;
      }
      case 3: { // connect
        var sock = getSocketFromFD(), info = getSocketAddress();
        sock.sock_ops.connect(sock, info.addr, info.port);
        return 0;
      }
      case 4: { // listen
        var sock = getSocketFromFD(), backlog = SYSCALLS.get();
        sock.sock_ops.listen(sock, backlog);
        return 0;
      }
      case 5: { // accept
        var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
        var newsock = sock.sock_ops.accept(sock);
        if (addr) {
          var res = __write_sockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport);
          assert(!res.errno);
        }
        return newsock.stream.fd;
      }
      case 6: { // getsockname
        var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
        // TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
        var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || '0.0.0.0'), sock.sport);
        assert(!res.errno);
        return 0;
      }
      case 7: { // getpeername
        var sock = getSocketFromFD(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
        if (!sock.daddr) {
          return -53; // The socket is not connected.
        }
        var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport);
        assert(!res.errno);
        return 0;
      }
      case 11: { // sendto
        var sock = getSocketFromFD(), message = SYSCALLS.get(), length = SYSCALLS.get(), flags = SYSCALLS.get(), dest = getSocketAddress(true);
        if (!dest) {
          // send, no address provided
          return FS.write(sock.stream, HEAP8, message, length);
        } else {
          // sendto an address
          return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
        }
      }
      case 12: { // recvfrom
        var sock = getSocketFromFD(), buf = SYSCALLS.get(), len = SYSCALLS.get(), flags = SYSCALLS.get(), addr = SYSCALLS.get(), addrlen = SYSCALLS.get();
        var msg = sock.sock_ops.recvmsg(sock, len);
        if (!msg) return 0; // socket is closed
        if (addr) {
          var res = __write_sockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port);
          assert(!res.errno);
        }
        HEAPU8.set(msg.buffer, buf);
        return msg.buffer.byteLength;
      }
      case 14: { // setsockopt
        return -50; // The option is unknown at the level indicated.
      }
      case 15: { // getsockopt
        var sock = getSocketFromFD(), level = SYSCALLS.get(), optname = SYSCALLS.get(), optval = SYSCALLS.get(), optlen = SYSCALLS.get();
        // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
        // so only supports SOL_SOCKET with SO_ERROR.
        if (level === 1) {
          if (optname === 4) {
            SAFE_HEAP_STORE(((optval) | 0), ((sock.error) | 0), 4);
            SAFE_HEAP_STORE(((optlen) | 0), ((4) | 0), 4);
            sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
            return 0;
          }
        }
        return -50; // The option is unknown at the level indicated.
      }
      case 16: { // sendmsg
        var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();
        var iov = ((SAFE_HEAP_LOAD((((message) + (8)) | 0), 4, 0)) | 0);
        var num = ((SAFE_HEAP_LOAD((((message) + (12)) | 0), 4, 0)) | 0);
        // read the address and port to send to
        var addr, port;
        var name = ((SAFE_HEAP_LOAD(((message) | 0), 4, 0)) | 0);
        var namelen = ((SAFE_HEAP_LOAD((((message) + (4)) | 0), 4, 0)) | 0);
        if (name) {
          var info = __read_sockaddr(name, namelen);
          if (info.errno) return -info.errno;
          port = info.port;
          addr = DNS.lookup_addr(info.addr) || info.addr;
        }
        // concatenate scatter-gather arrays into one message buffer
        var total = 0;
        for (var i = 0; i < num; i++) {
          total += ((SAFE_HEAP_LOAD((((iov) + ((8 * i) + 4)) | 0), 4, 0)) | 0);
        }
        var view = new Uint8Array(total);
        var offset = 0;
        for (var i = 0; i < num; i++) {
          var iovbase = ((SAFE_HEAP_LOAD((((iov) + ((8 * i) + 0)) | 0), 4, 0)) | 0);
          var iovlen = ((SAFE_HEAP_LOAD((((iov) + ((8 * i) + 4)) | 0), 4, 0)) | 0);
          for (var j = 0; j < iovlen; j++) {
            view[offset++] = ((SAFE_HEAP_LOAD((((iovbase) + (j)) | 0), 1, 0)) | 0);
          }
        }
        // write the buffer
        return sock.sock_ops.sendmsg(sock, view, 0, total, addr, port);
      }
      case 17: { // recvmsg
        var sock = getSocketFromFD(), message = SYSCALLS.get(), flags = SYSCALLS.get();
        var iov = ((SAFE_HEAP_LOAD((((message) + (8)) | 0), 4, 0)) | 0);
        var num = ((SAFE_HEAP_LOAD((((message) + (12)) | 0), 4, 0)) | 0);
        // get the total amount of data we can read across all arrays
        var total = 0;
        for (var i = 0; i < num; i++) {
          total += ((SAFE_HEAP_LOAD((((iov) + ((8 * i) + 4)) | 0), 4, 0)) | 0);
        }
        // try to read total data
        var msg = sock.sock_ops.recvmsg(sock, total);
        if (!msg) return 0; // socket is closed

        // TODO honor flags:
        // MSG_OOB
        // Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific.
        // MSG_PEEK
        // Peeks at the incoming message.
        // MSG_WAITALL
        // Requests that the function block until the full amount of data requested can be returned. The function may return a smaller amount of data if a signal is caught, if the connection is terminated, if MSG_PEEK was specified, or if an error is pending for the socket.

        // write the source address out
        var name = ((SAFE_HEAP_LOAD(((message) | 0), 4, 0)) | 0);
        if (name) {
          var res = __write_sockaddr(name, sock.family, DNS.lookup_name(msg.addr), msg.port);
          assert(!res.errno);
        }
        // write the buffer out to the scatter-gather arrays
        var bytesRead = 0;
        var bytesRemaining = msg.buffer.byteLength;
        for (var i = 0; bytesRemaining > 0 && i < num; i++) {
          var iovbase = ((SAFE_HEAP_LOAD((((iov) + ((8 * i) + 0)) | 0), 4, 0)) | 0);
          var iovlen = ((SAFE_HEAP_LOAD((((iov) + ((8 * i) + 4)) | 0), 4, 0)) | 0);
          if (!iovlen) {
            continue;
          }
          var length = Math.min(iovlen, bytesRemaining);
          var buf = msg.buffer.subarray(bytesRead, bytesRead + length);
          HEAPU8.set(buf, iovbase + bytesRead);
          bytesRead += length;
          bytesRemaining -= length;
        }

        // TODO set msghdr.msg_flags
        // MSG_EOR
        // End of record was received (if supported by the protocol).
        // MSG_OOB
        // Out-of-band data was received.
        // MSG_TRUNC
        // Normal data was truncated.
        // MSG_CTRUNC

        return bytesRead;
      }
      default: {
        return -52; // unsupported feature
      }
    }
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_socketcall"] = ___sys_socketcall;

function ___sys_stat64(path, buf) {
  try {

    path = SYSCALLS.getStr(path);
    return SYSCALLS.doStat(FS.stat, path, buf);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_stat64"] = ___sys_stat64;

function ___sys_statfs64(path, size, buf) {
  try {

    path = SYSCALLS.getStr(path);
    assert(size === 64);
    // NOTE: None of the constants here are true. We're just returning safe and
    //       sane values.
    SAFE_HEAP_STORE((((buf) + (4)) | 0), ((4096) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (40)) | 0), ((4096) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (8)) | 0), ((1000000) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (12)) | 0), ((500000) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (16)) | 0), ((500000) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (20)) | 0), ((FS.nextInode) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (24)) | 0), ((1000000) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (28)) | 0), ((42) | 0), 4);
    SAFE_HEAP_STORE((((buf) + (44)) | 0), ((2) | 0), 4);  // ST_NOSUID
    SAFE_HEAP_STORE((((buf) + (36)) | 0), ((255) | 0), 4);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_statfs64"] = ___sys_statfs64;

function ___sys_symlink(target, linkpath) {
  try {

    target = SYSCALLS.getStr(target);
    linkpath = SYSCALLS.getStr(linkpath);
    FS.symlink(target, linkpath);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_symlink"] = ___sys_symlink;

function ___sys_symlinkat(target, newdirfd, linkpath) {
  try {

    linkpath = SYSCALLS.calculateAt(newdirfd, linkpath);
    FS.symlink(target, linkpath);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_symlinkat"] = ___sys_symlinkat;

function ___sys_sync() {
  return 0;
}
Module["___sys_sync"] = ___sys_sync;

function ___sys_truncate64(path, zero, low, high) {
  try {

    path = SYSCALLS.getStr(path);
    var length = SYSCALLS.get64(low, high);
    FS.truncate(path, length);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_truncate64"] = ___sys_truncate64;

function ___sys_ugetrlimit(resource, rlim) {
  try {

    SAFE_HEAP_STORE(((rlim) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
    SAFE_HEAP_STORE((((rlim) + (4)) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
    SAFE_HEAP_STORE((((rlim) + (8)) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
    SAFE_HEAP_STORE((((rlim) + (12)) | 0), ((-1) | 0), 4);  // RLIM_INFINITY
    return 0; // just report no limits
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_ugetrlimit"] = ___sys_ugetrlimit;

function ___sys_umask(mask) {
  try {

    var old = SYSCALLS.umask;
    SYSCALLS.umask = mask;
    return old;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_umask"] = ___sys_umask;

function ___sys_uname(buf) {
  try {

    if (!buf) return -21
    var layout = { "__size__": 390, "sysname": 0, "nodename": 65, "release": 130, "version": 195, "machine": 260, "domainname": 325 };
    var copyString = function (element, value) {
      var offset = layout[element];
      writeAsciiToMemory(value, buf + offset);
    };
    copyString('sysname', 'Emscripten');
    copyString('nodename', 'emscripten');
    copyString('release', '1.0');
    copyString('version', '#1');
    copyString('machine', 'x86-JS');
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_uname"] = ___sys_uname;

function ___sys_unlink(path) {
  try {

    path = SYSCALLS.getStr(path);
    FS.unlink(path);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_unlink"] = ___sys_unlink;

function ___sys_unlinkat(dirfd, path, flags) {
  try {

    path = SYSCALLS.getStr(path);
    path = SYSCALLS.calculateAt(dirfd, path);
    if (flags === 0) {
      FS.unlink(path);
    } else if (flags === 512) {
      FS.rmdir(path);
    } else {
      abort('Invalid flags passed to unlinkat');
    }
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_unlinkat"] = ___sys_unlinkat;

function ___sys_utimensat(dirfd, path, times, flags) {
  try {

    path = SYSCALLS.getStr(path);
    assert(flags === 0);
    path = SYSCALLS.calculateAt(dirfd, path);
    var seconds = ((SAFE_HEAP_LOAD(((times) | 0), 4, 0)) | 0);
    var nanoseconds = ((SAFE_HEAP_LOAD((((times) + (4)) | 0), 4, 0)) | 0);
    var atime = (seconds * 1000) + (nanoseconds / (1000 * 1000));
    times += 8;
    seconds = ((SAFE_HEAP_LOAD(((times) | 0), 4, 0)) | 0);
    nanoseconds = ((SAFE_HEAP_LOAD((((times) + (4)) | 0), 4, 0)) | 0);
    var mtime = (seconds * 1000) + (nanoseconds / (1000 * 1000));
    FS.utime(path, atime, mtime);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_utimensat"] = ___sys_utimensat;

function ___sys_wait4(pid, wstart, options, rusage) {
  try {

    abort('cannot wait on child processes');
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_wait4"] = ___sys_wait4;

function ___sys_write(fd, buf, count) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    return FS.write(stream, HEAP8, buf, count);
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
Module["___sys_write"] = ___sys_write;

function ___wait() { }
Module["___wait"] = ___wait;


function _exit(status) {
  // void _exit(int status);
  // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
  exit(status);
}
Module["_exit"] = _exit; function __exit(a0
) {
  return _exit(a0);
}
Module["__exit"] = __exit;

function _abort() {
  abort();
}
Module["_abort"] = _abort;

function _atexit(func, arg) {
  warnOnce('atexit() called, but EXIT_RUNTIME is not set, so atexits() will not be called. set EXIT_RUNTIME to 1 (see the FAQ)');
  __ATEXIT__.unshift({ func: func, arg: arg });
}
Module["_atexit"] = _atexit;



/** @suppress{checkTypes} */
function _emscripten_with_builtin_malloc(func) {
  var prev_malloc = typeof _malloc !== 'undefined' ? _malloc : undefined;
  var prev_memalign = typeof _memalign !== 'undefined' ? _memalign : undefined;
  var prev_free = typeof _free !== 'undefined' ? _free : undefined;
  _malloc = _emscripten_builtin_malloc;
  _memalign = _emscripten_builtin_memalign;
  _free = _emscripten_builtin_free;
  try {
    return func();
  } finally {
    _malloc = prev_malloc;
    _memalign = prev_memalign;
    _free = prev_free;
  }
}
Module["_emscripten_with_builtin_malloc"] = _emscripten_with_builtin_malloc; function _emscripten_builtin_mmap2(addr, len, prot, flags, fd, off) {
  return _emscripten_with_builtin_malloc(function () {
    return syscallMmap2(addr, len, prot, flags, fd, off);
  });
}
Module["_emscripten_builtin_mmap2"] = _emscripten_builtin_mmap2;

function _emscripten_builtin_munmap(addr, len) {
  return _emscripten_with_builtin_malloc(function () {
    return syscallMunmap(addr, len);
  });
}
Module["_emscripten_builtin_munmap"] = _emscripten_builtin_munmap;

function _emscripten_get_module_name(buf, length) {
  return stringToUTF8(wasmBinaryFile, buf, length);
}
Module["_emscripten_get_module_name"] = _emscripten_get_module_name;

function _emscripten_get_sbrk_ptr() {
  return 4975184;
}
Module["_emscripten_get_sbrk_ptr"] = _emscripten_get_sbrk_ptr;

function _emscripten_memcpy_big(dest, src, num) {
  HEAPU8.copyWithin(dest, src, src + num);
}
Module["_emscripten_memcpy_big"] = _emscripten_memcpy_big;



var UNWIND_CACHE = {};
Module["UNWIND_CACHE"] = UNWIND_CACHE;

function _emscripten_generate_pc(frame) {
  var match;

  if (match = /\bwasm-function\[\d+\]:(0x[0-9a-f]+)/.exec(frame)) {
    // some engines give the binary offset directly, so we use that as return address
    return +match[1];
  } else if (match = /\bwasm-function\[(\d+)\]:(\d+)/.exec(frame)) {
    // other engines only give function index and offset in the function,
    // so we try using the offset converter. If that doesn't work,
    // we pack index and offset into a "return address"
    return wasmOffsetConverter.convert(+match[1], +match[2]);
  } else if (match = /:(\d+):\d+(?:\)|$)/.exec(frame)) {
    // if we are in js, we can use the js line number as the "return address"
    // this should work for wasm2js and fastcomp
    // we tag the high bit to distinguish this from wasm addresses
    return 0x80000000 | +match[1];
  } else {
    // return 0 if we can't find any
    return 0;
  }
}
Module["_emscripten_generate_pc"] = _emscripten_generate_pc; function _emscripten_pc_get_source_js(pc) {
  if (UNWIND_CACHE.last_get_source_pc == pc) return UNWIND_CACHE.last_source;

  var match;
  var source;

  if (!source) {
    var frame = UNWIND_CACHE[pc];
    if (!frame) return null;
    // Example: at callMain (a.out.js:6335:22)
    if (match = /\((.*):(\d+):(\d+)\)$/.exec(frame)) {
      source = { file: match[1], line: match[2], column: match[3] };
      // Example: main@a.out.js:1337:42
    } else if (match = /@(.*):(\d+):(\d+)/.exec(frame)) {
      source = { file: match[1], line: match[2], column: match[3] };
    }
  }
  UNWIND_CACHE.last_get_source_pc = pc;
  UNWIND_CACHE.last_source = source;
  return source;
}
Module["_emscripten_pc_get_source_js"] = _emscripten_pc_get_source_js; function _emscripten_pc_get_column(pc) {
  var result = _emscripten_pc_get_source_js(pc);
  return result ? result.column || 0 : 0;
}
Module["_emscripten_pc_get_column"] = _emscripten_pc_get_column;

function _emscripten_pc_get_file(pc) {
  var result = _emscripten_pc_get_source_js(pc);
  if (!result) return 0;

  _emscripten_with_builtin_malloc(function () {
    if (_emscripten_pc_get_file.ret) _free(_emscripten_pc_get_file.ret);
    _emscripten_pc_get_file.ret = allocateUTF8(result.file);
  });
  return _emscripten_pc_get_file.ret;
}
Module["_emscripten_pc_get_file"] = _emscripten_pc_get_file;

function _emscripten_pc_get_function(pc) {
  var name;
  if (pc & 0x80000000) {
    // If this is a JavaScript function, try looking it up in the unwind cache.
    var frame = UNWIND_CACHE[pc];
    if (!frame) return 0;

    var match;
    if (match = /^\s+at (.*) \(.*\)$/.exec(frame)) {
      name = match[1];
    } else if (match = /^(.+?)@/.exec(frame)) {
      name = match[1];
    } else {
      return 0;
    }
  } else {
    name = wasmOffsetConverter.getName(pc);
  }
  _emscripten_with_builtin_malloc(function () {
    if (_emscripten_pc_get_function.ret) _free(_emscripten_pc_get_function.ret);
    _emscripten_pc_get_function.ret = allocateUTF8(name);
  });
  return _emscripten_pc_get_function.ret;
}
Module["_emscripten_pc_get_function"] = _emscripten_pc_get_function;

function _emscripten_pc_get_line(pc) {
  var result = _emscripten_pc_get_source_js(pc);
  return result ? result.line : 0;
}
Module["_emscripten_pc_get_line"] = _emscripten_pc_get_line;


function _emscripten_get_heap_size() {
  return HEAPU8.length;
}
Module["_emscripten_get_heap_size"] = _emscripten_get_heap_size;

function emscripten_realloc_buffer(size) {
  try {
    // round size grow request up to wasm page size (fixed 64KB per spec)
    wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
    updateGlobalBufferAndViews(wasmMemory.buffer);
    return 1 /*success*/;
  } catch (e) {
    console.error('emscripten_realloc_buffer: Attempted to grow heap from ' + buffer.byteLength + ' bytes to ' + size + ' bytes, but got error: ' + e);
  }
}
Module["emscripten_realloc_buffer"] = emscripten_realloc_buffer; function _emscripten_resize_heap(requestedSize) {
  requestedSize = requestedSize >>> 0;
  var oldSize = _emscripten_get_heap_size();
  // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.
  assert(requestedSize > oldSize);


  var PAGE_MULTIPLE = 65536;

  // Memory resize rules:
  // 1. When resizing, always produce a resized heap that is at least 16MB (to avoid tiny heap sizes receiving lots of repeated resizes at startup)
  // 2. Always increase heap size to at least the requested size, rounded up to next page multiple.
  // 3a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap geometrically: increase the heap size according to 
  //                                         MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%),
  //                                         At most overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
  // 3b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap linearly: increase the heap size by at least MEMORY_GROWTH_LINEAR_STEP bytes.
  // 4. Max size for the heap is capped at 2048MB-PAGE_MULTIPLE, or by MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
  // 5. If we were unable to allocate as much memory, it may be due to over-eager decision to excessively reserve due to (3) above.
  //    Hence if an allocation fails, cut down on the amount of excess growth, in an attempt to succeed to perform a smaller allocation.

  // A limit was set for how much we can grow. We should not exceed that
  // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
  var maxHeapSize = 2147483648;
  if (requestedSize > maxHeapSize) {
    err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + maxHeapSize + ' bytes!');
    return false;
  }

  var minHeapSize = 16777216;

  // Loop through potential heap size increases. If we attempt a too eager reservation that fails, cut down on the
  // attempted size and reserve a smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
    var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
    // but limit overreserving (default to capping at +96MB overgrowth at most)
    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);


    var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));

    var replacement = emscripten_realloc_buffer(newSize);
    if (replacement) {

      return true;
    }
  }
  err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');
  return false;
}
Module["_emscripten_resize_heap"] = _emscripten_resize_heap;

function _emscripten_return_address(level) {
  var callstack = new Error().stack.split('\n');
  if (callstack[0] == 'Error') {
    callstack.shift();
  }
  // skip this function and the caller to get caller's return address
  return _emscripten_generate_pc(callstack[level + 2]);
}
Module["_emscripten_return_address"] = _emscripten_return_address;


function __emscripten_save_in_unwind_cache(callstack) {
  callstack.forEach(function (frame) {
    var pc = _emscripten_generate_pc(frame);
    if (pc) {
      UNWIND_CACHE[pc] = frame;
    }
  });
}
Module["__emscripten_save_in_unwind_cache"] = __emscripten_save_in_unwind_cache; function _emscripten_stack_snapshot() {
  var callstack = new Error().stack.split('\n');
  if (callstack[0] == 'Error') {
    callstack.shift();
  }
  __emscripten_save_in_unwind_cache(callstack);

  // Caches the stack snapshot so that emscripten_stack_unwind_buffer() can unwind from this spot.
  UNWIND_CACHE.last_addr = _emscripten_generate_pc(callstack[2]);
  UNWIND_CACHE.last_stack = callstack;
  return UNWIND_CACHE.last_addr;
}
Module["_emscripten_stack_snapshot"] = _emscripten_stack_snapshot;

function _emscripten_stack_unwind_buffer(addr, buffer, count) {
  var stack;
  if (UNWIND_CACHE.last_addr == addr) {
    stack = UNWIND_CACHE.last_stack;
  } else {
    stack = new Error().stack.split('\n');
    if (stack[0] == 'Error') {
      stack.shift();
    }
    __emscripten_save_in_unwind_cache(stack);
  }

  var offset = 2;
  while (stack[offset] && _emscripten_generate_pc(stack[offset]) != addr) {
    ++offset;
  }

  for (var i = 0; i < count && stack[i + offset]; ++i) {
    HEAP32[(((buffer) + (i * 4)) >> 2)] = _emscripten_generate_pc(stack[i + offset]);
  }
  return i;
}
Module["_emscripten_stack_unwind_buffer"] = _emscripten_stack_unwind_buffer;



var ENV = {};
Module["ENV"] = ENV;

function __getExecutableName() {
  return thisProgram || './this.program';
}
Module["__getExecutableName"] = __getExecutableName; function getEnvStrings() {
  if (!getEnvStrings.strings) {
    // Default values.
    var env = {
      'USER': 'web_user',
      'LOGNAME': 'web_user',
      'PATH': '/',
      'PWD': '/',
      'HOME': '/home/web_user',
      // Browser language detection #8751
      'LANG': ((typeof navigator === 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8',
      '_': __getExecutableName()
    };
    // Apply the user-provided values, if any.
    for (var x in ENV) {
      env[x] = ENV[x];
    }
    var strings = [];
    for (var x in env) {
      strings.push(x + '=' + env[x]);
    }
    getEnvStrings.strings = strings;
  }
  return getEnvStrings.strings;
}
Module["getEnvStrings"] = getEnvStrings; function _environ_get(__environ, environ_buf) {
  var bufSize = 0;
  getEnvStrings().forEach(function (string, i) {
    var ptr = environ_buf + bufSize;
    SAFE_HEAP_STORE((((__environ) + (i * 4)) | 0), ((ptr) | 0), 4);
    writeAsciiToMemory(string, ptr);
    bufSize += string.length + 1;
  });
  return 0;
}
Module["_environ_get"] = _environ_get;

function _environ_sizes_get(penviron_count, penviron_buf_size) {
  var strings = getEnvStrings();
  SAFE_HEAP_STORE(((penviron_count) | 0), ((strings.length) | 0), 4);
  var bufSize = 0;
  strings.forEach(function (string) {
    bufSize += string.length + 1;
  });
  SAFE_HEAP_STORE(((penviron_buf_size) | 0), ((bufSize) | 0), 4);
  return 0;
}
Module["_environ_sizes_get"] = _environ_sizes_get;


function _execl(path, arg0, varArgs) {
  // int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
  // http://pubs.opengroup.org/onlinepubs/009695399/functions/exec.html
  // We don't support executing external code.
  setErrNo(45);
  return -1;
}
Module["_execl"] = _execl; function _execv(a0, a1, a2
) {
  return _execl(a0, a1, a2);
}
Module["_execv"] = _execv;

function _fd_close(fd) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.close(stream);
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
Module["_fd_close"] = _fd_close;

function _fd_fdstat_get(fd, pbuf) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    // All character devices are terminals (other things a Linux system would
    // assume is a character device, like the mouse, we have special APIs for).
    var type = stream.tty ? 2 :
      FS.isDir(stream.mode) ? 3 :
        FS.isLink(stream.mode) ? 7 :
          4;
    SAFE_HEAP_STORE(((pbuf) | 0), ((type) | 0), 1);
    // TODO SAFE_HEAP_STORE((((pbuf)+(2))|0), ((?)|0), 2);
    // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],SAFE_HEAP_STORE((((pbuf)+(8))|0), ((tempI64[0])|0), 4),SAFE_HEAP_STORE((((pbuf)+(12))|0), ((tempI64[1])|0), 4));
    // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],SAFE_HEAP_STORE((((pbuf)+(16))|0), ((tempI64[0])|0), 4),SAFE_HEAP_STORE((((pbuf)+(20))|0), ((tempI64[1])|0), 4));
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
Module["_fd_fdstat_get"] = _fd_fdstat_get;

function _fd_read(fd, iov, iovcnt, pnum) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = SYSCALLS.doReadv(stream, iov, iovcnt);
    SAFE_HEAP_STORE(((pnum) | 0), ((num) | 0), 4)
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
Module["_fd_read"] = _fd_read;

function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {


    var stream = SYSCALLS.getStreamFromFD(fd);
    var HIGH_OFFSET = 0x100000000; // 2^32
    // use an unsigned operator on low and shift high by 32-bits
    var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);

    var DOUBLE_LIMIT = 0x20000000000000; // 2^53
    // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
    if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
      return -61;
    }

    FS.llseek(stream, offset, whence);
    (tempI64 = [stream.position >>> 0, (tempDouble = stream.position, (+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], SAFE_HEAP_STORE(((newOffset) | 0), ((tempI64[0]) | 0), 4), SAFE_HEAP_STORE((((newOffset) + (4)) | 0), ((tempI64[1]) | 0), 4));
    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
Module["_fd_seek"] = _fd_seek;

function _fd_sync(fd) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    if (stream.stream_ops && stream.stream_ops.fsync) {
      return -stream.stream_ops.fsync(stream);
    }
    return 0; // we can't do anything synchronously; the in-memory FS is already synced to
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
Module["_fd_sync"] = _fd_sync;

function _fd_write(fd, iov, iovcnt, pnum) {
  try {

    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = SYSCALLS.doWritev(stream, iov, iovcnt);
    SAFE_HEAP_STORE(((pnum) | 0), ((num) | 0), 4)
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
Module["_fd_write"] = _fd_write;

function _fork() {
  // pid_t fork(void);
  // http://pubs.opengroup.org/onlinepubs/000095399/functions/fork.html
  // We don't support multiple processes.
  setErrNo(6);
  return -1;
}
Module["_fork"] = _fork;

function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
  var info = __read_sockaddr(sa, salen);
  if (info.errno) {
    return -6;
  }
  var port = info.port;
  var addr = info.addr;

  var overflowed = false;

  if (node && nodelen) {
    var lookup;
    if ((flags & 1) || !(lookup = DNS.lookup_addr(addr))) {
      if (flags & 8) {
        return -2;
      }
    } else {
      addr = lookup;
    }
    var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);

    if (numBytesWrittenExclNull + 1 >= nodelen) {
      overflowed = true;
    }
  }

  if (serv && servlen) {
    port = '' + port;
    var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);

    if (numBytesWrittenExclNull + 1 >= servlen) {
      overflowed = true;
    }
  }

  if (overflowed) {
    // Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
    return -12;
  }

  return 0;
}
Module["_getnameinfo"] = _getnameinfo;


var ___tm_timezone = (stringToUTF8("GMT", 4975248, 4), 4975248);
Module["___tm_timezone"] = ___tm_timezone; function _gmtime_r(time, tmPtr) {
  var date = new Date(((SAFE_HEAP_LOAD(((time) | 0), 4, 0)) | 0) * 1000);
  SAFE_HEAP_STORE(((tmPtr) | 0), ((date.getUTCSeconds()) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (4)) | 0), ((date.getUTCMinutes()) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (8)) | 0), ((date.getUTCHours()) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (12)) | 0), ((date.getUTCDate()) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (16)) | 0), ((date.getUTCMonth()) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (20)) | 0), ((date.getUTCFullYear() - 1900) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (24)) | 0), ((date.getUTCDay()) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (36)) | 0), ((0) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (32)) | 0), ((0) | 0), 4);
  var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
  var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24)) | 0;
  SAFE_HEAP_STORE((((tmPtr) + (28)) | 0), ((yday) | 0), 4);
  SAFE_HEAP_STORE((((tmPtr) + (40)) | 0), ((___tm_timezone) | 0), 4);

  return tmPtr;
}
Module["_gmtime_r"] = _gmtime_r;

function _inet_addr(ptr) {
  var addr = __inet_pton4_raw(UTF8ToString(ptr));
  if (addr === null) {
    return -1;
  }
  return addr;
}
Module["_inet_addr"] = _inet_addr;


function _usleep(useconds) {
  // int usleep(useconds_t useconds);
  // http://pubs.opengroup.org/onlinepubs/000095399/functions/usleep.html
  // We're single-threaded, so use a busy loop. Super-ugly.
  var start = _emscripten_get_now();
  while (_emscripten_get_now() - start < useconds / 1000) {
    // Do nothing.
  }
}
Module["_usleep"] = _usleep; function _nanosleep(rqtp, rmtp) {
  // int nanosleep(const struct timespec  *rqtp, struct timespec *rmtp);
  if (rqtp === 0) {
    setErrNo(28);
    return -1;
  }
  var seconds = ((SAFE_HEAP_LOAD(((rqtp) | 0), 4, 0)) | 0);
  var nanoseconds = ((SAFE_HEAP_LOAD((((rqtp) + (4)) | 0), 4, 0)) | 0);
  if (nanoseconds < 0 || nanoseconds > 999999999 || seconds < 0) {
    setErrNo(28);
    return -1;
  }
  if (rmtp !== 0) {
    SAFE_HEAP_STORE(((rmtp) | 0), ((0) | 0), 4);
    SAFE_HEAP_STORE((((rmtp) + (4)) | 0), ((0) | 0), 4);
  }
  return _usleep((seconds * 1e6) + (nanoseconds / 1000));
}
Module["_nanosleep"] = _nanosleep;

function _pthread_attr_getstack(attr, stackaddr, stacksize) {
  /* int pthread_attr_getstack(const pthread_attr_t *restrict attr,
     void **restrict stackaddr, size_t *restrict stacksize); */
  /*FIXME: assumes that there is only one thread, and that attr is the
    current thread*/
  SAFE_HEAP_STORE(((stackaddr) | 0), ((STACK_BASE) | 0), 4);
  SAFE_HEAP_STORE(((stacksize) | 0), ((TOTAL_STACK) | 0), 4);
  return 0;
}
Module["_pthread_attr_getstack"] = _pthread_attr_getstack;

function _pthread_attr_setstacksize() { }
Module["_pthread_attr_setstacksize"] = _pthread_attr_setstacksize;

function _pthread_cleanup_pop() {
  assert(_pthread_cleanup_push.level == __ATEXIT__.length, 'cannot pop if something else added meanwhile!');
  __ATEXIT__.pop();
  _pthread_cleanup_push.level = __ATEXIT__.length;
}
Module["_pthread_cleanup_pop"] = _pthread_cleanup_pop;

function _pthread_cleanup_push(routine, arg) {
  __ATEXIT__.push(function () { dynCall_vi(routine, arg) })
  _pthread_cleanup_push.level = __ATEXIT__.length;
}
Module["_pthread_cleanup_push"] = _pthread_cleanup_push;

function _pthread_setcancelstate() { return 0; }
Module["_pthread_setcancelstate"] = _pthread_setcancelstate;

function _pthread_sigmask(how, set, oldset) {
  err('pthread_sigmask() is not supported: this is a no-op.');
  return 0;
}
Module["_pthread_sigmask"] = _pthread_sigmask;


function _round(d) {
  d = +d;
  return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);
}
Module["_round"] = _round;

function _roundf(d) {
  d = +d;
  return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);
}
Module["_roundf"] = _roundf;

function _setTempRet0($i) {
  setTempRet0(($i) | 0);
}
Module["_setTempRet0"] = _setTempRet0;

function _setitimer() {
  throw 'setitimer() is not implemented yet';
}
Module["_setitimer"] = _setitimer;

function _sigaction(signum, act, oldact) {
  //int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
  err('Calling stub instead of sigaction()');
  return 0;
}
Module["_sigaction"] = _sigaction;

/** @type {function(...*):?} */
function _sigaltstack(
) {
  err('missing function: sigaltstack'); abort(-1);
}
Module["_sigaltstack"] = _sigaltstack;

function _sigfillset(set) {
  SAFE_HEAP_STORE(((set) | 0), ((-1 >>> 0) | 0), 4);
  return 0;
}
Module["_sigfillset"] = _sigfillset;


function __isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
Module["__isLeapYear"] = __isLeapYear;

function __arraySum(array, index) {
  var sum = 0;
  for (var i = 0; i <= index; sum += array[i++]) {
    // no-op
  }
  return sum;
}
Module["__arraySum"] = __arraySum;


var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
Module["__MONTH_DAYS_LEAP"] = __MONTH_DAYS_LEAP;

var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
Module["__MONTH_DAYS_REGULAR"] = __MONTH_DAYS_REGULAR; function __addDays(date, days) {
  var newDate = new Date(date.getTime());
  while (days > 0) {
    var leap = __isLeapYear(newDate.getFullYear());
    var currentMonth = newDate.getMonth();
    var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];

    if (days > daysInCurrentMonth - newDate.getDate()) {
      // we spill over to next month
      days -= (daysInCurrentMonth - newDate.getDate() + 1);
      newDate.setDate(1);
      if (currentMonth < 11) {
        newDate.setMonth(currentMonth + 1)
      } else {
        newDate.setMonth(0);
        newDate.setFullYear(newDate.getFullYear() + 1);
      }
    } else {
      // we stay in current month
      newDate.setDate(newDate.getDate() + days);
      return newDate;
    }
  }

  return newDate;
}
Module["__addDays"] = __addDays; function _strftime(s, maxsize, format, tm) {
  // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
  // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html

  var tm_zone = ((SAFE_HEAP_LOAD((((tm) + (40)) | 0), 4, 0)) | 0);

  var date = {
    tm_sec: ((SAFE_HEAP_LOAD(((tm) | 0), 4, 0)) | 0),
    tm_min: ((SAFE_HEAP_LOAD((((tm) + (4)) | 0), 4, 0)) | 0),
    tm_hour: ((SAFE_HEAP_LOAD((((tm) + (8)) | 0), 4, 0)) | 0),
    tm_mday: ((SAFE_HEAP_LOAD((((tm) + (12)) | 0), 4, 0)) | 0),
    tm_mon: ((SAFE_HEAP_LOAD((((tm) + (16)) | 0), 4, 0)) | 0),
    tm_year: ((SAFE_HEAP_LOAD((((tm) + (20)) | 0), 4, 0)) | 0),
    tm_wday: ((SAFE_HEAP_LOAD((((tm) + (24)) | 0), 4, 0)) | 0),
    tm_yday: ((SAFE_HEAP_LOAD((((tm) + (28)) | 0), 4, 0)) | 0),
    tm_isdst: ((SAFE_HEAP_LOAD((((tm) + (32)) | 0), 4, 0)) | 0),
    tm_gmtoff: ((SAFE_HEAP_LOAD((((tm) + (36)) | 0), 4, 0)) | 0),
    tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''
  };

  var pattern = UTF8ToString(format);

  // expand format
  var EXPANSION_RULES_1 = {
    '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
    '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y
    '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d
    '%h': '%b',                       // Equivalent to %b
    '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation
    '%R': '%H:%M',                    // Replaced by the time in 24-hour notation
    '%T': '%H:%M:%S',                 // Replaced by the time
    '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation
    '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation
    // Modified Conversion Specifiers
    '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.
    '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.
    '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.
    '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.
    '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.
    '%EY': '%Y',                      // Replaced by the full alternative year representation.
    '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.
    '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.
    '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
    '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
    '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.
    '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.
    '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.
    '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
    '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.
    '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.
    '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
    '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
    '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.
  };
  for (var rule in EXPANSION_RULES_1) {
    pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
  }

  var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

  function leadingSomething(value, digits, character) {
    var str = typeof value === 'number' ? value.toString() : (value || '');
    while (str.length < digits) {
      str = character[0] + str;
    }
    return str;
  }

  function leadingNulls(value, digits) {
    return leadingSomething(value, digits, '0');
  }

  function compareByDay(date1, date2) {
    function sgn(value) {
      return value < 0 ? -1 : (value > 0 ? 1 : 0);
    }

    var compare;
    if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
      if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
        compare = sgn(date1.getDate() - date2.getDate());
      }
    }
    return compare;
  }

  function getFirstWeekStartDate(janFourth) {
    switch (janFourth.getDay()) {
      case 0: // Sunday
        return new Date(janFourth.getFullYear() - 1, 11, 29);
      case 1: // Monday
        return janFourth;
      case 2: // Tuesday
        return new Date(janFourth.getFullYear(), 0, 3);
      case 3: // Wednesday
        return new Date(janFourth.getFullYear(), 0, 2);
      case 4: // Thursday
        return new Date(janFourth.getFullYear(), 0, 1);
      case 5: // Friday
        return new Date(janFourth.getFullYear() - 1, 11, 31);
      case 6: // Saturday
        return new Date(janFourth.getFullYear() - 1, 11, 30);
    }
  }

  function getWeekBasedYear(date) {
    var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);

    var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
    var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);

    var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
    var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);

    if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
      // this date is after the start of the first week of this year
      if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
        return thisDate.getFullYear() + 1;
      } else {
        return thisDate.getFullYear();
      }
    } else {
      return thisDate.getFullYear() - 1;
    }
  }

  var EXPANSION_RULES_2 = {
    '%a': function (date) {
      return WEEKDAYS[date.tm_wday].substring(0, 3);
    },
    '%A': function (date) {
      return WEEKDAYS[date.tm_wday];
    },
    '%b': function (date) {
      return MONTHS[date.tm_mon].substring(0, 3);
    },
    '%B': function (date) {
      return MONTHS[date.tm_mon];
    },
    '%C': function (date) {
      var year = date.tm_year + 1900;
      return leadingNulls((year / 100) | 0, 2);
    },
    '%d': function (date) {
      return leadingNulls(date.tm_mday, 2);
    },
    '%e': function (date) {
      return leadingSomething(date.tm_mday, 2, ' ');
    },
    '%g': function (date) {
      // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.
      // In this system, weeks begin on a Monday and week 1 of the year is the week that includes
      // January 4th, which is also the week that includes the first Thursday of the year, and
      // is also the first week that contains at least four days in the year.
      // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of
      // the last week of the preceding year; thus, for Saturday 2nd January 1999,
      // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,
      // or 31st is a Monday, it and any following days are part of week 1 of the following year.
      // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.

      return getWeekBasedYear(date).toString().substring(2);
    },
    '%G': function (date) {
      return getWeekBasedYear(date);
    },
    '%H': function (date) {
      return leadingNulls(date.tm_hour, 2);
    },
    '%I': function (date) {
      var twelveHour = date.tm_hour;
      if (twelveHour == 0) twelveHour = 12;
      else if (twelveHour > 12) twelveHour -= 12;
      return leadingNulls(twelveHour, 2);
    },
    '%j': function (date) {
      // Day of the year (001-366)
      return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);
    },
    '%m': function (date) {
      return leadingNulls(date.tm_mon + 1, 2);
    },
    '%M': function (date) {
      return leadingNulls(date.tm_min, 2);
    },
    '%n': function () {
      return '\n';
    },
    '%p': function (date) {
      if (date.tm_hour >= 0 && date.tm_hour < 12) {
        return 'AM';
      } else {
        return 'PM';
      }
    },
    '%S': function (date) {
      return leadingNulls(date.tm_sec, 2);
    },
    '%t': function () {
      return '\t';
    },
    '%u': function (date) {
      return date.tm_wday || 7;
    },
    '%U': function (date) {
      // Replaced by the week number of the year as a decimal number [00,53].
      // The first Sunday of January is the first day of week 1;
      // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
      var janFirst = new Date(date.tm_year + 1900, 0, 1);
      var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);

      // is target date after the first Sunday?
      if (compareByDay(firstSunday, endDate) < 0) {
        // calculate difference in days between first Sunday and endDate
        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
        var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
        var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
        return leadingNulls(Math.ceil(days / 7), 2);
      }

      return compareByDay(firstSunday, janFirst) === 0 ? '01' : '00';
    },
    '%V': function (date) {
      // Replaced by the week number of the year (Monday as the first day of the week)
      // as a decimal number [01,53]. If the week containing 1 January has four
      // or more days in the new year, then it is considered week 1.
      // Otherwise, it is the last week of the previous year, and the next week is week 1.
      // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
      var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);
      var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);

      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);

      var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);

      if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
        // if given date is before this years first week, then it belongs to the 53rd week of last year
        return '53';
      }

      if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
        // if given date is after next years first week, then it belongs to the 01th week of next year
        return '01';
      }

      // given date is in between CW 01..53 of this calendar year
      var daysDifference;
      if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {
        // first CW of this year starts last year
        daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate()
      } else {
        // first CW of this year starts this year
        daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();
      }
      return leadingNulls(Math.ceil(daysDifference / 7), 2);
    },
    '%w': function (date) {
      return date.tm_wday;
    },
    '%W': function (date) {
      // Replaced by the week number of the year as a decimal number [00,53].
      // The first Monday of January is the first day of week 1;
      // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
      var janFirst = new Date(date.tm_year, 0, 1);
      var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);

      // is target date after the first Monday?
      if (compareByDay(firstMonday, endDate) < 0) {
        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
        var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
        var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
        return leadingNulls(Math.ceil(days / 7), 2);
      }
      return compareByDay(firstMonday, janFirst) === 0 ? '01' : '00';
    },
    '%y': function (date) {
      // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
      return (date.tm_year + 1900).toString().substring(2);
    },
    '%Y': function (date) {
      // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
      return date.tm_year + 1900;
    },
    '%z': function (date) {
      // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
      // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
      var off = date.tm_gmtoff;
      var ahead = off >= 0;
      off = Math.abs(off) / 60;
      // convert from minutes into hhmm format (which means 60 minutes = 100 units)
      off = (off / 60) * 100 + (off % 60);
      return (ahead ? '+' : '-') + String("0000" + off).slice(-4);
    },
    '%Z': function (date) {
      return date.tm_zone;
    },
    '%%': function () {
      return '%';
    }
  };
  for (var rule in EXPANSION_RULES_2) {
    if (pattern.indexOf(rule) >= 0) {
      pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));
    }
  }

  var bytes = intArrayFromString(pattern, false);
  if (bytes.length > maxsize) {
    return 0;
  }

  writeArrayToMemory(bytes, s);
  return bytes.length - 1;
}
Module["_strftime"] = _strftime;

function _sysconf(name) {
  // long sysconf(int name);
  // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
  switch (name) {
    case 30: return 16384;
    case 85:
      var maxHeapSize = 2147483648;
      return maxHeapSize / 16384;
    case 132:
    case 133:
    case 12:
    case 137:
    case 138:
    case 15:
    case 235:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 149:
    case 13:
    case 10:
    case 236:
    case 153:
    case 9:
    case 21:
    case 22:
    case 159:
    case 154:
    case 14:
    case 77:
    case 78:
    case 139:
    case 80:
    case 81:
    case 82:
    case 68:
    case 67:
    case 164:
    case 11:
    case 29:
    case 47:
    case 48:
    case 95:
    case 52:
    case 51:
    case 46:
    case 79:
      return 200809;
    case 27:
    case 246:
    case 127:
    case 128:
    case 23:
    case 24:
    case 160:
    case 161:
    case 181:
    case 182:
    case 242:
    case 183:
    case 184:
    case 243:
    case 244:
    case 245:
    case 165:
    case 178:
    case 179:
    case 49:
    case 50:
    case 168:
    case 169:
    case 175:
    case 170:
    case 171:
    case 172:
    case 97:
    case 76:
    case 32:
    case 173:
    case 35:
      return -1;
    case 176:
    case 177:
    case 7:
    case 155:
    case 8:
    case 157:
    case 125:
    case 126:
    case 92:
    case 93:
    case 129:
    case 130:
    case 131:
    case 94:
    case 91:
      return 1;
    case 74:
    case 60:
    case 69:
    case 70:
    case 4:
      return 1024;
    case 31:
    case 42:
    case 72:
      return 32;
    case 87:
    case 26:
    case 33:
      return 2147483647;
    case 34:
    case 1:
      return 47839;
    case 38:
    case 36:
      return 99;
    case 43:
    case 37:
      return 2048;
    case 0: return 2097152;
    case 3: return 65536;
    case 28: return 32768;
    case 44: return 32767;
    case 75: return 16384;
    case 39: return 1000;
    case 89: return 700;
    case 71: return 256;
    case 40: return 255;
    case 2: return 100;
    case 180: return 64;
    case 25: return 20;
    case 5: return 16;
    case 6: return 6;
    case 73: return 4;
    case 84: {
      if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;
      return 1;
    }
  }
  setErrNo(28);
  return -1;
}
Module["_sysconf"] = _sysconf;

function _time(ptr) {
  var ret = (Date.now() / 1000) | 0;
  if (ptr) {
    SAFE_HEAP_STORE(((ptr) | 0), ((ret) | 0), 4);
  }
  return ret;
}
Module["_time"] = _time;



function _wait(stat_loc) {
  // pid_t wait(int *stat_loc);
  // http://pubs.opengroup.org/onlinepubs/009695399/functions/wait.html
  // Makes no sense in a single-process environment.
  setErrNo(12);
  return -1;
}
Module["_wait"] = _wait; function _waitpid(a0
) {
  return _wait(a0);
}
Module["_waitpid"] = _waitpid;

function readAsmConstArgs(sigPtr, buf) {
  if (!readAsmConstArgs.array) {
    readAsmConstArgs.array = [];
  }
  var args = readAsmConstArgs.array;
  args.length = 0;
  var ch;
  while (ch = HEAPU8[sigPtr++]) {
    if (ch === 100/*'d'*/ || ch === 102/*'f'*/) {
      buf = (buf + 7) & ~7;
      args.push(HEAPF64[(buf >> 3)]);
      buf += 8;
    } else
      if (ch === 105 /*'i'*/) {
        buf = (buf + 3) & ~3;
        args.push(HEAP32[(buf >> 2)]);
        buf += 4;
      }
      else abort("unexpected char in asm const signature " + ch);
  }
  return args;
}
Module["readAsmConstArgs"] = readAsmConstArgs;
var FSNode = /** @constructor */ function (parent, name, mode, rdev) {
  if (!parent) {
    parent = this;  // root node sets parent to itself
  }
  this.parent = parent;
  this.mount = parent.mount;
  this.mounted = null;
  this.id = FS.nextInode++;
  this.name = name;
  this.mode = mode;
  this.node_ops = {};
  this.stream_ops = {};
  this.rdev = rdev;
};
var readMode = 292/*292*/ | 73/*73*/;
var writeMode = 146/*146*/;
Object.defineProperties(FSNode.prototype, {
  read: {
    get: /** @this{FSNode} */function () {
      return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function (val) {
      val ? this.mode |= readMode : this.mode &= ~readMode;
    }
  },
  write: {
    get: /** @this{FSNode} */function () {
      return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function (val) {
      val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
  },
  isFolder: {
    get: /** @this{FSNode} */function () {
      return FS.isDir(this.mode);
    }
  },
  isDevice: {
    get: /** @this{FSNode} */function () {
      return FS.isChrdev(this.mode);
    }
  }
});
FS.FSNode = FSNode;
FS.staticInit();;
var ASSERTIONS = true;

/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// ASM_LIBRARY EXTERN PRIMITIVES: Math_floor,Math_ceil

var asmGlobalArg = {};
var asmLibraryArg = { "_Z18__wasi_syscall_rett": __Z18__wasi_syscall_rett, "_ZN11__sanitizer15__clock_gettimeEiPv": __ZN11__sanitizer15__clock_gettimeEiPv, "_ZN11__sanitizer17SymbolizerProcess25StartSymbolizerSubprocessEv": __ZN11__sanitizer17SymbolizerProcess25StartSymbolizerSubprocessEv, "__clock_gettime": ___clock_gettime, "__handle_stack_overflow": ___handle_stack_overflow, "__map_file": ___map_file, "__sys__newselect": ___sys__newselect, "__sys_access": ___sys_access, "__sys_acct": ___sys_acct, "__sys_chdir": ___sys_chdir, "__sys_chmod": ___sys_chmod, "__sys_chown32": ___sys_chown32, "__sys_dup": ___sys_dup, "__sys_dup2": ___sys_dup2, "__sys_dup3": ___sys_dup3, "__sys_exit_group": ___sys_exit_group, "__sys_fadvise64_64": ___sys_fadvise64_64, "__sys_fallocate": ___sys_fallocate, "__sys_fchdir": ___sys_fchdir, "__sys_fchmod": ___sys_fchmod, "__sys_fchmodat": ___sys_fchmodat, "__sys_fchown32": ___sys_fchown32, "__sys_fchownat": ___sys_fchownat, "__sys_fcntl64": ___sys_fcntl64, "__sys_fdatasync": ___sys_fdatasync, "__sys_fstat64": ___sys_fstat64, "__sys_fstatat64": ___sys_fstatat64, "__sys_fstatfs64": ___sys_fstatfs64, "__sys_ftruncate64": ___sys_ftruncate64, "__sys_getcwd": ___sys_getcwd, "__sys_getdents64": ___sys_getdents64, "__sys_getegid32": ___sys_getegid32, "__sys_geteuid32": ___sys_geteuid32, "__sys_getgid32": ___sys_getgid32, "__sys_getgroups32": ___sys_getgroups32, "__sys_getpgid": ___sys_getpgid, "__sys_getpid": ___sys_getpid, "__sys_getppid": ___sys_getppid, "__sys_getpriority": ___sys_getpriority, "__sys_getresgid32": ___sys_getresgid32, "__sys_getresuid32": ___sys_getresuid32, "__sys_getrusage": ___sys_getrusage, "__sys_getsid": ___sys_getsid, "__sys_getuid32": ___sys_getuid32, "__sys_ioctl": ___sys_ioctl, "__sys_lchown32": ___sys_lchown32, "__sys_link": ___sys_link, "__sys_linkat": ___sys_linkat, "__sys_lstat64": ___sys_lstat64, "__sys_madvise1": ___sys_madvise1, "__sys_mincore": ___sys_mincore, "__sys_mkdir": ___sys_mkdir, "__sys_mkdirat": ___sys_mkdirat, "__sys_mknod": ___sys_mknod, "__sys_mknodat": ___sys_mknodat, "__sys_mlock": ___sys_mlock, "__sys_mlockall": ___sys_mlockall, "__sys_mmap2": ___sys_mmap2, "__sys_mprotect": ___sys_mprotect, "__sys_mremap": ___sys_mremap, "__sys_msync": ___sys_msync, "__sys_munlock": ___sys_munlock, "__sys_munlockall": ___sys_munlockall, "__sys_munmap": ___sys_munmap, "__sys_nice": ___sys_nice, "__sys_open": ___sys_open, "__sys_openat": ___sys_openat, "__sys_pause": ___sys_pause, "__sys_pipe": ___sys_pipe, "__sys_pipe2": ___sys_pipe2, "__sys_poll": ___sys_poll, "__sys_pread64": ___sys_pread64, "__sys_preadv": ___sys_preadv, "__sys_prlimit64": ___sys_prlimit64, "__sys_pselect6": ___sys_pselect6, "__sys_pwrite64": ___sys_pwrite64, "__sys_pwritev": ___sys_pwritev, "__sys_read": ___sys_read, "__sys_readlink": ___sys_readlink, "__sys_readlinkat": ___sys_readlinkat, "__sys_recvmmsg": ___sys_recvmmsg, "__sys_rename": ___sys_rename, "__sys_renameat": ___sys_renameat, "__sys_rmdir": ___sys_rmdir, "__sys_sendmmsg": ___sys_sendmmsg, "__sys_setdomainname": ___sys_setdomainname, "__sys_setpgid": ___sys_setpgid, "__sys_setpriority": ___sys_setpriority, "__sys_setrlimit": ___sys_setrlimit, "__sys_setsid": ___sys_setsid, "__sys_socketcall": ___sys_socketcall, "__sys_stat64": ___sys_stat64, "__sys_statfs64": ___sys_statfs64, "__sys_symlink": ___sys_symlink, "__sys_symlinkat": ___sys_symlinkat, "__sys_sync": ___sys_sync, "__sys_truncate64": ___sys_truncate64, "__sys_ugetrlimit": ___sys_ugetrlimit, "__sys_umask": ___sys_umask, "__sys_uname": ___sys_uname, "__sys_unlink": ___sys_unlink, "__sys_unlinkat": ___sys_unlinkat, "__sys_utimensat": ___sys_utimensat, "__sys_wait4": ___sys_wait4, "__sys_write": ___sys_write, "__wait": ___wait, "_exit": __exit, "abort": _abort, "alignfault": alignfault, "atexit": _atexit, "clock_gettime": _clock_gettime, "emscripten_asm_const_iii": _emscripten_asm_const_iii, "emscripten_builtin_mmap2": _emscripten_builtin_mmap2, "emscripten_builtin_munmap": _emscripten_builtin_munmap, "emscripten_get_module_name": _emscripten_get_module_name, "emscripten_get_sbrk_ptr": _emscripten_get_sbrk_ptr, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_pc_get_column": _emscripten_pc_get_column, "emscripten_pc_get_file": _emscripten_pc_get_file, "emscripten_pc_get_function": _emscripten_pc_get_function, "emscripten_pc_get_line": _emscripten_pc_get_line, "emscripten_resize_heap": _emscripten_resize_heap, "emscripten_return_address": _emscripten_return_address, "emscripten_stack_snapshot": _emscripten_stack_snapshot, "emscripten_stack_unwind_buffer": _emscripten_stack_unwind_buffer, "environ_get": _environ_get, "environ_sizes_get": _environ_sizes_get, "execv": _execv, "fd_close": _fd_close, "fd_fdstat_get": _fd_fdstat_get, "fd_read": _fd_read, "fd_seek": _fd_seek, "fd_sync": _fd_sync, "fd_write": _fd_write, "fork": _fork, "getTempRet0": getTempRet0, "getnameinfo": _getnameinfo, "gmtime_r": _gmtime_r, "inet_addr": _inet_addr, "memory": wasmMemory, "nanosleep": _nanosleep, "pthread_attr_getstack": _pthread_attr_getstack, "pthread_attr_setstacksize": _pthread_attr_setstacksize, "pthread_cleanup_pop": _pthread_cleanup_pop, "pthread_cleanup_push": _pthread_cleanup_push, "pthread_setcancelstate": _pthread_setcancelstate, "pthread_sigmask": _pthread_sigmask, "round": _round, "roundf": _roundf, "segfault": segfault, "setTempRet0": setTempRet0, "setitimer": _setitimer, "sigaction": _sigaction, "sigaltstack": _sigaltstack, "sigfillset": _sigfillset, "strftime": _strftime, "sysconf": _sysconf, "table": wasmTable, "time": _time, "usleep": _usleep, "waitpid": _waitpid };
var asm = createWasm();
Module["asm"] = asm;
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasm_call_ctors"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3dec_init = Module["_drmp3dec_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3dec_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3dec_decode_frame = Module["_drmp3dec_decode_frame"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3dec_decode_frame"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memset = Module["_memset"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memcpy = Module["_memcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3dec_f32_to_s16 = Module["_drmp3dec_f32_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3dec_f32_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_cache_init = Module["_drmp3_src_cache_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_cache_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_cache_read_frames = Module["_drmp3_src_cache_read_frames"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_cache_read_frames"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_init = Module["_drmp3_src_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_set_input_sample_rate = Module["_drmp3_src_set_input_sample_rate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_set_input_sample_rate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_set_output_sample_rate = Module["_drmp3_src_set_output_sample_rate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_set_output_sample_rate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_read_frames_ex = Module["_drmp3_src_read_frames_ex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_read_frames_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_read_frames_linear = Module["_drmp3_src_read_frames_linear"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_read_frames_linear"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_read_frames_passthrough = Module["_drmp3_src_read_frames_passthrough"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_read_frames_passthrough"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_src_read_frames = Module["_drmp3_src_read_frames"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_src_read_frames"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_init_internal = Module["_drmp3_init_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_init_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fclose = Module["_fclose"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fclose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_uninit = Module["_drmp3_uninit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_uninit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_init = Module["_drmp3_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_init_memory = Module["_drmp3_init_memory"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_init_memory"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_init_file = Module["_drmp3_init_file"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_init_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fopen = Module["_fopen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fread = Module["_fread"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fseek = Module["_fseek"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fseek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_free = Module["_drmp3_free"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_read_pcm_frames_f32 = Module["_drmp3_read_pcm_frames_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_read_pcm_frames_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_reset = Module["_drmp3_reset"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_reset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_seek_to_start_of_stream = Module["_drmp3_seek_to_start_of_stream"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_seek_to_start_of_stream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_get_cached_pcm_frame_count_from_src = Module["_drmp3_get_cached_pcm_frame_count_from_src"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_get_cached_pcm_frame_count_from_src"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_get_pcm_frames_remaining_in_mp3_frame = Module["_drmp3_get_pcm_frames_remaining_in_mp3_frame"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_get_pcm_frames_remaining_in_mp3_frame"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_seek_forward_by_pcm_frames__brute_force = Module["_drmp3_seek_forward_by_pcm_frames__brute_force"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_seek_forward_by_pcm_frames__brute_force"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_seek_to_pcm_frame__brute_force = Module["_drmp3_seek_to_pcm_frame__brute_force"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_seek_to_pcm_frame__brute_force"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_find_closest_seek_point = Module["_drmp3_find_closest_seek_point"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_find_closest_seek_point"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_seek_to_pcm_frame__seek_table = Module["_drmp3_seek_to_pcm_frame__seek_table"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_seek_to_pcm_frame__seek_table"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _realloc = Module["_realloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["realloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memmove = Module["_memmove"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memmove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_seek_to_pcm_frame = Module["_drmp3_seek_to_pcm_frame"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_seek_to_pcm_frame"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_get_mp3_and_pcm_frame_count = Module["_drmp3_get_mp3_and_pcm_frame_count"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_get_mp3_and_pcm_frame_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_get_pcm_frame_count = Module["_drmp3_get_pcm_frame_count"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_get_pcm_frame_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_get_mp3_frame_count = Module["_drmp3_get_mp3_frame_count"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_get_mp3_frame_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3__accumulate_running_pcm_frame_count = Module["_drmp3__accumulate_running_pcm_frame_count"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3__accumulate_running_pcm_frame_count"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_calculate_seek_points = Module["_drmp3_calculate_seek_points"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_calculate_seek_points"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_bind_seek_table = Module["_drmp3_bind_seek_table"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_bind_seek_table"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3__full_read_and_close_f32 = Module["_drmp3__full_read_and_close_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3__full_read_and_close_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_open_and_read_f32 = Module["_drmp3_open_and_read_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_open_and_read_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_open_memory_and_read_f32 = Module["_drmp3_open_memory_and_read_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_open_memory_and_read_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drmp3_open_file_and_read_f32 = Module["_drmp3_open_file_and_read_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drmp3_open_file_and_read_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_fopen = Module["_drwav_fopen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_fopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_file = Module["_drwav_init_file"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_ex = Module["_drwav_init_ex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_file_ex = Module["_drwav_init_file_ex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_file_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_file_write__internal = Module["_drwav_init_file_write__internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_file_write__internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_write__internal = Module["_drwav_init_write__internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_write__internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwrite = Module["_fwrite"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_file_write = Module["_drwav_init_file_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_file_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_file_write_sequential = Module["_drwav_init_file_write_sequential"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_file_write_sequential"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file = Module["_drwav_open_file"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_ex = Module["_drwav_open_file_ex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_ex = Module["_drwav_open_ex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_write__internal = Module["_drwav_open_file_write__internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_write__internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_write__internal = Module["_drwav_open_write__internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_write__internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_write = Module["_drwav_open_file_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_write_sequential = Module["_drwav_open_file_write_sequential"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_write_sequential"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_memory = Module["_drwav_init_memory"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_memory"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_memory_ex = Module["_drwav_init_memory_ex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_memory_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_memory_write__internal = Module["_drwav_init_memory_write__internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_memory_write__internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_memory_write = Module["_drwav_init_memory_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_memory_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_memory_write_sequential = Module["_drwav_init_memory_write_sequential"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_memory_write_sequential"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory = Module["_drwav_open_memory"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_ex = Module["_drwav_open_memory_ex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_ex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_write__internal = Module["_drwav_open_memory_write__internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_write__internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_write = Module["_drwav_open_memory_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_write_sequential = Module["_drwav_open_memory_write_sequential"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_write_sequential"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav__on_read = Module["_drwav__on_read"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav__on_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav__on_seek = Module["_drwav__on_seek"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav__on_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init = Module["_drwav_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_riff_chunk_size_riff = Module["_drwav_riff_chunk_size_riff"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_riff_chunk_size_riff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_data_chunk_size_riff = Module["_drwav_data_chunk_size_riff"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_data_chunk_size_riff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_riff_chunk_size_w64 = Module["_drwav_riff_chunk_size_w64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_riff_chunk_size_w64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_data_chunk_size_w64 = Module["_drwav_data_chunk_size_w64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_data_chunk_size_w64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_write = Module["_drwav_init_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_init_write_sequential = Module["_drwav_init_write_sequential"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_init_write_sequential"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_uninit = Module["_drwav_uninit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_uninit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open = Module["_drwav_open"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_write = Module["_drwav_open_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_write_sequential = Module["_drwav_open_write_sequential"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_write_sequential"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_close = Module["_drwav_close"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_raw = Module["_drwav_read_raw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_raw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read = Module["_drwav_read"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_pcm_frames = Module["_drwav_read_pcm_frames"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_pcm_frames"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_seek_to_first_pcm_frame = Module["_drwav_seek_to_first_pcm_frame"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_seek_to_first_pcm_frame"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_seek_to_sample = Module["_drwav_seek_to_sample"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_seek_to_sample"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s16__msadpcm = Module["_drwav_read_s16__msadpcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s16__msadpcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s16__ima = Module["_drwav_read_s16__ima"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s16__ima"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_seek_to_pcm_frame = Module["_drwav_seek_to_pcm_frame"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_seek_to_pcm_frame"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_write_raw = Module["_drwav_write_raw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_write_raw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_write = Module["_drwav_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_write_pcm_frames = Module["_drwav_write_pcm_frames"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_write_pcm_frames"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s16__pcm = Module["_drwav_read_s16__pcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s16__pcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s16__ieee = Module["_drwav_read_s16__ieee"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s16__ieee"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s16__alaw = Module["_drwav_read_s16__alaw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s16__alaw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_alaw_to_s16 = Module["_drwav_alaw_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_alaw_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s16__mulaw = Module["_drwav_read_s16__mulaw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s16__mulaw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_mulaw_to_s16 = Module["_drwav_mulaw_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_mulaw_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s16 = Module["_drwav_read_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_pcm_frames_s16 = Module["_drwav_read_pcm_frames_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_pcm_frames_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_u8_to_s16 = Module["_drwav_u8_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_u8_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_s24_to_s16 = Module["_drwav_s24_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_s24_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_s32_to_s16 = Module["_drwav_s32_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_s32_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_f32_to_s16 = Module["_drwav_f32_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_f32_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_f64_to_s16 = Module["_drwav_f64_to_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_f64_to_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_f32__pcm = Module["_drwav_read_f32__pcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_f32__pcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_f32__msadpcm = Module["_drwav_read_f32__msadpcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_f32__msadpcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_s16_to_f32 = Module["_drwav_s16_to_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_s16_to_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_f32__ima = Module["_drwav_read_f32__ima"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_f32__ima"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_f32__ieee = Module["_drwav_read_f32__ieee"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_f32__ieee"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_f32__alaw = Module["_drwav_read_f32__alaw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_f32__alaw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_alaw_to_f32 = Module["_drwav_alaw_to_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_alaw_to_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_f32__mulaw = Module["_drwav_read_f32__mulaw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_f32__mulaw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_mulaw_to_f32 = Module["_drwav_mulaw_to_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_mulaw_to_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_f32 = Module["_drwav_read_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_pcm_frames_f32 = Module["_drwav_read_pcm_frames_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_pcm_frames_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_u8_to_f32 = Module["_drwav_u8_to_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_u8_to_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_s24_to_f32 = Module["_drwav_s24_to_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_s24_to_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_s32_to_f32 = Module["_drwav_s32_to_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_s32_to_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_f64_to_f32 = Module["_drwav_f64_to_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_f64_to_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s32__pcm = Module["_drwav_read_s32__pcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s32__pcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s32__msadpcm = Module["_drwav_read_s32__msadpcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s32__msadpcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_s16_to_s32 = Module["_drwav_s16_to_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_s16_to_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s32__ima = Module["_drwav_read_s32__ima"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s32__ima"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s32__ieee = Module["_drwav_read_s32__ieee"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s32__ieee"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s32__alaw = Module["_drwav_read_s32__alaw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s32__alaw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_alaw_to_s32 = Module["_drwav_alaw_to_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_alaw_to_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s32__mulaw = Module["_drwav_read_s32__mulaw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s32__mulaw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_mulaw_to_s32 = Module["_drwav_mulaw_to_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_mulaw_to_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_s32 = Module["_drwav_read_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_read_pcm_frames_s32 = Module["_drwav_read_pcm_frames_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_read_pcm_frames_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_u8_to_s32 = Module["_drwav_u8_to_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_u8_to_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_s24_to_s32 = Module["_drwav_s24_to_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_s24_to_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_f32_to_s32 = Module["_drwav_f32_to_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_f32_to_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_f64_to_s32 = Module["_drwav_f64_to_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_f64_to_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav__read_and_close_s16 = Module["_drwav__read_and_close_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav__read_and_close_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav__read_and_close_f32 = Module["_drwav__read_and_close_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav__read_and_close_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav__read_and_close_s32 = Module["_drwav__read_and_close_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav__read_and_close_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_and_read_s16 = Module["_drwav_open_and_read_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_and_read_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_and_read_pcm_frames_s16 = Module["_drwav_open_and_read_pcm_frames_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_and_read_pcm_frames_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_and_read_f32 = Module["_drwav_open_and_read_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_and_read_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_and_read_pcm_frames_f32 = Module["_drwav_open_and_read_pcm_frames_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_and_read_pcm_frames_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_and_read_s32 = Module["_drwav_open_and_read_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_and_read_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_and_read_pcm_frames_s32 = Module["_drwav_open_and_read_pcm_frames_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_and_read_pcm_frames_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_and_read_s16 = Module["_drwav_open_file_and_read_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_and_read_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_and_read_pcm_frames_s16 = Module["_drwav_open_file_and_read_pcm_frames_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_and_read_pcm_frames_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_and_read_f32 = Module["_drwav_open_file_and_read_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_and_read_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_and_read_pcm_frames_f32 = Module["_drwav_open_file_and_read_pcm_frames_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_and_read_pcm_frames_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_and_read_s32 = Module["_drwav_open_file_and_read_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_and_read_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_file_and_read_pcm_frames_s32 = Module["_drwav_open_file_and_read_pcm_frames_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_file_and_read_pcm_frames_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_and_read_s16 = Module["_drwav_open_memory_and_read_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_and_read_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_and_read_pcm_frames_s16 = Module["_drwav_open_memory_and_read_pcm_frames_s16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_and_read_pcm_frames_s16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_and_read_f32 = Module["_drwav_open_memory_and_read_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_and_read_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_and_read_pcm_frames_f32 = Module["_drwav_open_memory_and_read_pcm_frames_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_and_read_pcm_frames_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_and_read_s32 = Module["_drwav_open_memory_and_read_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_and_read_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_open_memory_and_read_pcm_frames_s32 = Module["_drwav_open_memory_and_read_pcm_frames_s32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_open_memory_and_read_pcm_frames_s32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drwav_free = Module["_drwav_free"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drwav_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _Resample_f32 = Module["_Resample_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["Resample_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _denoise_proc = Module["_denoise_proc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["denoise_proc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rnnoise_create = Module["_rnnoise_create"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rnnoise_create"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rnnoise_process_frame = Module["_rnnoise_process_frame"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rnnoise_process_frame"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rnnoise_destroy = Module["_rnnoise_destroy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rnnoise_destroy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___original_main = Module["___original_main"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__original_main"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _main = Module["_main"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["main"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stbSinCos = Module["_stbSinCos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stbSinCos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sin = Module["_sin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cos = Module["_cos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_make_twiddles = Module["_stb_make_twiddles"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_make_twiddles"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_make_twiddles_sequential = Module["_stb_make_twiddles_sequential"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_make_twiddles_sequential"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_calculate_stages = Module["_stb_calculate_stages"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_calculate_stages"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_make_fft_plan = Module["_stb_make_fft_plan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_make_fft_plan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_fft_plan_dft_1d = Module["_stb_fft_plan_dft_1d"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_fft_plan_dft_1d"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _calloc = Module["_calloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["calloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_fft_real_plan_dft_1d = Module["_stb_fft_real_plan_dft_1d"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_fft_real_plan_dft_1d"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_general_dit = Module["_stb_general_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_general_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_2_dit = Module["_stb_radix_2_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_2_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_3_dit = Module["_stb_radix_3_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_3_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_4_dit = Module["_stb_radix_4_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_4_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_5_dit = Module["_stb_radix_5_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_5_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_6_dit = Module["_stb_radix_6_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_6_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_7_dit = Module["_stb_radix_7_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_7_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_8_dit = Module["_stb_radix_8_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_8_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_2_idit = Module["_stb_radix_2_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_2_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_3_idit = Module["_stb_radix_3_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_3_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_4_idit = Module["_stb_radix_4_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_4_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_5_idit = Module["_stb_radix_5_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_5_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_6_idit = Module["_stb_radix_6_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_6_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_7_idit = Module["_stb_radix_7_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_7_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_radix_8_idit = Module["_stb_radix_8_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_radix_8_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_recursive_mixed_radix_dit = Module["_stb_recursive_mixed_radix_dit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_recursive_mixed_radix_dit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_recursive_mixed_radix_idit = Module["_stb_recursive_mixed_radix_idit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_recursive_mixed_radix_idit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_fft_exec = Module["_stb_fft_exec"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_fft_exec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_ifft_exec = Module["_stb_ifft_exec"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_ifft_exec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_fft_r2c_exec = Module["_stb_fft_r2c_exec"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_fft_r2c_exec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stb_fft_c2r_exec = Module["_stb_fft_c2r_exec"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stb_fft_c2r_exec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _STB_FFT = Module["_STB_FFT"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["STB_FFT"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _STB_IFFT = Module["_STB_IFFT"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["STB_IFFT"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _STB_FFT_R2C = Module["_STB_FFT_R2C"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["STB_FFT_R2C"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _STB_IFFT_C2R = Module["_STB_IFFT_C2R"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["STB_IFFT_C2R"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compute_band_energy = Module["_compute_band_energy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compute_band_energy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compute_band_corr = Module["_compute_band_corr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compute_band_corr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _interp_band_gain = Module["_interp_band_gain"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["interp_band_gain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rnnoise_get_size = Module["_rnnoise_get_size"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rnnoise_get_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rnnoise_init = Module["_rnnoise_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rnnoise_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iprintf = Module["_iprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pitch_filter = Module["_pitch_filter"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pitch_filter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pitch_downsample = Module["_pitch_downsample"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pitch_downsample"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pitch_search = Module["_pitch_search"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pitch_search"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remove_doubling = Module["_remove_doubling"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remove_doubling"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log10f = Module["_log10f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log10f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compute_rnn = Module["_compute_rnn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compute_rnn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __celt_lpc = Module["__celt_lpc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_celt_lpc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _celt_fir = Module["_celt_fir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["celt_fir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _celt_iir = Module["_celt_iir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["celt_iir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __celt_autocorr = Module["__celt_autocorr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_celt_autocorr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _celt_pitch_xcorr = Module["_celt_pitch_xcorr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["celt_pitch_xcorr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fastabs = Module["_fastabs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fastabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compute_dense = Module["_compute_dense"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compute_dense"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _compute_gru = Module["_compute_gru"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["compute_gru"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fesetround = Module["_fesetround"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fesetround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fesetround = Module["___fesetround"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fesetround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fesetexceptflag = Module["_fesetexceptflag"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fesetexceptflag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feclearexcept = Module["_feclearexcept"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feclearexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feraiseexcept = Module["_feraiseexcept"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feraiseexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fegetexceptflag = Module["_fegetexceptflag"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fegetexceptflag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fetestexcept = Module["_fetestexcept"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fetestexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feholdexcept = Module["_feholdexcept"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feholdexcept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fegetenv = Module["_fegetenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fegetenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feupdateenv = Module["_feupdateenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feupdateenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fesetenv = Module["_fesetenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fesetenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___flt_rounds = Module["___flt_rounds"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__flt_rounds"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fegetround = Module["_fegetround"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fegetround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfgetospeed = Module["_cfgetospeed"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfgetospeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfgetispeed = Module["_cfgetispeed"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfgetispeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcsendbreak = Module["_tcsendbreak"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcsendbreak"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ioctl = Module["_ioctl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ioctl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcdrain = Module["_tcdrain"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcdrain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___syscall_ret = Module["___syscall_ret"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__syscall_ret"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcflush = Module["_tcflush"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcflush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcgetsid = Module["_tcgetsid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcgetsid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfmakeraw = Module["_cfmakeraw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfmakeraw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcflow = Module["_tcflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcgetattr = Module["_tcgetattr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcgetattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcsetattr = Module["_tcsetattr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcsetattr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__errno_location"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfsetospeed = Module["_cfsetospeed"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfsetospeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfsetispeed = Module["_cfsetispeed"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfsetispeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cfsetspeed = Module["_cfsetspeed"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cfsetspeed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openat = Module["_openat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openat64 = Module["_openat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creat = Module["_creat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open = Module["_open"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creat64 = Module["_creat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fadvise = Module["_posix_fadvise"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fadvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fadvise64 = Module["_posix_fadvise64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fadvise64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fcntl = Module["_fcntl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fcntl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fallocate = Module["_posix_fallocate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fallocate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_fallocate64 = Module["_posix_fallocate64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_fallocate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open64 = Module["_open64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towupper = Module["_towupper"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalpha = Module["_iswalpha"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalpha"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towlower = Module["_towlower"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towlower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towupper_l = Module["___towupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towlower_l = Module["___towlower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towupper_l = Module["_towupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towlower_l = Module["_towlower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isgraph = Module["_isgraph"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isgraph"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isgraph_l = Module["___isgraph_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isgraph_l = Module["_isgraph_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswctype = Module["_iswctype"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswctype"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalnum = Module["_iswalnum"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalnum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswblank = Module["_iswblank"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswblank"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswcntrl = Module["_iswcntrl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswcntrl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswdigit = Module["_iswdigit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswgraph = Module["_iswgraph"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswgraph"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswlower = Module["_iswlower"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswlower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswprint = Module["_iswprint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswpunct = Module["_iswpunct"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswpunct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswspace = Module["_iswspace"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswspace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswupper = Module["_iswupper"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswxdigit = Module["_iswxdigit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswxdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctype = Module["_wctype"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctype"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcmp = Module["_strcmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswctype_l = Module["___iswctype_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wctype_l = Module["___wctype_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswctype_l = Module["_iswctype_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctype_l = Module["_wctype_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctype_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_b_loc = Module["___ctype_b_loc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_b_loc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalpha = Module["_isalpha"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalpha"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isalpha_l = Module["___isalpha_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalpha_l = Module["_isalpha_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswdigit_l = Module["___iswdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswdigit_l = Module["_iswdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_get_mb_cur_max = Module["___ctype_get_mb_cur_max"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_get_mb_cur_max"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_self = Module["_pthread_self"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_self"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswalnum_l = Module["___iswalnum_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalnum_l = Module["_iswalnum_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswalpha_l = Module["___iswalpha_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswalpha_l = Module["_iswalpha_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswalpha_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isspace = Module["_isspace"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isspace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isspace_l = Module["___isspace_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isspace_l = Module["_isspace_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _islower = Module["_islower"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["islower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___islower_l = Module["___islower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__islower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _islower_l = Module["_islower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["islower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iscntrl = Module["_iscntrl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iscntrl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iscntrl_l = Module["___iscntrl_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iscntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iscntrl_l = Module["_iscntrl_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iscntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isxdigit = Module["_isxdigit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isxdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isdigit = Module["_isdigit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isdigit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isxdigit_l = Module["___isxdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isxdigit_l = Module["_isxdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_toupper_loc = Module["___ctype_toupper_loc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_toupper_loc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswprint_l = Module["___iswprint_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswprint_l = Module["_iswprint_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isprint = Module["_isprint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isprint_l = Module["___isprint_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isprint_l = Module["_isprint_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isprint_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswlower_l = Module["___iswlower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswlower_l = Module["_iswlower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswlower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tolower = Module["_tolower"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tolower"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isupper = Module["_isupper"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tolower_l = Module["___tolower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tolower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tolower_l = Module["_tolower_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tolower_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctrans = Module["_wctrans"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctrans"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towctrans = Module["_towctrans"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towctrans"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wctrans_l = Module["___wctrans_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towctrans_l = Module["___towctrans_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctrans_l = Module["_wctrans_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _towctrans_l = Module["_towctrans_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["towctrans_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isblank = Module["_isblank"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isblank"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswblank_l = Module["___iswblank_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswblank_l = Module["_iswblank_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcswidth = Module["_wcswidth"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcswidth"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcwidth = Module["_wcwidth"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcwidth"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isupper_l = Module["___isupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isupper_l = Module["_isupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _toupper = Module["_toupper"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["toupper"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___toupper_l = Module["___toupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__toupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _toupper_l = Module["_toupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["toupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isblank_l = Module["___isblank_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isblank_l = Module["_isblank_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isblank_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _toascii = Module["_toascii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["toascii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isdigit_l = Module["___isdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isdigit_l = Module["_isdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswxdigit_l = Module["___iswxdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswxdigit_l = Module["_iswxdigit_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswxdigit_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswpunct_l = Module["___iswpunct_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswpunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswpunct_l = Module["_iswpunct_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswpunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isascii = Module["_isascii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isascii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswcntrl_l = Module["___iswcntrl_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswcntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswcntrl_l = Module["_iswcntrl_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswcntrl_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswgraph_l = Module["___iswgraph_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswgraph_l = Module["_iswgraph_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswgraph_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswupper_l = Module["___iswupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswupper_l = Module["_iswupper_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswupper_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalnum = Module["_isalnum"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalnum"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isalnum_l = Module["___isalnum_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isalnum_l = Module["_isalnum_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isalnum_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcschr = Module["_wcschr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcschr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___iswspace_l = Module["___iswspace_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__iswspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iswspace_l = Module["_iswspace_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iswspace_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ispunct = Module["_ispunct"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ispunct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ispunct_l = Module["___ispunct_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ispunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ispunct_l = Module["_ispunct_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ispunct_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ctype_tolower_loc = Module["___ctype_tolower_loc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ctype_tolower_loc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _umask = Module["_umask"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["umask"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatat = Module["_fstatat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatat64 = Module["_fstatat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkdir = Module["_mkdir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lchmod = Module["_lchmod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lchmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchmodat = Module["_fchmodat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchmodat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___futimesat = Module["___futimesat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__futimesat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _utimensat = Module["_utimensat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["utimensat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _futimesat = Module["_futimesat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["futimesat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _futimens = Module["_futimens"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["futimens"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkfifo = Module["_mkfifo"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkfifo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mknod = Module["_mknod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mknod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _chmod = Module["_chmod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["chmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lstat = Module["_lstat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lstat64 = Module["_lstat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstat = Module["___fxstat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstat = Module["_fstat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstatat = Module["___fxstatat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstatat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lxstat = Module["___lxstat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lxstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xstat = Module["___xstat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xstat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stat = Module["_stat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xmknod = Module["___xmknod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xmknod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xmknodat = Module["___xmknodat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xmknodat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mknodat = Module["_mknodat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mknodat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstat64 = Module["___fxstat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fxstatat64 = Module["___fxstatat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fxstatat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lxstat64 = Module["___lxstat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lxstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xstat64 = Module["___xstat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkfifoat = Module["_mkfifoat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkfifoat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___procfdname = Module["___procfdname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__procfdname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkdirat = Module["_mkdirat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkdirat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchmod = Module["_fchmod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wasi_fd_is_valid = Module["___wasi_fd_is_valid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasi_fd_is_valid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstat64 = Module["_fstat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stat64 = Module["_stat64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stat64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___statfs = Module["___statfs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__statfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fstatfs = Module["___fstatfs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fstatfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statvfs = Module["_statvfs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statvfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatvfs = Module["_fstatvfs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatvfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statfs = Module["_statfs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatfs = Module["_fstatfs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatfs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statvfs64 = Module["_statvfs64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statvfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _statfs64 = Module["_statfs64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["statfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatvfs64 = Module["_fstatvfs64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatvfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fstatfs64 = Module["_fstatfs64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fstatfs64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mktemp = Module["_mktemp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mktemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlen = Module["_strlen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memcmp = Module["_memcmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___randname = Module["___randname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__randname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemp = Module["_mkostemp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mkostemps = Module["___mkostemps"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mkostemps"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemp64 = Module["_mkostemp64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemp64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkdtemp = Module["_mkdtemp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkdtemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemps = Module["_mkostemps"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemps"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkostemps64 = Module["_mkostemps64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkostemps64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemp = Module["_mkstemp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemp64 = Module["_mkstemp64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemp64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemps = Module["_mkstemps"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemps"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mkstemps64 = Module["_mkstemps64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mkstemps64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlwr = Module["_strlwr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlwr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _aligned_alloc = Module["_aligned_alloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["aligned_alloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_memalign = Module["_posix_memalign"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_memalign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___synccall = Module["___synccall"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__synccall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoull_l = Module["_strtoull_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoull_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoull = Module["_strtoull"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoll_l = Module["_strtoll_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoll = Module["_strtoll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoul_l = Module["_strtoul_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoul_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoul = Module["_strtoul"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtol_l = Module["_strtol_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtol_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtol = Module["_strtol"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strupr = Module["_strupr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strupr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___libc_get_version = Module["___libc_get_version"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__libc_get_version"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___intscan = Module["___intscan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__intscan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___shgetc = Module["___shgetc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__shgetc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___shlim = Module["___shlim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__shlim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___multi3 = Module["___multi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__multi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatscan = Module["___floatscan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatscan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___extendsftf2 = Module["___extendsftf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__extendsftf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatsitf = Module["___floatsitf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatsitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___multf3 = Module["___multf3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__multf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___addtf3 = Module["___addtf3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__addtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___extenddftf2 = Module["___extenddftf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__extenddftf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getf2 = Module["___getf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbn = Module["_scalbn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copysignl = Module["_copysignl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copysignl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___netf2 = Module["___netf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__netf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatunsitf = Module["___floatunsitf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatunsitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___subtf3 = Module["___subtf3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__subtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbnl = Module["_scalbnl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbnl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divtf3 = Module["___divtf3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divtf3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmodl = Module["_fmodl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmodl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___trunctfdf2 = Module["___trunctfdf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__trunctfdf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fabs = Module["_fabs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___uflow = Module["___uflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__uflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _select = Module["_select"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["select"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pselect = Module["_pselect"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pselect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _poll = Module["_poll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["poll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tre_mem_new_impl = Module["___tre_mem_new_impl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tre_mem_new_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tre_mem_destroy = Module["___tre_mem_destroy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tre_mem_destroy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tre_mem_alloc_impl = Module["___tre_mem_alloc_impl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tre_mem_alloc_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regcomp = Module["_regcomp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regcomp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regfree = Module["_regfree"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regfree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbtowc = Module["_mbtowc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbtowc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _qsort = Module["_qsort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["qsort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _glob = Module["_glob"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["glob"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strchr = Module["_strchr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcpy = Module["_strcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _opendir = Module["_opendir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["opendir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir_r = Module["_readdir_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fnmatch = Module["_fnmatch"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fnmatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _closedir = Module["_closedir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["closedir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcat = Module["_strcat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _globfree = Module["_globfree"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["globfree"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _glob64 = Module["_glob64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["glob64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _globfree64 = Module["_globfree64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["globfree64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regexec = Module["_regexec"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regexec"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncmp = Module["_strncmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _regerror = Module["_regerror"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["regerror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lctrans_cur = Module["___lctrans_cur"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lctrans_cur"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _snprintf = Module["_snprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["snprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strnlen = Module["_strnlen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strnlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getdents = Module["___getdents"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getdents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdents = Module["_getdents"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdents"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdents64 = Module["_getdents64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdents64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdopendir = Module["_fdopendir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdopendir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _alphasort = Module["_alphasort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["alphasort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcoll = Module["_strcoll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _alphasort64 = Module["_alphasort64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["alphasort64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lock = Module["___lock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir = Module["_readdir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unlock = Module["___unlock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir64_r = Module["_readdir64_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir64_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scandir = Module["_scandir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scandir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scandir64 = Module["_scandir64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scandir64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _versionsort = Module["_versionsort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["versionsort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strverscmp = Module["_strverscmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strverscmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _versionsort64 = Module["_versionsort64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["versionsort64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readdir64 = Module["_readdir64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readdir64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dirfd = Module["_dirfd"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dirfd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rewinddir = Module["_rewinddir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rewinddir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lseek = Module["_lseek"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lseek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _close = Module["_close"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _telldir = Module["_telldir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["telldir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _seekdir = Module["_seekdir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["seekdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _login_tty = Module["_login_tty"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["login_tty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setsid = Module["_setsid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setsid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dup2 = Module["_dup2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dup2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffs = Module["_ffs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdomainname = Module["_getdomainname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdomainname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uname = Module["_uname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setlogmask = Module["_setlogmask"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setlogmask"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _closelog = Module["_closelog"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["closelog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openlog = Module["_openlog"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openlog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___vsyslog = Module["___vsyslog"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__vsyslog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpid = Module["_getpid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsnprintf = Module["_vsnprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsnprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _send = Module["_send"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["send"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _connect = Module["_connect"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["connect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dprintf = Module["_dprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _syslog = Module["_syslog"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["syslog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _socket = Module["_socket"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["socket"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsyslog = Module["_vsyslog"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsyslog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getresgid = Module["_getresgid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getresgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffsll = Module["_ffsll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffsll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setpriority = Module["_setpriority"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setpriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getopt_long = Module["_getopt_long"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getopt_long"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getopt_long_only = Module["_getopt_long_only"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getopt_long_only"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getopt_msg = Module["___getopt_msg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getopt_msg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getopt = Module["_getopt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lockf = Module["_lockf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lockf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lockf64 = Module["_lockf64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lockf64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getresuid = Module["_getresuid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getresuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _basename = Module["_basename"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["basename"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xpg_basename = Module["___xpg_basename"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xpg_basename"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getrlimit = Module["_getrlimit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getrlimit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getrlimit64 = Module["_getrlimit64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getrlimit64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setmntent = Module["_setmntent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endmntent = Module["_endmntent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getmntent_r = Module["_getmntent_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getmntent_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgets = Module["_fgets"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgets"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feof = Module["_feof"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ferror = Module["_ferror"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ferror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fscanf = Module["_fscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sscanf = Module["_sscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getmntent = Module["_getmntent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _addmntent = Module["_addmntent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["addmntent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fprintf = Module["_fprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hasmntopt = Module["_hasmntopt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hasmntopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strstr = Module["_strstr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dirname = Module["_dirname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dirname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpriority = Module["_getpriority"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpriority"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nftw = Module["_nftw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nftw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _access = Module["_access"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["access"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strrchr = Module["_strrchr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nftw64 = Module["_nftw64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nftw64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmtmsg = Module["_fmtmsg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmtmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getenv = Module["_getenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _forkpty = Module["_forkpty"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["forkpty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _openpty = Module["_openpty"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["openpty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pipe2 = Module["_pipe2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pipe2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _read = Module["_read"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _write = Module["_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _flockfile = Module["_flockfile"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["flockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputs = Module["_fputs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putc = Module["_putc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _funlockfile = Module["_funlockfile"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["funlockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___posix_getopt = Module["___posix_getopt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__posix_getopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getauxval = Module["_getauxval"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getauxval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_openpt = Module["_posix_openpt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_openpt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _grantpt = Module["_grantpt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["grantpt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unlockpt = Module["_unlockpt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unlockpt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ptsname_r = Module["___ptsname_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ptsname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ptsname_r = Module["_ptsname_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ptsname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gethostid = Module["_gethostid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gethostid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___emscripten_pthread_data_constructor = Module["___emscripten_pthread_data_constructor"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__emscripten_pthread_data_constructor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _realpath = Module["_realpath"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["realpath"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readlink = Module["_readlink"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strdup = Module["_strdup"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getsubopt = Module["_getsubopt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getsubopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ffsl = Module["_ffsl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ffsl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___setrlimit = Module["___setrlimit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__setrlimit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setrlimit = Module["_setrlimit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setrlimit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setrlimit64 = Module["_setrlimit64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setrlimit64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _get_current_dir_name = Module["_get_current_dir_name"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["get_current_dir_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getcwd = Module["_getcwd"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getcwd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _issetugid = Module["_issetugid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["issetugid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ptsname = Module["_ptsname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ptsname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getrusage = Module["_getrusage"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getrusage"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setdomainname = Module["_setdomainname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setdomainname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _a64l = Module["_a64l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["a64l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _l64a = Module["_l64a"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["l64a"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sendmmsg = Module["_sendmmsg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sendmmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dn_comp = Module["___dn_comp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dn_comp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dn_comp = Module["_dn_comp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dn_comp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getnetbyaddr = Module["_getnetbyaddr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getnetbyaddr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getnetbyname = Module["_getnetbyname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getnetbyname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_send = Module["___res_send"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_send"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_msend = Module["___res_msend"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_msend"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res_send = Module["_res_send"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res_send"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___inet_aton = Module["___inet_aton"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__inet_aton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_aton = Module["_inet_aton"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_aton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyport_r = Module["_getservbyport_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyport_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___get_resolv_conf = Module["___get_resolv_conf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__get_resolv_conf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fopen_rb_ca = Module["___fopen_rb_ca"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fopen_rb_ca"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fclose_ca = Module["___fclose_ca"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fclose_ca"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getc = Module["_getc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lookup_ipliteral = Module["___lookup_ipliteral"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lookup_ipliteral"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_msend_rc = Module["___res_msend_rc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_msend_rc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _htons = Module["_htons"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["htons"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bind = Module["_bind"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bind"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setsockopt = Module["_setsockopt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setsockopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sendto = Module["_sendto"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sendto"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _recvfrom = Module["_recvfrom"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["recvfrom"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res_init = Module["_res_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sockatmark = Module["_sockatmark"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sockatmark"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hstrerror = Module["_hstrerror"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hstrerror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_pton = Module["_inet_pton"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_pton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _accept4 = Module["_accept4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["accept4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _accept = Module["_accept"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["accept"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_aton_r = Module["_ether_aton_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_aton_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_aton = Module["_ether_aton"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_aton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_ntoa_r = Module["_ether_ntoa_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_ntoa_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sprintf = Module["_sprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_ntoa = Module["_ether_ntoa"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_ntoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_line = Module["_ether_line"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_line"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_ntohost = Module["_ether_ntohost"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_ntohost"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ether_hostton = Module["_ether_hostton"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ether_hostton"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___h_errno_location = Module["___h_errno_location"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__h_errno_location"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_nametoindex = Module["_if_nametoindex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_nametoindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dn_skipname = Module["_dn_skipname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dn_skipname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyport = Module["_getservbyport"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyport"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_network = Module["_inet_network"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_network"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ntohl = Module["_ntohl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ntohl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_makeaddr = Module["_inet_makeaddr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_makeaddr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_lnaof = Module["_inet_lnaof"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_lnaof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_netof = Module["_inet_netof"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_netof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_mkquery = Module["___res_mkquery"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_mkquery"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _res_mkquery = Module["_res_mkquery"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["res_mkquery"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyname = Module["_getservbyname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservbyname_r = Module["_getservbyname_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservbyname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _recvmmsg = Module["_recvmmsg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["recvmmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endservent = Module["_endservent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endservent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setservent = Module["_setservent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setservent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getservent = Module["_getservent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getservent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _herror = Module["_herror"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["herror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sethostent = Module["_sethostent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sethostent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gethostent = Module["_gethostent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gethostent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endhostent = Module["_endhostent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endhostent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setnetent = Module["_setnetent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setnetent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getnetent = Module["_getnetent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getnetent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _endnetent = Module["_endnetent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["endnetent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___res_state = Module["___res_state"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__res_state"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_get16 = Module["_ns_get16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_get16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_get32 = Module["_ns_get32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_get32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_put16 = Module["_ns_put16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_put16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_put32 = Module["_ns_put32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_put32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_skiprr = Module["_ns_skiprr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_skiprr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_initparse = Module["_ns_initparse"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_initparse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_name_uncompress = Module["_ns_name_uncompress"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_name_uncompress"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dn_expand = Module["_dn_expand"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dn_expand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ns_parserr = Module["_ns_parserr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ns_parserr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ntohs = Module["_ntohs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ntohs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_nameindex = Module["_if_nameindex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_nameindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rtnetlink_enumerate = Module["___rtnetlink_enumerate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rtnetlink_enumerate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freeifaddrs = Module["_freeifaddrs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freeifaddrs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getifaddrs = Module["_getifaddrs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getifaddrs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_ntoa = Module["_inet_ntoa"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_ntoa"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_indextoname = Module["_if_indextoname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_indextoname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncpy = Module["_strncpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _if_freenameindex = Module["_if_freenameindex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["if_freenameindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dn_expand = Module["___dn_expand"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dn_expand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _recv = Module["_recv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["recv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lookup_serv = Module["___lookup_serv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lookup_serv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dns_parse = Module["___dns_parse"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dns_parse"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _htonl = Module["_htonl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["htonl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lookup_name = Module["___lookup_name"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lookup_name"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getsockname = Module["_getsockname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getsockname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbstowcs = Module["_mbstowcs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbstowcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _inet_ntop = Module["_inet_ntop"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["inet_ntop"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strspn = Module["_strspn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_sha256 = Module["___crypt_sha256"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_sha256"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _crypt = Module["_crypt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["crypt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_r = Module["___crypt_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_md5 = Module["___crypt_md5"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_md5"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_blowfish = Module["___crypt_blowfish"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_blowfish"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_sha512 = Module["___crypt_sha512"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_sha512"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___crypt_des = Module["___crypt_des"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__crypt_des"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _crypt_r = Module["_crypt_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["crypt_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setkey = Module["_setkey"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setkey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___des_setkey = Module["___des_setkey"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__des_setkey"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _encrypt = Module["_encrypt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["encrypt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___do_des = Module["___do_des"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__do_des"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcrtomb = Module["_wcrtomb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcrtomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsrtombs = Module["_wcsrtombs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsrtombs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbsrtowcs = Module["_mbsrtowcs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbsrtowcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbsinit = Module["_mbsinit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbsinit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctomb = Module["_wctomb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wctob = Module["_wctob"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wctob"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrtoc16 = Module["_mbrtoc16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrtoc16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrtowc = Module["_mbrtowc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrtowc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mblen = Module["_mblen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mblen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrlen = Module["_mbrlen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbsnrtowcs = Module["_mbsnrtowcs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbsnrtowcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mbrtoc32 = Module["_mbrtoc32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mbrtoc32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _btowc = Module["_btowc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["btowc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c16rtomb = Module["_c16rtomb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c16rtomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsnrtombs = Module["_wcsnrtombs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsnrtombs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstombs = Module["_wcstombs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstombs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _c32rtomb = Module["_c32rtomb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["c32rtomb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strerror_l = Module["___strerror_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strerror_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lctrans = Module["___lctrans"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lctrans"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strerror = Module["_strerror"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strerror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strerror_l = Module["_strerror_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strerror_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rmdir = Module["_rmdir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rmdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwrite = Module["_pwrite"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwrite64 = Module["_pwrite64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwrite64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setgid = Module["_setgid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___setxid = Module["___setxid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__setxid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _renameat = Module["_renameat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["renameat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _seteuid = Module["_seteuid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["seteuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getegid = Module["_getegid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getegid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setpgrp = Module["_setpgrp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setpgid = Module["_setpgid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setpgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwritev = Module["_pwritev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwritev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pwritev64 = Module["_pwritev64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pwritev64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _link = Module["_link"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["link"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchdir = Module["_fchdir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unlinkat = Module["_unlinkat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unlinkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readlinkat = Module["_readlinkat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readlinkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getppid = Module["_getppid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getppid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncate = Module["_truncate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncate64 = Module["_truncate64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setresuid = Module["_setresuid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setresuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sleep = Module["_sleep"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sleep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pread = Module["_pread"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pread64 = Module["_pread64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pread64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcsetpgrp = Module["_tcsetpgrp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcsetpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ualarm = Module["_ualarm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ualarm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tcgetpgrp = Module["_tcgetpgrp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tcgetpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gethostname = Module["_gethostname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gethostname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setegid = Module["_setegid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setegid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setuid = Module["_setuid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpgrp = Module["_getpgrp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpgrp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dup3 = Module["___dup3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dup3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dup3 = Module["_dup3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dup3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ttyname = Module["_ttyname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ttyname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ttyname_r = Module["_ttyname_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ttyname_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _writev = Module["_writev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["writev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _geteuid = Module["_geteuid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["geteuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _linkat = Module["_linkat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["linkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getlogin_r = Module["_getlogin_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getlogin_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getlogin = Module["_getlogin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getlogin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpgid = Module["_getpgid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _readv = Module["_readv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["readv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wasi_syscall_ret = Module["___wasi_syscall_ret"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasi_syscall_ret"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_close = Module["_posix_close"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dup = Module["_dup"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdatasync = Module["_fdatasync"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdatasync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getsid = Module["_getsid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getsid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pipe = Module["_pipe"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pipe"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _isatty = Module["_isatty"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["isatty"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setregid = Module["_setregid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setregid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _symlinkat = Module["_symlinkat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["symlinkat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setreuid = Module["_setreuid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setreuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getuid = Module["_getuid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getuid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lchown = Module["_lchown"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lchown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctermid = Module["_ctermid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctermid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getgroups = Module["_getgroups"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getgroups"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nice = Module["_nice"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nice"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setresgid = Module["_setresgid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setresgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _symlink = Module["_symlink"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["symlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___aio_close = Module["___aio_close"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__aio_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _preadv = Module["_preadv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["preadv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _preadv64 = Module["_preadv64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["preadv64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lseek64 = Module["_lseek64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lseek64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchown = Module["_fchown"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pause = Module["_pause"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pause"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unlink = Module["_unlink"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getgid = Module["_getgid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getgid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fsync = Module["_fsync"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fsync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acct = Module["_acct"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acct"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sync = Module["_sync"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _chown = Module["_chown"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["chown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _chdir = Module["_chdir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["chdir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftruncate = Module["_ftruncate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftruncate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftruncate64 = Module["_ftruncate64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftruncate64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fchownat = Module["_fchownat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fchownat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncasecmp = Module["_wcsncasecmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlcpy = Module["_strlcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsstr = Module["_wcsstr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsstr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemcmp = Module["_wmemcmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemchr = Module["_wmemchr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _index = Module["_index"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["index"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcswcs = Module["_wcswcs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcswcs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___memrchr = Module["___memrchr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__memrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memrchr = Module["_memrchr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtok = Module["_strtok"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtok"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcspn = Module["_strcspn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strchrnul = Module["___strchrnul"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strchrnul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strchrnul = Module["_strchrnul"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strchrnul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strpbrk = Module["_strpbrk"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strpbrk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsdup = Module["_wcsdup"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcslen = Module["_wcslen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcslen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemcpy = Module["_wmemcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memchr = Module["_memchr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncat = Module["_wcsncat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stpncpy = Module["___stpncpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stpncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stpncpy = Module["_stpncpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stpncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _swab = Module["_swab"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["swab"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memmem = Module["_memmem"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memmem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncpy = Module["_wcsncpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemset = Module["_wmemset"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstok = Module["_wcstok"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstok"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsspn = Module["_wcsspn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscspn = Module["_wcscspn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscspn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcpncpy = Module["_wcpncpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcpncpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsnlen = Module["_wcsnlen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsnlen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strlcat = Module["_strlcat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strlcat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bzero = Module["_bzero"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bzero"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcspbrk = Module["_wcspbrk"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcspbrk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncasecmp = Module["_strncasecmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strncasecmp_l = Module["___strncasecmp_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strncasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncasecmp_l = Module["_strncasecmp_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strndup = Module["_strndup"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strndup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcpcpy = Module["_wcpcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcpcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscpy = Module["_wcscpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscasecmp_l = Module["_wcscasecmp_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscasecmp = Module["_wcscasecmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtok_r = Module["_strtok_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtok_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bcmp = Module["_bcmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bcmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcasecmp = Module["_strcasecmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcasecmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strcasecmp_l = Module["___strcasecmp_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strcasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcasecmp_l = Module["_strcasecmp_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memccpy = Module["_memccpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memccpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncasecmp_l = Module["_wcsncasecmp_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncasecmp_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strncat = Module["_strncat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strncat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rindex = Module["_rindex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rindex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wmemmove = Module["_wmemmove"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wmemmove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strsep = Module["_strsep"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strsep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mempcpy = Module["_mempcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mempcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stpcpy = Module["___stpcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stpcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _stpcpy = Module["_stpcpy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stpcpy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsncmp = Module["_wcsncmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsncmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strerror_r = Module["_strerror_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strerror_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___xpg_strerror_r = Module["___xpg_strerror_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__xpg_strerror_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcasestr = Module["_strcasestr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcasestr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscat = Module["_wcscat"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscat"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bcopy = Module["_bcopy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bcopy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsrchr = Module["_wcsrchr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsrchr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscmp = Module["_wcscmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strsignal = Module["_strsignal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strsignal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strdup = Module["___strdup"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strdup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___shm_mapname = Module["___shm_mapname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__shm_mapname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _shm_open = Module["_shm_open"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["shm_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _shm_unlink = Module["_shm_unlink"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["shm_unlink"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mremap = Module["___mremap"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mremap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___vm_wait = Module["___vm_wait"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__vm_wait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mremap = Module["_mremap"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mremap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mincore = Module["_mincore"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mincore"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mprotect = Module["___mprotect"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mprotect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mprotect = Module["_mprotect"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mprotect"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _msync = Module["_msync"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["msync"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___munmap = Module["___munmap"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__munmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _munmap = Module["_munmap"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["munmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _munlock = Module["_munlock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["munlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mlockall = Module["_mlockall"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mlockall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _posix_madvise = Module["_posix_madvise"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["posix_madvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___madvise = Module["___madvise"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__madvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _madvise = Module["_madvise"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["madvise"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _munlockall = Module["_munlockall"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["munlockall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mlock = Module["_mlock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mmap = Module["___mmap"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mmap = Module["_mmap"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mmap"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mmap64 = Module["_mmap64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mmap64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccosf = Module["_ccosf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccoshf = Module["_ccoshf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccoshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ldexp_cexp = Module["___ldexp_cexp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ldexp_cexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp = Module["_exp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creall = Module["_creall"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creall"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clogl = Module["_clogl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clogl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cabsl = Module["_cabsl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cabsl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cargl = Module["_cargl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cargl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logl = Module["_logl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccoshl = Module["_ccoshl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccoshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccosh = Module["_ccosh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacosl = Module["_cacosl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinl = Module["_casinl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catan = Module["_catan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan2 = Module["_atan2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log = Module["_log"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _creal = Module["_creal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["creal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacosf = Module["_cacosf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinf = Module["_casinf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csqrtf = Module["_csqrtf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csqrtf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fabsf = Module["_fabsf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fabsf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copysignf = Module["_copysignf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copysignf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hypot = Module["_hypot"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hypot"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sqrt = Module["_sqrt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccos = Module["_ccos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cexpf = Module["_cexpf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expf = Module["_expf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cosf = Module["_cosf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinf = Module["_sinf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ldexp_cexpf = Module["___ldexp_cexpf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ldexp_cexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _coshf = Module["_coshf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["coshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinhf = Module["_sinhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacosh = Module["_cacosh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacos = Module["_cacos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanhf = Module["_ctanhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanf = Module["_tanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sqrtf = Module["_sqrtf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sqrtf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinhl = Module["_csinhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinh = Module["_csinh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cproj = Module["_cproj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cproj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _copysign = Module["_copysign"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["copysign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _conjf = Module["_conjf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["conjf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanl = Module["_catanl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___gttf2 = Module["___gttf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__gttf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___eqtf2 = Module["___eqtf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__eqtf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan2l = Module["_atan2l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixtfsi = Module["___fixtfsi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixtfsi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cargf = Module["_cargf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cargf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan2f = Module["_atan2f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinhl = Module["_casinhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanl = Module["_ctanl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanhl = Module["_ctanhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanhf = Module["_catanhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanf = Module["_catanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cpowf = Module["_cpowf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cpowf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clogf = Module["_clogf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clogf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mulsc3 = Module["___mulsc3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mulsc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csqrtl = Module["_csqrtl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csqrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csqrt = Module["_csqrt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csqrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___muldc3 = Module["___muldc3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__muldc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctan = Module["_ctan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanh = Module["_ctanh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinhf = Module["_casinhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinf = Module["_csinf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinhf = Module["_csinhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cexp = Module["_cexp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tan = Module["_tan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinh = Module["_sinh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cpowl = Module["_cpowl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cpowl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unordtf2 = Module["___unordtf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unordtf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___multc3 = Module["___multc3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__multc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cexpl = Module["_cexpl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _carg = Module["_carg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["carg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cabsf = Module["_cabsf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cabsf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hypotf = Module["_hypotf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hypotf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _hypotl = Module["_hypotl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["hypotl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _conjl = Module["_conjl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["conjl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logf = Module["_logf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanhl = Module["_catanhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cabs = Module["_cabs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cprojf = Module["_cprojf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cprojf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cprojl = Module["_cprojl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cprojl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpclassifyl = Module["___fpclassifyl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpclassifyl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catanh = Module["_catanh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ccosl = Module["_ccosl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ccosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casin = Module["_casin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ctanf = Module["_ctanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ctanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _casinh = Module["_casinh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["casinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cimag = Module["_cimag"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cimag"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacoshf = Module["_cacoshf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacoshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _conj = Module["_conj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["conj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cpow = Module["_cpow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cpow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clog = Module["_clog"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clog"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csin = Module["_csin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cimagl = Module["_cimagl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cimagl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cosh = Module["_cosh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cimagf = Module["_cimagf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cimagf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _csinl = Module["_csinl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["csinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cacoshl = Module["_cacoshl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cacoshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _crealf = Module["_crealf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["crealf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cbrtf = Module["_cbrtf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cbrtf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrint = Module["_lrint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rint = Module["_rint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbnf = Module["_scalbnf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbnf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log10l = Module["_log10l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log10 = Module["_log10"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log10"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___invtrigl_R = Module["___invtrigl_R"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__invtrigl_R"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalb = Module["_scalb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tgammaf = Module["_tgammaf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tgammaf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tgamma = Module["_tgamma"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tgamma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nan = Module["_nan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j1f = Module["_j1f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j1f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y1f = Module["_y1f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y1f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrintf = Module["_lrintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rintf = Module["_rintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdimf = Module["_fdimf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdimf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nearbyintl = Module["_nearbyintl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nearbyintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rintl = Module["_rintl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nextafterf = Module["_nextafterf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nextafterf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncl = Module["_truncl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2 = Module["___rem_pio2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2_large = Module["___rem_pio2_large"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2_large"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinh = Module["_asinh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log1p = Module["_log1p"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log1p"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j1 = Module["_j1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y1 = Module["_y1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ilogbl = Module["_ilogbl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ilogbl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llrintl = Module["_llrintl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llrintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixtfdi = Module["___fixtfdi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixtfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floor = Module["_floor"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfl = Module["_erfl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erf = Module["_erf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfcl = Module["_erfcl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfcl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfc = Module["_erfc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdim = Module["_fdim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _significandf = Module["_significandf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["significandf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ilogbf = Module["_ilogbf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ilogbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinhl = Module["_asinhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lgammal_r = Module["___lgammal_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lgammal_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lgamma_r = Module["___lgamma_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lgamma_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammal = Module["_lgammal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammal_r = Module["_lgammal_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammal_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log1pl = Module["_log1pl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log1pl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logbl = Module["_logbl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logbl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sin = Module["___sin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cos = Module["___cos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgamma_r = Module["_lgamma_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgamma_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llrintf = Module["_llrintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llrintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lgammaf_r = Module["___lgammaf_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lgammaf_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floorf = Module["_floorf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floorf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sindf = Module["___sindf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sindf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cosdf = Module["___cosdf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cosdf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammaf_r = Module["_lgammaf_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammaf_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nearbyintf = Module["_nearbyintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nearbyintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nextafter = Module["_nextafter"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nextafter"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cbrt = Module["_cbrt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cbrt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nanl = Module["_nanl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _significand = Module["_significand"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["significand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ilogb = Module["_ilogb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ilogb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _modfl = Module["_modfl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["modfl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _coshl = Module["_coshl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["coshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remquof = Module["_remquof"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remquof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _frexp = Module["_frexp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["frexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log1pf = Module["_log1pf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log1pf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpclassify = Module["___fpclassify"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpclassify"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrintl = Module["_lrintl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrintl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmal = Module["_fmal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _frexpl = Module["_frexpl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["frexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lttf2 = Module["___lttf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lttf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nextafterl = Module["_nextafterl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nextafterl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalblnl = Module["_scalblnl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalblnl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j0 = Module["_j0"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y0 = Module["_y0"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y0"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acoshf = Module["_acoshf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acoshf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expm1 = Module["_expm1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expm1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___expo2f = Module["___expo2f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__expo2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanh = Module["_tanh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remainderf = Module["_remainderf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remainderf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dremf = Module["_dremf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dremf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _finitef = Module["_finitef"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["finitef"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logb = Module["_logb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nanf = Module["_nanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expm1f = Module["_expm1f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expm1f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sinl = Module["___sinl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cosl = Module["___cosl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llroundl = Module["_llroundl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llroundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _roundl = Module["_roundl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["roundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___expo2 = Module["___expo2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__expo2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llround = Module["_llround"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remainder = Module["_remainder"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remainder"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remquo = Module["_remquo"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remquo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drem = Module["_drem"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drem"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _frexpf = Module["_frexpf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["frexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanh = Module["_atanh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanhf = Module["_tanhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbln = Module["_scalbln"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbln"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldexp = Module["_ldexp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldexp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmaf = Module["_fmaf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmaf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _logbf = Module["_logbf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["logbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldexpl = Module["_ldexpl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldexpl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remainderl = Module["_remainderl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remainderl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remquol = Module["_remquol"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remquol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpclassifyf = Module["___fpclassifyf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpclassifyf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erff = Module["_erff"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erfcf = Module["_erfcf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erfcf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ceilf = Module["_ceilf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ceilf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log2l = Module["_log2l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log2 = Module["_log2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nearbyint = Module["_nearbyint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nearbyint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp10l = Module["_exp10l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp2l = Module["_exp2l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _powl = Module["_powl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["powl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pow10l = Module["_pow10l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pow10l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___letf2 = Module["___letf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__letf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2f = Module["___rem_pio2f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalbf = Module["_scalbf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sincosl = Module["_sincosl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sincosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rem_pio2l = Module["___rem_pio2l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rem_pio2l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fma = Module["_fma"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tgammal = Module["_tgammal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tgammal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lroundf = Module["_lroundf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lroundf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llroundf = Module["_llroundf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llroundf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _jn = Module["_jn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _yn = Module["_yn"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["yn"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___polevll = Module["___polevll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__polevll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___p1evll = Module["___p1evll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__p1evll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nexttoward = Module["_nexttoward"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nexttoward"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___signbitl = Module["___signbitl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__signbitl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scalblnf = Module["_scalblnf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scalblnf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinhl = Module["_sinhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sincosf = Module["_sincosf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sincosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acoshl = Module["_acoshl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acoshl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acosh = Module["_acosh"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acosh"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tanl = Module["___tanl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fabsl = Module["_fabsl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fabsl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanhf = Module["_atanhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdiml = Module["_fdiml"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdiml"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sqrtl = Module["_sqrtl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sqrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nexttowardl = Module["_nexttowardl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nexttowardl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgamma = Module["_lgamma"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgamma"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanhl = Module["_atanhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinhf = Module["_asinhf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinhf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ceil = Module["_ceil"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ceil"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cbrtl = Module["_cbrtl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cbrtl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___trunctfsf2 = Module["___trunctfsf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__trunctfsf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _finite = Module["_finite"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["finite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lroundl = Module["_lroundl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lroundl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tan = Module["___tan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nexttowardf = Module["_nexttowardf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nexttowardf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expm1l = Module["_expm1l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expm1l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llrint = Module["_llrint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llrint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _j0f = Module["_j0f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["j0f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _y0f = Module["_y0f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["y0f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _jnf = Module["_jnf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jnf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ynf = Module["_ynf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ynf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lgammaf = Module["_lgammaf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lgammaf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sincos = Module["_sincos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sincos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _modf = Module["_modf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["modf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _truncf = Module["_truncf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["truncf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _modff = Module["_modff"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["modff"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___tandf = Module["___tandf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__tandf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lround = Module["_lround"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lround"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _trunc = Module["_trunc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["trunc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pow = Module["_pow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldexpf = Module["_ldexpf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldexpf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanhl = Module["_tanhl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanhl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _srand48 = Module["_srand48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["srand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _seed48 = Module["_seed48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["seed48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _jrand48 = Module["_jrand48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["jrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___rand48_step = Module["___rand48_step"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__rand48_step"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mrand48 = Module["_mrand48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _srandom = Module["_srandom"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["srandom"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _initstate = Module["_initstate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["initstate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setstate = Module["_setstate"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setstate"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _random = Module["_random"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["random"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _erand48 = Module["_erand48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["erand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _drand48 = Module["_drand48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["drand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lcong48 = Module["_lcong48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lcong48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rand_r = Module["_rand_r"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rand_r"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _srand = Module["_srand"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["srand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rand = Module["_rand"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rand"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nrand48 = Module["_nrand48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lrand48 = Module["_lrand48"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lrand48"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_exit = Module["___stdio_exit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_exit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ofl_lock = Module["___ofl_lock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ofl_lock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lockfile = Module["___lockfile"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_exit_needed = Module["___stdio_exit_needed"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_exit_needed"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tmpnam = Module["_tmpnam"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tmpnam"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fdopen = Module["___fdopen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fdopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_seek = Module["___stdio_seek"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_seek"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_write = Module["___stdio_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_read = Module["___stdio_read"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdio_close = Module["___stdio_close"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdio_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ofl_add = Module["___ofl_add"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ofl_add"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fdopen = Module["_fdopen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fdopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfscanf = Module["_vfscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unlockfile = Module["___unlockfile"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unlockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vfscanf = Module["___isoc99_vfscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vfscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___string_read = Module["___string_read"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__string_read"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vdprintf = Module["_vdprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vdprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfprintf = Module["_vfprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ftello_unlocked = Module["___ftello_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ftello_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ftello = Module["___ftello"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ftello"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftell = Module["_ftell"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftell"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftello = Module["_ftello"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftello"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftello64 = Module["_ftello64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftello64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getchar_unlocked = Module["_getchar_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___do_orphaned_stdio_locks = Module["___do_orphaned_stdio_locks"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__do_orphaned_stdio_locks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___unlist_locked_file = Module["___unlist_locked_file"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__unlist_locked_file"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ftrylockfile = Module["_ftrylockfile"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ftrylockfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open_wmemstream = Module["_open_wmemstream"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open_wmemstream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputc = Module["_fputc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___overflow = Module["___overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _remove = Module["_remove"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["remove"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ferror_unlocked = Module["_ferror_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ferror_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_ferror_unlocked = Module["__IO_ferror_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_ferror_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_fscanf = Module["___isoc99_fscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_fscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetln = Module["_fgetln"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetln"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ungetc = Module["_ungetc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ungetc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getline = Module["_getline"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getline"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___toread = Module["___toread"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__toread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vwscanf = Module["_vwscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfwscanf = Module["_vfwscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vwscanf = Module["___isoc99_vwscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fputwc_unlocked = Module["___fputwc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fputwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwide = Module["_fwide"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwide"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fwritex = Module["___fwritex"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fwritex"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputwc = Module["_fputwc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputwc_unlocked = Module["_fputwc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwc_unlocked = Module["_putwc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ofl_unlock = Module["___ofl_unlock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ofl_unlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fflush = Module["_fflush"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fflush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadahead = Module["___freadahead"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadahead"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadptr = Module["___freadptr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadptr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadptrinc = Module["___freadptrinc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadptrinc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fseterr = Module["___fseterr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fseterr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fflush_unlocked = Module["_fflush_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fflush_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetc = Module["_fgetc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fsetpos = Module["_fsetpos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fsetpos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fseeko = Module["___fseeko"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fseeko"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fsetpos64 = Module["_fsetpos64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fsetpos64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vprintf = Module["_vprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putw = Module["_putw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ungetwc = Module["_ungetwc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ungetwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setvbuf = Module["_setvbuf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setvbuf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwchar = Module["_getwchar"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetwc = Module["_fgetwc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwchar_unlocked = Module["_getwchar_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _open_memstream = Module["_open_memstream"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["open_memstream"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asprintf = Module["_asprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vasprintf = Module["_vasprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vasprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsprintf = Module["_vsprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsiprintf = Module["_vsiprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsiprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsniprintf = Module["_vsniprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsniprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_vsprintf = Module["___small_vsprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_vsprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_vsnprintf = Module["___small_vsnprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_vsnprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setbuffer = Module["_setbuffer"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setbuffer"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wprintf = Module["_wprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vwprintf = Module["_vwprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vwprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fseeko_unlocked = Module["___fseeko_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fseeko_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fseeko = Module["_fseeko"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fseeko"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fseeko64 = Module["_fseeko64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fseeko64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fmodeflags = Module["___fmodeflags"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fmodeflags"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fopen64 = Module["_fopen64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fopen64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wscanf = Module["_wscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_wscanf = Module["___isoc99_wscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_wscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _scanf = Module["_scanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["scanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vscanf = Module["_vscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_scanf = Module["___isoc99_scanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_scanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfiprintf = Module["_vfiprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfiprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_vfprintf = Module["___small_vfprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_vfprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fread_unlocked = Module["_fread_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fread_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putchar = Module["_putchar"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwscanf = Module["_fwscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_fwscanf = Module["___isoc99_fwscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_fwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getw = Module["_getw"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getw"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tmpfile = Module["_tmpfile"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tmpfile"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tmpfile64 = Module["_tmpfile64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tmpfile64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clearerr = Module["_clearerr"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clearerr"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clearerr_unlocked = Module["_clearerr_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clearerr_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _siprintf = Module["_siprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["siprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_sprintf = Module["___small_sprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_sprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gets = Module["_gets"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gets"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _swprintf = Module["_swprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["swprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vswprintf = Module["_vswprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vswprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwc = Module["_putwc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getdelim = Module["_getdelim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getdelim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getdelim = Module["___getdelim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getdelim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _swscanf = Module["_swscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["swscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vswscanf = Module["_vswscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vswscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_swscanf = Module["___isoc99_swscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_swscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___toread_needs_stdio_exit = Module["___toread_needs_stdio_exit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__toread_needs_stdio_exit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwc = Module["_getwc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vfwscanf = Module["___isoc99_vfwscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vfwscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rewind = Module["_rewind"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rewind"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgets_unlocked = Module["_fgets_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgets_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___vfprintf_internal = Module["___vfprintf_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__vfprintf_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getchar = Module["_getchar"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vscanf = Module["___isoc99_vscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fiprintf = Module["_fiprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fiprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_fprintf = Module["___small_fprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_fprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmemopen = Module["_fmemopen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmemopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freopen = Module["_freopen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freopen64 = Module["_freopen64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freopen64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tempnam = Module["_tempnam"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tempnam"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putchar_unlocked = Module["_putchar_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_getc = Module["__IO_getc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_getc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pclose = Module["_pclose"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pclose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwprintf = Module["_fwprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vfwprintf = Module["_vfwprintf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vfwprintf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setbuf = Module["_setbuf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setbuf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _vsscanf = Module["_vsscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["vsscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vsscanf = Module["___isoc99_vsscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vsscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_sscanf = Module["___isoc99_sscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_sscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_putc = Module["__IO_putc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_putc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __flushlbf = Module["__flushlbf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_flushlbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fsetlocking = Module["___fsetlocking"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fsetlocking"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fwriting = Module["___fwriting"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fwriting"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freading = Module["___freading"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freading"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freadable = Module["___freadable"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freadable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fwritable = Module["___fwritable"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fwritable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___flbf = Module["___flbf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__flbf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fbufsize = Module["___fbufsize"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fbufsize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpending = Module["___fpending"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpending"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fpurge = Module["___fpurge"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fpurge"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fpurge = Module["_fpurge"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fpurge"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputws = Module["_fputws"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputws"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputws_unlocked = Module["_fputws_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputws_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___stdout_write = Module["___stdout_write"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__stdout_write"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fgetwc_unlocked = Module["___fgetwc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fgetwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetwc_unlocked = Module["_fgetwc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getwc_unlocked = Module["_getwc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getwc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setlinebuf = Module["_setlinebuf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setlinebuf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fileno = Module["_fileno"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fileno"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fileno_unlocked = Module["_fileno_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fileno_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getc_unlocked = Module["_getc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetc_unlocked = Module["_fgetc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_getc_unlocked = Module["__IO_getc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_getc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetws = Module["_fgetws"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetws"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetws_unlocked = Module["_fgetws_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetws_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___isoc99_vswscanf = Module["___isoc99_vswscanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__isoc99_vswscanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetpos = Module["_fgetpos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetpos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fgetpos64 = Module["_fgetpos64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fgetpos64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _rename = Module["_rename"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["rename"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _feof_unlocked = Module["_feof_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["feof_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_feof_unlocked = Module["__IO_feof_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_feof_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putc_unlocked = Module["_putc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputc_unlocked = Module["_fputc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __IO_putc_unlocked = Module["__IO_putc_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_IO_putc_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _perror = Module["_perror"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["perror"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwchar = Module["_putwchar"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwchar"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putwchar_unlocked = Module["_putwchar_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putwchar_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ecvt = Module["_ecvt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ecvt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atoi = Module["_atoi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atoi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atof = Module["_atof"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtod = Module["_strtod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstof = Module["_wcstof"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstod = Module["_wcstod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstold = Module["_wcstold"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstold"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoimax = Module["_strtoimax"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoimax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtoumax = Module["_strtoumax"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtoumax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtol_internal = Module["___strtol_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtol_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoul_internal = Module["___strtoul_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoul_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoll_internal = Module["___strtoll_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoll_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoull_internal = Module["___strtoull_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoull_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoimax_internal = Module["___strtoimax_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoimax_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strtoumax_internal = Module["___strtoumax_internal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strtoumax_internal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _labs = Module["_labs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["labs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atoll = Module["_atoll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoull = Module["_wcstoull"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoull"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoll = Module["_wcstoll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoul = Module["_wcstoul"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoul"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstol = Module["_wcstol"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoimax = Module["_wcstoimax"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoimax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcstoumax = Module["_wcstoumax"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcstoumax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _lldiv = Module["_lldiv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["lldiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _imaxabs = Module["_imaxabs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["imaxabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bsearch = Module["_bsearch"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bsearch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _imaxdiv = Module["_imaxdiv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["imaxdiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _llabs = Module["_llabs"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["llabs"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fcvt = Module["_fcvt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fcvt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _div = Module["_div"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["div"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atol = Module["_atol"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atol"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gcvt = Module["_gcvt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gcvt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtof = Module["_strtof"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtof"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtold = Module["_strtold"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtold"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtof_l = Module["_strtof_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtof_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtod_l = Module["_strtod_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtod_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strtold_l = Module["_strtold_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strtold_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ldiv = Module["_ldiv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ldiv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freelocale = Module["_freelocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freelocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___loc_is_allocated = Module["___loc_is_allocated"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__loc_is_allocated"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___freelocale = Module["___freelocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__freelocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wcsxfrm_l = Module["___wcsxfrm_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wcsxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsxfrm = Module["_wcsxfrm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsxfrm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcsxfrm_l = Module["_wcsxfrm_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcsxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___gettextdomain = Module["___gettextdomain"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__gettextdomain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _textdomain = Module["_textdomain"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["textdomain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _gettext = Module["_gettext"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["gettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dgettext = Module["_dgettext"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dgettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ngettext = Module["_ngettext"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ngettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dngettext = Module["_dngettext"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dngettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catclose = Module["_catclose"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catclose"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strcoll_l = Module["___strcoll_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strcoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strcoll_l = Module["_strcoll_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strcoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _localeconv = Module["_localeconv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["localeconv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bind_textdomain_codeset = Module["_bind_textdomain_codeset"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bind_textdomain_codeset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___pleval = Module["___pleval"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__pleval"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strfmon_l = Module["_strfmon_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strfmon_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strfmon = Module["_strfmon"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strfmon"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___newlocale = Module["___newlocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__newlocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___get_locale = Module["___get_locale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__get_locale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _newlocale = Module["_newlocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["newlocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___nl_langinfo_l = Module["___nl_langinfo_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__nl_langinfo_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___nl_langinfo = Module["___nl_langinfo"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__nl_langinfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nl_langinfo = Module["_nl_langinfo"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nl_langinfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _nl_langinfo_l = Module["_nl_langinfo_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["nl_langinfo_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bindtextdomain = Module["_bindtextdomain"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bindtextdomain"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dcngettext = Module["_dcngettext"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dcngettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___mo_lookup = Module["___mo_lookup"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__mo_lookup"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _dcgettext = Module["_dcgettext"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dcgettext"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___uselocale = Module["___uselocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__uselocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _uselocale = Module["_uselocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["uselocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___strxfrm_l = Module["___strxfrm_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__strxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strxfrm = Module["_strxfrm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strxfrm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _strxfrm_l = Module["_strxfrm_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["strxfrm_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catopen = Module["_catopen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catopen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___wcscoll_l = Module["___wcscoll_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wcscoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscoll = Module["_wcscoll"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscoll"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _wcscoll_l = Module["_wcscoll_l"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["wcscoll_l"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lctrans_impl = Module["___lctrans_impl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lctrans_impl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___duplocale = Module["___duplocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__duplocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _duplocale = Module["_duplocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["duplocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iconv_open = Module["_iconv_open"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iconv_open"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iconv_close = Module["_iconv_close"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iconv_close"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _iconv = Module["_iconv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["iconv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _catgets = Module["_catgets"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["catgets"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setlocale = Module["_setlocale"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setlocale"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _clock_settime = Module["_clock_settime"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["clock_settime"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpagesize = Module["_getpagesize"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpagesize"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___emscripten_environ_constructor = Module["___emscripten_environ_constructor"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__emscripten_environ_constructor"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___putenv = Module["___putenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__putenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _unsetenv = Module["_unsetenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["unsetenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _putenv = Module["_putenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["putenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setenv = Module["_setenv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setenv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sched_yield = Module["_sched_yield"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sched_yield"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __get_tzname = Module["__get_tzname"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_get_tzname"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __get_daylight = Module["__get_daylight"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_get_daylight"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __get_timezone = Module["__get_timezone"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_get_timezone"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashlti3 = Module["___ashlti3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashlti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lshrti3 = Module["___lshrti3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lshrti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashldi3 = Module["___ashldi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashldi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashrdi3 = Module["___ashrdi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashrdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ashrti3 = Module["___ashrti3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ashrti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load = Module["___atomic_load"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store = Module["___atomic_store"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange = Module["___atomic_compare_exchange"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange = Module["___atomic_exchange"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_1 = Module["___atomic_load_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_2 = Module["___atomic_load_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_4 = Module["___atomic_load_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_8 = Module["___atomic_load_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_load_16 = Module["___atomic_load_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_load_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_1 = Module["___atomic_store_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_2 = Module["___atomic_store_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_4 = Module["___atomic_store_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_8 = Module["___atomic_store_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_store_16 = Module["___atomic_store_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_store_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_1 = Module["___atomic_exchange_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_2 = Module["___atomic_exchange_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_4 = Module["___atomic_exchange_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_8 = Module["___atomic_exchange_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_exchange_16 = Module["___atomic_exchange_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_exchange_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_1 = Module["___atomic_compare_exchange_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_2 = Module["___atomic_compare_exchange_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_4 = Module["___atomic_compare_exchange_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_8 = Module["___atomic_compare_exchange_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_compare_exchange_16 = Module["___atomic_compare_exchange_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_compare_exchange_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_1 = Module["___atomic_fetch_add_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_2 = Module["___atomic_fetch_add_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_4 = Module["___atomic_fetch_add_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_8 = Module["___atomic_fetch_add_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_add_16 = Module["___atomic_fetch_add_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_add_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_1 = Module["___atomic_fetch_sub_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_2 = Module["___atomic_fetch_sub_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_4 = Module["___atomic_fetch_sub_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_8 = Module["___atomic_fetch_sub_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_sub_16 = Module["___atomic_fetch_sub_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_sub_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_1 = Module["___atomic_fetch_and_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_2 = Module["___atomic_fetch_and_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_4 = Module["___atomic_fetch_and_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_8 = Module["___atomic_fetch_and_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_and_16 = Module["___atomic_fetch_and_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_and_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_1 = Module["___atomic_fetch_or_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_2 = Module["___atomic_fetch_or_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_4 = Module["___atomic_fetch_or_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_8 = Module["___atomic_fetch_or_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_or_16 = Module["___atomic_fetch_or_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_or_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_1 = Module["___atomic_fetch_xor_1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_2 = Module["___atomic_fetch_xor_2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_4 = Module["___atomic_fetch_xor_4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_8 = Module["___atomic_fetch_xor_8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___atomic_fetch_xor_16 = Module["___atomic_fetch_xor_16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__atomic_fetch_xor_16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___clzti2 = Module["___clzti2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__clzti2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divdc3 = Module["___divdc3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divdc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmax = Module["_fmax"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmax"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divdi3 = Module["___divdi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivmoddi4 = Module["___udivmoddi4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivmoddi4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divmoddi4 = Module["___divmoddi4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divmoddi4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divsc3 = Module["___divsc3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divsc3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmaxf = Module["_fmaxf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmaxf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___divti3 = Module["___divti3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__divti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivmodti4 = Module["___udivmodti4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivmodti4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixdfdi = Module["___fixdfdi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixdfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunsdfdi = Module["___fixunsdfdi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunsdfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixdfti = Module["___fixdfti"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixdfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixsfti = Module["___fixsfti"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixsfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixtfti = Module["___fixtfti"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixtfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunsdfti = Module["___fixunsdfti"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunsdfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunssfti = Module["___fixunssfti"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunssfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunstfdi = Module["___fixunstfdi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunstfdi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunstfsi = Module["___fixunstfsi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunstfsi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___fixunstfti = Module["___fixunstfti"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__fixunstfti"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatdidf = Module["___floatdidf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatdidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatditf = Module["___floatditf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatditf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floattidf = Module["___floattidf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floattidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floattisf = Module["___floattisf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floattisf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floattitf = Module["___floattitf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floattitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatunditf = Module["___floatunditf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatunditf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatuntidf = Module["___floatuntidf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatuntidf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___floatuntisf = Module["___floatuntisf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__floatuntisf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___lshrdi3 = Module["___lshrdi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__lshrdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___moddi3 = Module["___moddi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__moddi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___modti3 = Module["___modti3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__modti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___muldi3 = Module["___muldi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__muldi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___powidf2 = Module["___powidf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__powidf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___powisf2 = Module["___powisf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__powisf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___powitf2 = Module["___powitf2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__powitf2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivdi3 = Module["___udivdi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivdi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___udivti3 = Module["___udivti3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__udivti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___umoddi3 = Module["___umoddi3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__umoddi3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___umodti3 = Module["___umodti3"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__umodti3"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _setThrew = Module["_setThrew"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setThrew"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _cosl = Module["_cosl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["cosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sinl = Module["_sinl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _tanl = Module["_tanl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["tanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acos = Module["_acos"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acos"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acosf = Module["_acosf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acosf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _acosl = Module["_acosl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["acosl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asin = Module["_asin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinf = Module["_asinf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _asinl = Module["_asinl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["asinl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atan = Module["_atan"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atan"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanf = Module["_atanf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _atanl = Module["_atanl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["atanl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _expl = Module["_expl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["expl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _powf = Module["_powf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["powf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _ceill = Module["_ceill"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["ceill"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _floorl = Module["_floorl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["floorl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sbrk = Module["_sbrk"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sbrk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _realloc_in_place = Module["_realloc_in_place"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["realloc_in_place"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memalign = Module["_memalign"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memalign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _valloc = Module["_valloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["valloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pvalloc = Module["_pvalloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pvalloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mallinfo = Module["_mallinfo"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mallinfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _mallopt = Module["_mallopt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["mallopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_trim = Module["_malloc_trim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_trim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_usable_size = Module["_malloc_usable_size"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_usable_size"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_footprint = Module["_malloc_footprint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_footprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_max_footprint = Module["_malloc_max_footprint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_max_footprint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_footprint_limit = Module["_malloc_footprint_limit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_footprint_limit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc_set_footprint_limit = Module["_malloc_set_footprint_limit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc_set_footprint_limit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _independent_calloc = Module["_independent_calloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["independent_calloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _independent_comalloc = Module["_independent_comalloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["independent_comalloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _bulk_free = Module["_bulk_free"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["bulk_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_builtin_malloc = Module["_emscripten_builtin_malloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_builtin_malloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_builtin_free = Module["_emscripten_builtin_free"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_builtin_free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_builtin_memalign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _brk = Module["_brk"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["brk"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_has_threading_support = Module["_emscripten_has_threading_support"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_has_threading_support"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_num_logical_cores = Module["_emscripten_num_logical_cores"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_num_logical_cores"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_force_num_logical_cores = Module["_emscripten_force_num_logical_cores"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_force_num_logical_cores"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_exchange_u8 = Module["_emscripten_atomic_exchange_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_exchange_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_exchange_u16 = Module["_emscripten_atomic_exchange_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_exchange_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_exchange_u32 = Module["_emscripten_atomic_exchange_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_exchange_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_exchange_u64 = Module["_emscripten_atomic_exchange_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_exchange_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_cas_u8 = Module["_emscripten_atomic_cas_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_cas_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_cas_u16 = Module["_emscripten_atomic_cas_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_cas_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_cas_u32 = Module["_emscripten_atomic_cas_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_cas_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_cas_u64 = Module["_emscripten_atomic_cas_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_cas_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_load_u8 = Module["_emscripten_atomic_load_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_load_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_load_u16 = Module["_emscripten_atomic_load_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_load_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_load_u32 = Module["_emscripten_atomic_load_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_load_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_load_f32 = Module["_emscripten_atomic_load_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_load_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_load_u64 = Module["_emscripten_atomic_load_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_load_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_load_f64 = Module["_emscripten_atomic_load_f64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_load_f64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_store_u8 = Module["_emscripten_atomic_store_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_store_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_store_u16 = Module["_emscripten_atomic_store_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_store_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_store_u32 = Module["_emscripten_atomic_store_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_store_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_store_f32 = Module["_emscripten_atomic_store_f32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_store_f32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_store_u64 = Module["_emscripten_atomic_store_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_store_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_store_f64 = Module["_emscripten_atomic_store_f64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_store_f64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_fence = Module["_emscripten_atomic_fence"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_fence"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_add_u8 = Module["_emscripten_atomic_add_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_add_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_add_u16 = Module["_emscripten_atomic_add_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_add_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_add_u32 = Module["_emscripten_atomic_add_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_add_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_add_u64 = Module["_emscripten_atomic_add_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_add_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_sub_u8 = Module["_emscripten_atomic_sub_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_sub_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_sub_u16 = Module["_emscripten_atomic_sub_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_sub_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_sub_u32 = Module["_emscripten_atomic_sub_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_sub_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_sub_u64 = Module["_emscripten_atomic_sub_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_sub_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_and_u8 = Module["_emscripten_atomic_and_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_and_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_and_u16 = Module["_emscripten_atomic_and_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_and_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_and_u32 = Module["_emscripten_atomic_and_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_and_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_and_u64 = Module["_emscripten_atomic_and_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_and_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_or_u8 = Module["_emscripten_atomic_or_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_or_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_or_u16 = Module["_emscripten_atomic_or_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_or_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_or_u32 = Module["_emscripten_atomic_or_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_or_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_or_u64 = Module["_emscripten_atomic_or_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_or_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_xor_u8 = Module["_emscripten_atomic_xor_u8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_xor_u8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_xor_u16 = Module["_emscripten_atomic_xor_u16"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_xor_u16"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_xor_u32 = Module["_emscripten_atomic_xor_u32"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_xor_u32"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_atomic_xor_u64 = Module["_emscripten_atomic_xor_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_atomic_xor_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __emscripten_atomic_fetch_and_add_u64 = Module["__emscripten_atomic_fetch_and_add_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_emscripten_atomic_fetch_and_add_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __emscripten_atomic_fetch_and_sub_u64 = Module["__emscripten_atomic_fetch_and_sub_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_emscripten_atomic_fetch_and_sub_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __emscripten_atomic_fetch_and_and_u64 = Module["__emscripten_atomic_fetch_and_and_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_emscripten_atomic_fetch_and_and_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __emscripten_atomic_fetch_and_or_u64 = Module["__emscripten_atomic_fetch_and_or_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_emscripten_atomic_fetch_and_or_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __emscripten_atomic_fetch_and_xor_u64 = Module["__emscripten_atomic_fetch_and_xor_u64"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_emscripten_atomic_fetch_and_xor_u64"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_futex_wait = Module["_emscripten_futex_wait"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_futex_wait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_futex_wake = Module["_emscripten_futex_wake"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_futex_wake"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_is_main_runtime_thread = Module["_emscripten_is_main_runtime_thread"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_is_main_runtime_thread"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_main_thread_process_queued_calls"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emscripten_current_thread_process_queued_calls"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_mutex_init = Module["_pthread_mutex_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_mutex_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_mutex_lock = Module["_pthread_mutex_lock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_mutex_lock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_mutex_unlock = Module["_pthread_mutex_unlock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_mutex_unlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_mutex_trylock = Module["_pthread_mutex_trylock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_mutex_trylock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_mutex_timedlock = Module["_pthread_mutex_timedlock"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_mutex_timedlock"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_mutex_destroy = Module["_pthread_mutex_destroy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_mutex_destroy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_mutex_consistent = Module["_pthread_mutex_consistent"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_mutex_consistent"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_barrier_init = Module["_pthread_barrier_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_barrier_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_barrier_destroy = Module["_pthread_barrier_destroy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_barrier_destroy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_barrier_wait = Module["_pthread_barrier_wait"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_barrier_wait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_key_create = Module["_pthread_key_create"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_key_create"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_key_delete = Module["_pthread_key_delete"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_key_delete"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_getspecific = Module["_pthread_getspecific"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_getspecific"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_setspecific = Module["_pthread_setspecific"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_setspecific"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_once = Module["_pthread_once"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_once"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_cond_wait = Module["_pthread_cond_wait"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_cond_wait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_cond_signal = Module["_pthread_cond_signal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_cond_signal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_cond_broadcast = Module["_pthread_cond_broadcast"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_cond_broadcast"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_cond_init = Module["_pthread_cond_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_cond_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_cond_destroy = Module["_pthread_cond_destroy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_cond_destroy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_cond_timedwait = Module["_pthread_cond_timedwait"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_cond_timedwait"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_atfork = Module["_pthread_atfork"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_atfork"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pthread_equal = Module["_pthread_equal"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pthread_equal"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmin = Module["_fmin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fminf = Module["_fminf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fminf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fminl = Module["_fminl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fminl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmaxl = Module["_fmaxl"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmaxl"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmod = Module["_fmod"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmod"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fmodf = Module["_fmodf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fmodf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _log2f = Module["_log2f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["log2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp2 = Module["_exp2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp2f = Module["_exp2f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp2f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp10 = Module["_exp10"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp10"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pow10 = Module["_pow10"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pow10"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _exp10f = Module["_exp10f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["exp10f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _pow10f = Module["_pow10f"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["pow10f"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___signbitf = Module["___signbitf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__signbitf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___signbit = Module["___signbit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__signbit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towrite = Module["___towrite"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towrite"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___towrite_needs_stdio_exit = Module["___towrite_needs_stdio_exit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__towrite_needs_stdio_exit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fwrite_unlocked = Module["_fwrite_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fwrite_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fputs_unlocked = Module["_fputs_unlocked"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fputs_unlocked"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _printf = Module["_printf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["printf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___small_printf = Module["___small_printf"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__small_printf"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _puts = Module["_puts"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["puts"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan22GetSanititizerToolNameEv = Module["__ZN7__ubsan22GetSanititizerToolNameEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan22GetSanititizerToolNameEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan16InitAsStandaloneEv = Module["__ZN7__ubsan16InitAsStandaloneEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan16InitAsStandaloneEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15StaticSpinMutex8LockSlowEv = Module["__ZN11__sanitizer15StaticSpinMutex8LockSlowEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15StaticSpinMutex8LockSlowEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15CacheBinaryNameEv = Module["__ZN11__sanitizer15CacheBinaryNameEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15CacheBinaryNameEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan15InitializeFlagsEv = Module["__ZN7__ubsan15InitializeFlagsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan15InitializeFlagsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_set_report_path = Module["___sanitizer_set_report_path"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_set_report_path"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18InitializeCoverageEbPKc = Module["__ZN11__sanitizer18InitializeCoverageEbPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18InitializeCoverageEbPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan22InitializeSuppressionsEv = Module["__ZN7__ubsan22InitializeSuppressionsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan22InitializeSuppressionsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan27InitAsStandaloneIfNecessaryEv = Module["__ZN7__ubsan27InitAsStandaloneIfNecessaryEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan27InitAsStandaloneIfNecessaryEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12InitAsPluginEv = Module["__ZN7__ubsan12InitAsPluginEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12InitAsPluginEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20internal_sched_yieldEv = Module["__ZN11__sanitizer20internal_sched_yieldEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20internal_sched_yieldEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_dynamic_type_cache_miss = Module["___ubsan_handle_dynamic_type_cache_miss"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_dynamic_type_cache_miss"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan16checkDynamicTypeEPvS0_m = Module["__ZN7__ubsan16checkDynamicTypeEPvS0_m"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan16checkDynamicTypeEPvS0_m"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan28getDynamicTypeInfoFromObjectEPv = Module["__ZN7__ubsan28getDynamicTypeInfoFromObjectEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan28getDynamicTypeInfoFromObjectEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan21IsVptrCheckSuppressedEPKc = Module["__ZN7__ubsan21IsVptrCheckSuppressedEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan21IsVptrCheckSuppressedEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12ignoreReportENS_14SourceLocationENS_13ReportOptionsENS_9ErrorTypeE = Module["__ZN7__ubsan12ignoreReportENS_14SourceLocationENS_13ReportOptionsENS_9ErrorTypeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12ignoreReportENS_14SourceLocationENS_13ReportOptionsENS_9ErrorTypeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12ScopedReportC1ENS_13ReportOptionsENS_8LocationENS_9ErrorTypeE = Module["__ZN7__ubsan12ScopedReportC1ENS_13ReportOptionsENS_8LocationENS_9ErrorTypeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12ScopedReportC1ENS_13ReportOptionsENS_8LocationENS_9ErrorTypeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan4DiaglsERKNS_14TypeDescriptorE = Module["__ZN7__ubsan4DiaglsERKNS_14TypeDescriptorE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan4DiaglsERKNS_14TypeDescriptorE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan4DiagD1Ev = Module["__ZN7__ubsan4DiagD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan4DiagD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12ScopedReportD1Ev = Module["__ZN7__ubsan12ScopedReportD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12ScopedReportD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_dynamic_type_cache_miss_abort = Module["___ubsan_handle_dynamic_type_cache_miss_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_dynamic_type_cache_miss_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer3DieEv = Module["__ZN11__sanitizer3DieEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer3DieEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_cfi_bad_type = Module["___ubsan_handle_cfi_bad_type"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_cfi_bad_type"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan28getDynamicTypeInfoFromVtableEPv = Module["__ZN7__ubsan28getDynamicTypeInfoFromVtableEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan28getDynamicTypeInfoFromVtableEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer9GetOrInitEv = Module["__ZN11__sanitizer10Symbolizer9GetOrInitEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer9GetOrInitEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer27GetModuleNameAndOffsetForPCEmPPKcPm = Module["__ZN11__sanitizer10Symbolizer27GetModuleNameAndOffsetForPCEmPPKcPm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer27GetModuleNameAndOffsetForPCEmPPKcPm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_strcmpEPKcS1_ = Module["__ZN11__sanitizer15internal_strcmpEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_strcmpEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11CheckFailedEPKciS1_yy = Module["__ZN11__sanitizer11CheckFailedEPKciS1_yy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11CheckFailedEPKciS1_yy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan23UndefinedBehaviorReportC2EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE = Module["__ZN7__ubsan23UndefinedBehaviorReportC2EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan23UndefinedBehaviorReportC2EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20InternalScopedStringC2Em = Module["__ZN11__sanitizer20InternalScopedStringC2Em"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20InternalScopedStringC2Em"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20InternalScopedString6appendEPKcz = Module["__ZN11__sanitizer20InternalScopedString6appendEPKcz"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20InternalScopedString6appendEPKcz"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_on_report = Module["___ubsan_on_report"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_on_report"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorIcE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorIcE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorIcE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_memsetEPvim = Module["__ZN11__sanitizer15internal_memsetEPvim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_memsetEPvim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan31RegisterUndefinedBehaviorReportEPNS_23UndefinedBehaviorReportE = Module["__ZN7__ubsan31RegisterUndefinedBehaviorReportEPNS_23UndefinedBehaviorReportE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan31RegisterUndefinedBehaviorReportEPNS_23UndefinedBehaviorReportE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_get_current_report_data = Module["___ubsan_get_current_report_data"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_get_current_report_data"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11GetPageSizeEv = Module["__ZN11__sanitizer11GetPageSizeEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11GetPageSizeEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer9MmapOrDieEmPKcb = Module["__ZN11__sanitizer9MmapOrDieEmPKcb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer9MmapOrDieEmPKcb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_memcpyEPvPKvm = Module["__ZN11__sanitizer15internal_memcpyEPvPKvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_memcpyEPvPKvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10UnmapOrDieEPvm = Module["__ZN11__sanitizer10UnmapOrDieEPvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10UnmapOrDieEPvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer8RawWriteEPKc = Module["__ZN11__sanitizer8RawWriteEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer8RawWriteEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan23UndefinedBehaviorReportC1EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE = Module["__ZN7__ubsan23UndefinedBehaviorReportC1EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan23UndefinedBehaviorReportC1EPKcRNS_8LocationERN11__sanitizer20InternalScopedStringE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK7__ubsan5Value12getSIntValueEv = Module["__ZNK7__ubsan5Value12getSIntValueEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK7__ubsan5Value12getSIntValueEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK7__ubsan5Value12getUIntValueEv = Module["__ZNK7__ubsan5Value12getUIntValueEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK7__ubsan5Value12getUIntValueEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK7__ubsan5Value19getPositiveIntValueEv = Module["__ZNK7__ubsan5Value19getPositiveIntValueEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK7__ubsan5Value19getPositiveIntValueEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK7__ubsan5Value13getFloatValueEv = Module["__ZNK7__ubsan5Value13getFloatValueEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK7__ubsan5Value13getFloatValueEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan23InitializeDeadlySignalsEv = Module["__ZN7__ubsan23InitializeDeadlySignalsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan23InitializeDeadlySignalsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23IsAccessibleMemoryRangeEmm = Module["__ZN11__sanitizer23IsAccessibleMemoryRangeEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23IsAccessibleMemoryRangeEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___dynamic_cast = Module["___dynamic_cast"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__dynamic_cast"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_print_stack_trace = Module["___sanitizer_print_stack_trace"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_print_stack_trace"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer26GetThreadStackTopAndBottomEbPmS0_ = Module["__ZN11__sanitizer26GetThreadStackTopAndBottomEbPmS0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer26GetThreadStackTopAndBottomEbPmS0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10StackTrace12GetCurrentPcEv = Module["__ZN11__sanitizer10StackTrace12GetCurrentPcEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10StackTrace12GetCurrentPcEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18BufferedStackTrace6UnwindEjmmPvmmb = Module["__ZN11__sanitizer18BufferedStackTrace6UnwindEjmmPvmmb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18BufferedStackTrace6UnwindEjmmPvmmb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer10StackTrace5PrintEv = Module["__ZNK11__sanitizer10StackTrace5PrintEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer10StackTrace5PrintEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan13GetStackTraceEPN11__sanitizer18BufferedStackTraceEmmmPvb = Module["__ZN7__ubsan13GetStackTraceEPN11__sanitizer18BufferedStackTraceEmmmPvb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan13GetStackTraceEPN11__sanitizer18BufferedStackTraceEmmmPvb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan21getSymbolizedLocationEm = Module["__ZN7__ubsan21getSymbolizedLocationEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan21getSymbolizedLocationEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer11SymbolizePCEm = Module["__ZN11__sanitizer10Symbolizer11SymbolizePCEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer11SymbolizePCEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan4DiaglsERKNS_5ValueE = Module["__ZN7__ubsan4DiaglsERKNS_5ValueE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan4DiaglsERKNS_5ValueE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan4DiagD2Ev = Module["__ZN7__ubsan4DiagD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan4DiagD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21ScopedErrorReportLock11CheckLockedEv = Module["__ZN11__sanitizer21ScopedErrorReportLock11CheckLockedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21ScopedErrorReportLock11CheckLockedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15ColorizeReportsEv = Module["__ZN11__sanitizer15ColorizeReportsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15ColorizeReportsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_ = Module["__ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20RenderSourceLocationEPNS_20InternalScopedStringEPKciibS3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20RenderModuleLocationEPNS_20InternalScopedStringEPKcmNS_10ModuleArchES3_ = Module["__ZN11__sanitizer20RenderModuleLocationEPNS_20InternalScopedStringEPKcmNS_10ModuleArchES3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20RenderModuleLocationEPNS_20InternalScopedStringEPKcmNS_10ModuleArchES3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer6PrintfEPKcz = Module["__ZN11__sanitizer6PrintfEPKcz"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer6PrintfEPKcz"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer8DemangleEPKc = Module["__ZN11__sanitizer10Symbolizer8DemangleEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer8DemangleEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12ScopedReport11InitializerC2Ev = Module["__ZN7__ubsan12ScopedReport11InitializerC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12ScopedReport11InitializerC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12ScopedReportC2ENS_13ReportOptionsENS_8LocationENS_9ErrorTypeE = Module["__ZN7__ubsan12ScopedReportC2ENS_13ReportOptionsENS_8LocationENS_9ErrorTypeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12ScopedReportC2ENS_13ReportOptionsENS_8LocationENS_9ErrorTypeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21ScopedErrorReportLockC1Ev = Module["__ZN11__sanitizer21ScopedErrorReportLockC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21ScopedErrorReportLockC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12ScopedReportD2Ev = Module["__ZN7__ubsan12ScopedReportD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12ScopedReportD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11AddressInfoC1Ev = Module["__ZN11__sanitizer11AddressInfoC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11AddressInfoC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_strdupEPKc = Module["__ZN11__sanitizer15internal_strdupEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_strdupEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18ReportErrorSummaryEPKcRKNS_11AddressInfoES1_ = Module["__ZN11__sanitizer18ReportErrorSummaryEPKcRKNS_11AddressInfoES1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18ReportErrorSummaryEPKcRKNS_11AddressInfoES1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11AddressInfo5ClearEv = Module["__ZN11__sanitizer11AddressInfo5ClearEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11AddressInfo5ClearEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18ReportErrorSummaryEPKcS1_ = Module["__ZN11__sanitizer18ReportErrorSummaryEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18ReportErrorSummaryEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21ScopedErrorReportLockD1Ev = Module["__ZN11__sanitizer21ScopedErrorReportLockD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21ScopedErrorReportLockD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18SuppressionContextC1EPPKci = Module["__ZN11__sanitizer18SuppressionContextC1EPPKci"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18SuppressionContextC1EPPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc = Module["__ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18SuppressionContext13ParseFromFileEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE = Module["__ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18SuppressionContext5MatchEPKcS2_PPNS_11SuppressionE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan14IsPCSuppressedENS_9ErrorTypeEmPKc = Module["__ZN7__ubsan14IsPCSuppressedENS_9ErrorTypeEmPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan14IsPCSuppressedENS_9ErrorTypeEmPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc = Module["__ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer18SuppressionContext18HasSuppressionTypeEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15SymbolizedStack8ClearAllEv = Module["__ZN11__sanitizer15SymbolizedStack8ClearAllEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15SymbolizedStack8ClearAllEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan12ScopedReport11InitializerC1Ev = Module["__ZN7__ubsan12ScopedReport11InitializerC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan12ScopedReport11InitializerC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_type_mismatch_v1 = Module["___ubsan_handle_type_mismatch_v1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_type_mismatch_v1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_type_mismatch_v1_abort = Module["___ubsan_handle_type_mismatch_v1_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_type_mismatch_v1_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_alignment_assumption = Module["___ubsan_handle_alignment_assumption"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_alignment_assumption"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_alignment_assumption_abort = Module["___ubsan_handle_alignment_assumption_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_alignment_assumption_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_add_overflow = Module["___ubsan_handle_add_overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_add_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_add_overflow_abort = Module["___ubsan_handle_add_overflow_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_add_overflow_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_sub_overflow = Module["___ubsan_handle_sub_overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_sub_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_sub_overflow_abort = Module["___ubsan_handle_sub_overflow_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_sub_overflow_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_mul_overflow = Module["___ubsan_handle_mul_overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_mul_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_mul_overflow_abort = Module["___ubsan_handle_mul_overflow_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_mul_overflow_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_negate_overflow = Module["___ubsan_handle_negate_overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_negate_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_negate_overflow_abort = Module["___ubsan_handle_negate_overflow_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_negate_overflow_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_divrem_overflow = Module["___ubsan_handle_divrem_overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_divrem_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_divrem_overflow_abort = Module["___ubsan_handle_divrem_overflow_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_divrem_overflow_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_shift_out_of_bounds = Module["___ubsan_handle_shift_out_of_bounds"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_shift_out_of_bounds"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_shift_out_of_bounds_abort = Module["___ubsan_handle_shift_out_of_bounds_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_shift_out_of_bounds_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_out_of_bounds = Module["___ubsan_handle_out_of_bounds"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_out_of_bounds"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_out_of_bounds_abort = Module["___ubsan_handle_out_of_bounds_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_out_of_bounds_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_builtin_unreachable = Module["___ubsan_handle_builtin_unreachable"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_builtin_unreachable"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_missing_return = Module["___ubsan_handle_missing_return"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_missing_return"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_vla_bound_not_positive = Module["___ubsan_handle_vla_bound_not_positive"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_vla_bound_not_positive"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_vla_bound_not_positive_abort = Module["___ubsan_handle_vla_bound_not_positive_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_vla_bound_not_positive_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_float_cast_overflow = Module["___ubsan_handle_float_cast_overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_float_cast_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_float_cast_overflow_abort = Module["___ubsan_handle_float_cast_overflow_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_float_cast_overflow_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_load_invalid_value = Module["___ubsan_handle_load_invalid_value"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_load_invalid_value"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strncmpEPKcS1_m = Module["__ZN11__sanitizer16internal_strncmpEPKcS1_m"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strncmpEPKcS1_m"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_load_invalid_value_abort = Module["___ubsan_handle_load_invalid_value_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_load_invalid_value_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_implicit_conversion = Module["___ubsan_handle_implicit_conversion"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_implicit_conversion"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_implicit_conversion_abort = Module["___ubsan_handle_implicit_conversion_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_implicit_conversion_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_invalid_builtin = Module["___ubsan_handle_invalid_builtin"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_invalid_builtin"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_invalid_builtin_abort = Module["___ubsan_handle_invalid_builtin_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_invalid_builtin_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_function_type_mismatch = Module["___ubsan_handle_function_type_mismatch"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_function_type_mismatch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_function_type_mismatch_abort = Module["___ubsan_handle_function_type_mismatch_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_function_type_mismatch_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nonnull_return_v1 = Module["___ubsan_handle_nonnull_return_v1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nonnull_return_v1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nonnull_return_v1_abort = Module["___ubsan_handle_nonnull_return_v1_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nonnull_return_v1_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nullability_return_v1 = Module["___ubsan_handle_nullability_return_v1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nullability_return_v1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nullability_return_v1_abort = Module["___ubsan_handle_nullability_return_v1_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nullability_return_v1_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nonnull_arg = Module["___ubsan_handle_nonnull_arg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nonnull_arg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nonnull_arg_abort = Module["___ubsan_handle_nonnull_arg_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nonnull_arg_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nullability_arg = Module["___ubsan_handle_nullability_arg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nullability_arg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_nullability_arg_abort = Module["___ubsan_handle_nullability_arg_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_nullability_arg_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_pointer_overflow = Module["___ubsan_handle_pointer_overflow"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_pointer_overflow"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_pointer_overflow_abort = Module["___ubsan_handle_pointer_overflow_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_pointer_overflow_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_cfi_check_fail = Module["___ubsan_handle_cfi_check_fail"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_cfi_check_fail"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_handle_cfi_check_fail_abort = Module["___ubsan_handle_cfi_check_fail_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_handle_cfi_check_fail_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan28MaybeCallUbsanDefaultOptionsEv = Module["__ZN7__ubsan28MaybeCallUbsanDefaultOptionsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan28MaybeCallUbsanDefaultOptionsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___ubsan_default_options = Module["___ubsan_default_options"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__ubsan_default_options"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan5Flags11SetDefaultsEv = Module["__ZN7__ubsan5Flags11SetDefaultsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan5Flags11SetDefaultsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN7__ubsan18RegisterUbsanFlagsEPN11__sanitizer10FlagParserEPNS_5FlagsE = Module["__ZN7__ubsan18RegisterUbsanFlagsEPN11__sanitizer10FlagParserEPNS_5FlagsE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN7__ubsan18RegisterUbsanFlagsEPN11__sanitizer10FlagParserEPNS_5FlagsE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17LowLevelAllocator8AllocateEm = Module["__ZN11__sanitizer17LowLevelAllocator8AllocateEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17LowLevelAllocator8AllocateEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_ = Module["__ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser15RegisterHandlerEPKcPNS_15FlagHandlerBaseES2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11CommonFlags11SetDefaultsEv = Module["__ZN11__sanitizer11CommonFlags11SetDefaultsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11CommonFlags11SetDefaultsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11CommonFlags8CopyFromERKS0_ = Module["__ZN11__sanitizer11CommonFlags8CopyFromERKS0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11CommonFlags8CopyFromERKS0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParserC1Ev = Module["__ZN11__sanitizer10FlagParserC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParserC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19RegisterCommonFlagsEPNS_10FlagParserEPNS_11CommonFlagsE = Module["__ZN11__sanitizer19RegisterCommonFlagsEPNS_10FlagParserEPNS_11CommonFlagsE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19RegisterCommonFlagsEPNS_10FlagParserEPNS_11CommonFlagsE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser11ParseStringEPKc = Module["__ZN11__sanitizer10FlagParser11ParseStringEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser11ParseStringEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21InitializeCommonFlagsEPNS_11CommonFlagsE = Module["__ZN11__sanitizer21InitializeCommonFlagsEPNS_11CommonFlagsE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21InitializeCommonFlagsEPNS_11CommonFlagsE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23ReportUnrecognizedFlagsEv = Module["__ZN11__sanitizer23ReportUnrecognizedFlagsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23ReportUnrecognizedFlagsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser21PrintFlagDescriptionsEv = Module["__ZN11__sanitizer10FlagParser21PrintFlagDescriptionsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser21PrintFlagDescriptionsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11FlagHandlerIbE5ParseEPKc = Module["__ZN11__sanitizer11FlagHandlerIbE5ParseEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11FlagHandlerIbE5ParseEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11FlagHandlerIPKcE5ParseES2_ = Module["__ZN11__sanitizer11FlagHandlerIPKcE5ParseES2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11FlagHandlerIPKcE5ParseES2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13ListOfModules4initEv = Module["__ZN11__sanitizer13ListOfModules4initEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13ListOfModules4initEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorINS_12LoadedModuleEE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorINS_12LoadedModuleEE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorINS_12LoadedModuleEE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12LoadedModule3setEPKcm = Module["__ZN11__sanitizer12LoadedModule3setEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12LoadedModule3setEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12LoadedModule15addAddressRangeEmmbbPKc = Module["__ZN11__sanitizer12LoadedModule15addAddressRangeEmmbbPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12LoadedModule15addAddressRangeEmmbbPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorINS_12LoadedModuleEE9push_backERKS1_ = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorINS_12LoadedModuleEE9push_backERKS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorINS_12LoadedModuleEE9push_backERKS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13ListOfModules12fallbackInitEv = Module["__ZN11__sanitizer13ListOfModules12fallbackInitEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13ListOfModules12fallbackInitEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12LoadedModule5clearEv = Module["__ZN11__sanitizer12LoadedModule5clearEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12LoadedModule5clearEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18internal_sigactionEiPKvPv = Module["__ZN11__sanitizer18internal_sigactionEiPKvPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18internal_sigactionEiPKvPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13internal_mmapEPvmiiim = Module["__ZN11__sanitizer13internal_mmapEPvmiiim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13internal_mmapEPvmiiim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_munmapEPvm = Module["__ZN11__sanitizer15internal_munmapEPvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_munmapEPvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer7GetArgvEv = Module["__ZN11__sanitizer7GetArgvEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer7GetArgvEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10GetEnvironEv = Module["__ZN11__sanitizer10GetEnvironEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10GetEnvironEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10GetTlsSizeEv = Module["__ZN11__sanitizer10GetTlsSizeEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10GetTlsSizeEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11InitTlsSizeEv = Module["__ZN11__sanitizer11InitTlsSizeEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11InitTlsSizeEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20GetThreadStackAndTlsEbPmS0_S0_S0_ = Module["__ZN11__sanitizer20GetThreadStackAndTlsEbPmS0_S0_S0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20GetThreadStackAndTlsEbPmS0_S0_S0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12StopTheWorldEPFvRKNS_20SuspendedThreadsListEPvES3_ = Module["__ZN11__sanitizer12StopTheWorldEPFvRKNS_20SuspendedThreadsListEPvES3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12StopTheWorldEPFvRKNS_20SuspendedThreadsListEPvES3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer20SuspendedThreadsList17GetRegistersAndSPEmPmS1_ = Module["__ZNK11__sanitizer20SuspendedThreadsList17GetRegistersAndSPEmPmS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer20SuspendedThreadsList17GetRegistersAndSPEmPmS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer20SuspendedThreadsList13RegisterCountEv = Module["__ZNK11__sanitizer20SuspendedThreadsList13RegisterCountEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer20SuspendedThreadsList13RegisterCountEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer20SuspendedThreadsList11ThreadCountEv = Module["__ZNK11__sanitizer20SuspendedThreadsList11ThreadCountEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer20SuspendedThreadsList11ThreadCountEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer20SuspendedThreadsList11GetThreadIDEm = Module["__ZNK11__sanitizer20SuspendedThreadsList11GetThreadIDEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer20SuspendedThreadsList11GetThreadIDEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer31SetSoftRssLimitExceededCallbackEPFvbE = Module["__ZN11__sanitizer31SetSoftRssLimitExceededCallbackEPFvbE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer31SetSoftRssLimitExceededCallbackEPFvbE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13WriteToSyslogEPKc = Module["__ZN11__sanitizer13WriteToSyslogEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13WriteToSyslogEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_strchrEPKci = Module["__ZN11__sanitizer15internal_strchrEPKci"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_strchrEPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer25MaybeStartBackgroudThreadEv = Module["__ZN11__sanitizer25MaybeStartBackgroudThreadEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer25MaybeStartBackgroudThreadEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21SetSandboxingCallbackEPFvvE = Module["__ZN11__sanitizer21SetSandboxingCallbackEPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21SetSandboxingCallbackEPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_sandbox_on_notify = Module["___sanitizer_sandbox_on_notify"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_sandbox_on_notify"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer28PlatformPrepareForSandboxingEP29__sanitizer_sandbox_arguments = Module["__ZN11__sanitizer28PlatformPrepareForSandboxingEP29__sanitizer_sandbox_arguments"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer28PlatformPrepareForSandboxingEP29__sanitizer_sandbox_arguments"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_ = Module["__ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11RenderFrameEPNS_20InternalScopedStringEPKciRKNS_11AddressInfoEbS3_S3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18ReportErrorSummaryEPKcPKNS_10StackTraceES1_ = Module["__ZN11__sanitizer18ReportErrorSummaryEPKcPKNS_10StackTraceES1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18ReportErrorSummaryEPKcPKNS_10StackTraceES1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19ReportMmapWriteExecEi = Module["__ZN11__sanitizer19ReportMmapWriteExecEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19ReportMmapWriteExecEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21ScopedErrorReportLockC2Ev = Module["__ZN11__sanitizer21ScopedErrorReportLockC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21ScopedErrorReportLockC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorINS_18BufferedStackTraceEE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorINS_18BufferedStackTraceEE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorINS_18BufferedStackTraceEE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer6ReportEPKcz = Module["__ZN11__sanitizer6ReportEPKcz"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer6ReportEPKcz"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23StartReportDeadlySignalEv = Module["__ZN11__sanitizer23StartReportDeadlySignalEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23StartReportDeadlySignalEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_strlenEPKc = Module["__ZN11__sanitizer15internal_strlenEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_strlenEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22CatastrophicErrorWriteEPKcm = Module["__ZN11__sanitizer22CatastrophicErrorWriteEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22CatastrophicErrorWriteEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18ReportDeadlySignalERKNS_13SignalContextEjPFvS2_PKvPNS_18BufferedStackTraceEES4_ = Module["__ZN11__sanitizer18ReportDeadlySignalERKNS_13SignalContextEjPFvS2_PKvPNS_18BufferedStackTraceEES4_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18ReportDeadlySignalERKNS_13SignalContextEjPFvS2_PKvPNS_18BufferedStackTraceEES4_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer13SignalContext15IsStackOverflowEv = Module["__ZNK11__sanitizer13SignalContext15IsStackOverflowEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer13SignalContext15IsStackOverflowEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer13SignalContext8DescribeEv = Module["__ZNK11__sanitizer13SignalContext8DescribeEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer13SignalContext8DescribeEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13SignalContext16DumpAllRegistersEPv = Module["__ZN11__sanitizer13SignalContext16DumpAllRegistersEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13SignalContext16DumpAllRegistersEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18HandleDeadlySignalEPvS0_jPFvRKNS_13SignalContextEPKvPNS_18BufferedStackTraceEES5_ = Module["__ZN11__sanitizer18HandleDeadlySignalEPvS0_jPFvRKNS_13SignalContextEPKvPNS_18BufferedStackTraceEES5_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18HandleDeadlySignalEPvS0_jPFvRKNS_13SignalContextEPKvPNS_18BufferedStackTraceEES5_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13SignalContextC2EPvS1_ = Module["__ZN11__sanitizer13SignalContextC2EPvS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13SignalContextC2EPvS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer13SignalContext10GetAddressEv = Module["__ZNK11__sanitizer13SignalContext10GetAddressEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer13SignalContext10GetAddressEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer13SignalContext14IsMemoryAccessEv = Module["__ZNK11__sanitizer13SignalContext14IsMemoryAccessEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer13SignalContext14IsMemoryAccessEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer13SignalContext12GetWriteFlagEv = Module["__ZNK11__sanitizer13SignalContext12GetWriteFlagEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer13SignalContext12GetWriteFlagEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13SignalContext10InitPcSpBpEv = Module["__ZN11__sanitizer13SignalContext10InitPcSpBpEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13SignalContext10InitPcSpBpEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13GetThreadSelfEv = Module["__ZN11__sanitizer13GetThreadSelfEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13GetThreadSelfEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14internal__exitEi = Module["__ZN11__sanitizer14internal__exitEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14internal__exitEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21ScopedErrorReportLockD2Ev = Module["__ZN11__sanitizer21ScopedErrorReportLockD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21ScopedErrorReportLockD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16StackDepotHandle2idEv = Module["__ZN11__sanitizer16StackDepotHandle2idEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16StackDepotHandle2idEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16StackDepotHandle9use_countEv = Module["__ZN11__sanitizer16StackDepotHandle9use_countEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16StackDepotHandle9use_countEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16StackDepotHandle20inc_use_count_unsafeEv = Module["__ZN11__sanitizer16StackDepotHandle20inc_use_count_unsafeEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16StackDepotHandle20inc_use_count_unsafeEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18StackDepotGetStatsEv = Module["__ZN11__sanitizer18StackDepotGetStatsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18StackDepotGetStatsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13StackDepotPutENS_10StackTraceE = Module["__ZN11__sanitizer13StackDepotPutENS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13StackDepotPutENS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb = Module["__ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3PutENS_10StackTraceEPb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24StackDepotPut_WithHandleENS_10StackTraceE = Module["__ZN11__sanitizer24StackDepotPut_WithHandleENS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24StackDepotPut_WithHandleENS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13StackDepotGetEj = Module["__ZN11__sanitizer13StackDepotGetEj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13StackDepotGetEj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3GetEj = Module["__ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3GetEj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14StackDepotBaseINS_14StackDepotNodeELi1ELi20EE3GetEj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17StackDepotLockAllEv = Module["__ZN11__sanitizer17StackDepotLockAllEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17StackDepotLockAllEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19StackDepotUnlockAllEv = Module["__ZN11__sanitizer19StackDepotUnlockAllEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19StackDepotUnlockAllEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20StackDepotReverseMap10IdDescPair12IdComparatorERKS1_S3_ = Module["__ZN11__sanitizer20StackDepotReverseMap10IdDescPair12IdComparatorERKS1_S3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20StackDepotReverseMap10IdDescPair12IdComparatorERKS1_S3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20StackDepotReverseMapC2Ev = Module["__ZN11__sanitizer20StackDepotReverseMapC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20StackDepotReverseMapC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorINS_20StackDepotReverseMap10IdDescPairEE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorINS_20StackDepotReverseMap10IdDescPairEE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorINS_20StackDepotReverseMap10IdDescPairEE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorINS_20StackDepotReverseMap10IdDescPairEE9push_backERKS2_ = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorINS_20StackDepotReverseMap10IdDescPairEE9push_backERKS2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorINS_20StackDepotReverseMap10IdDescPairEE9push_backERKS2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20StackDepotReverseMap3GetEj = Module["__ZN11__sanitizer20StackDepotReverseMap3GetEj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20StackDepotReverseMap3GetEj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20StackDepotReverseMapC1Ev = Module["__ZN11__sanitizer20StackDepotReverseMapC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20StackDepotReverseMapC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15StripPathPrefixEPKcS1_ = Module["__ZN11__sanitizer15StripPathPrefixEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15StripPathPrefixEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15StripModuleNameEPKc = Module["__ZN11__sanitizer15StripModuleNameEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15StripModuleNameEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10RenderDataEPNS_20InternalScopedStringEPKcPKNS_8DataInfoES3_ = Module["__ZN11__sanitizer10RenderDataEPNS_20InternalScopedStringEPKcPKNS_8DataInfoES3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10RenderDataEPNS_20InternalScopedStringEPKcPKNS_8DataInfoES3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18GetMmapGranularityEv = Module["__ZN11__sanitizer18GetMmapGranularityEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18GetMmapGranularityEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_iserrorEmPi = Module["__ZN11__sanitizer16internal_iserrorEmPi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_iserrorEmPi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17IncreaseTotalMmapEm = Module["__ZN11__sanitizer17IncreaseTotalMmapEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17IncreaseTotalMmapEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23ReportMmapFailureAndDieEmPKcS1_ib = Module["__ZN11__sanitizer23ReportMmapFailureAndDieEmPKcS1_ib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23ReportMmapFailureAndDieEmPKcS1_ib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17DecreaseTotalMmapEm = Module["__ZN11__sanitizer17DecreaseTotalMmapEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17DecreaseTotalMmapEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21MmapOrDieOnFatalErrorEmPKc = Module["__ZN11__sanitizer21MmapOrDieOnFatalErrorEmPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21MmapOrDieOnFatalErrorEmPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer28MmapAlignedOrDieOnFatalErrorEmmPKc = Module["__ZN11__sanitizer28MmapAlignedOrDieOnFatalErrorEmmPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer28MmapAlignedOrDieOnFatalErrorEmmPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18MmapNoReserveOrDieEmPKc = Module["__ZN11__sanitizer18MmapNoReserveOrDieEmPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18MmapNoReserveOrDieEmPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13MmapFixedImplEmmb = Module["__ZN11__sanitizer13MmapFixedImplEmmb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13MmapFixedImplEmmb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17internal_snprintfEPcmPKcz = Module["__ZN11__sanitizer17internal_snprintfEPcmPKcz"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17internal_snprintfEPcmPKcz"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14MmapFixedOrDieEmm = Module["__ZN11__sanitizer14MmapFixedOrDieEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14MmapFixedOrDieEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer26MmapFixedOrDieOnFatalErrorEmm = Module["__ZN11__sanitizer26MmapFixedOrDieOnFatalErrorEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer26MmapFixedOrDieOnFatalErrorEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16MprotectNoAccessEmm = Module["__ZN11__sanitizer16MprotectNoAccessEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16MprotectNoAccessEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17internal_mprotectEPvmi = Module["__ZN11__sanitizer17internal_mprotectEPvmi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17internal_mprotectEPvmi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16MprotectReadOnlyEmm = Module["__ZN11__sanitizer16MprotectReadOnlyEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16MprotectReadOnlyEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19MprotectMallocZonesEPvi = Module["__ZN11__sanitizer19MprotectMallocZonesEPvi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19MprotectMallocZonesEPvi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi = Module["__ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer8OpenFileEPKcNS_14FileAccessModeEPi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13internal_openEPKcij = Module["__ZN11__sanitizer13internal_openEPKcij"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13internal_openEPKcij"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18ReserveStandardFdsEi = Module["__ZN11__sanitizer18ReserveStandardFdsEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18ReserveStandardFdsEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23ShouldMockFailureToOpenEPKc = Module["__ZN11__sanitizer23ShouldMockFailureToOpenEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23ShouldMockFailureToOpenEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12internal_dupEi = Module["__ZN11__sanitizer12internal_dupEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12internal_dupEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14internal_closeEi = Module["__ZN11__sanitizer14internal_closeEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14internal_closeEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer9CloseFileEi = Module["__ZN11__sanitizer9CloseFileEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer9CloseFileEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12ReadFromFileEiPvmPmPi = Module["__ZN11__sanitizer12ReadFromFileEiPvmPmPi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12ReadFromFileEiPvmPmPi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13internal_readEiPvm = Module["__ZN11__sanitizer13internal_readEiPvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13internal_readEiPvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11WriteToFileEiPKvmPmPi = Module["__ZN11__sanitizer11WriteToFileEiPKvmPmPi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11WriteToFileEiPKvmPmPi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14internal_writeEiPKvm = Module["__ZN11__sanitizer14internal_writeEiPKvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14internal_writeEiPKvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15MapFileToMemoryEPKcPm = Module["__ZN11__sanitizer15MapFileToMemoryEPKcPm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15MapFileToMemoryEPKcPm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17internal_filesizeEi = Module["__ZN11__sanitizer17internal_filesizeEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17internal_filesizeEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23MapWritableFileToMemoryEPvmim = Module["__ZN11__sanitizer23MapWritableFileToMemoryEPvmim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23MapWritableFileToMemoryEPvmim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22MemoryRangeIsAvailableEmm = Module["__ZN11__sanitizer22MemoryRangeIsAvailableEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22MemoryRangeIsAvailableEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14DumpProcessMapEv = Module["__ZN11__sanitizer14DumpProcessMapEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14DumpProcessMapEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer6GetPwdEv = Module["__ZN11__sanitizer6GetPwdEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer6GetPwdEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer6GetEnvEPKc = Module["__ZN11__sanitizer6GetEnvEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer6GetEnvEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15IsPathSeparatorEc = Module["__ZN11__sanitizer15IsPathSeparatorEc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15IsPathSeparatorEc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14IsAbsolutePathEPKc = Module["__ZN11__sanitizer14IsAbsolutePathEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14IsAbsolutePathEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10ReportFile5WriteEPKcm = Module["__ZN11__sanitizer10ReportFile5WriteEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10ReportFile5WriteEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv = Module["__ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10ReportFile17ReopenIfNecessaryEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_ = Module["__ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19GetCodeRangeForFileEPKcPmS2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer13SignalContext7GetTypeEv = Module["__ZNK11__sanitizer13SignalContext7GetTypeEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer13SignalContext7GetTypeEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16SetErrnoToENOMEMEv = Module["__ZN11__sanitizer16SetErrnoToENOMEMEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16SetErrnoToENOMEMEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBaseC2Ej = Module["__ZN11__sanitizer17ThreadContextBaseC2Ej"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBaseC2Ej"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBaseD2Ev = Module["__ZN11__sanitizer17ThreadContextBaseD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBaseD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase7SetNameEPKc = Module["__ZN11__sanitizer17ThreadContextBase7SetNameEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase7SetNameEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strncpyEPcPKcm = Module["__ZN11__sanitizer16internal_strncpyEPcPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strncpyEPcPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase7SetDeadEv = Module["__ZN11__sanitizer17ThreadContextBase7SetDeadEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase7SetDeadEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase12SetDestroyedEv = Module["__ZN11__sanitizer17ThreadContextBase12SetDestroyedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase12SetDestroyedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase12GetDestroyedEv = Module["__ZN11__sanitizer17ThreadContextBase12GetDestroyedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase12GetDestroyedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase9SetJoinedEPv = Module["__ZN11__sanitizer17ThreadContextBase9SetJoinedEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase9SetJoinedEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase11SetFinishedEv = Module["__ZN11__sanitizer17ThreadContextBase11SetFinishedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase11SetFinishedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase10SetStartedEybPv = Module["__ZN11__sanitizer17ThreadContextBase10SetStartedEybPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase10SetStartedEybPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase10SetCreatedEmybjPv = Module["__ZN11__sanitizer17ThreadContextBase10SetCreatedEmybjPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase10SetCreatedEmybjPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase5ResetEv = Module["__ZN11__sanitizer17ThreadContextBase5ResetEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase5ResetEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistryC2EPFPNS_17ThreadContextBaseEjEjjj = Module["__ZN11__sanitizer14ThreadRegistryC2EPFPNS_17ThreadContextBaseEjEjjj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistryC2EPFPNS_17ThreadContextBaseEjEjjj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13BlockingMutexC1Ev = Module["__ZN11__sanitizer13BlockingMutexC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13BlockingMutexC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry18GetNumberOfThreadsEPmS1_S1_ = Module["__ZN11__sanitizer14ThreadRegistry18GetNumberOfThreadsEPmS1_S1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry18GetNumberOfThreadsEPmS1_S1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13BlockingMutex4LockEv = Module["__ZN11__sanitizer13BlockingMutex4LockEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13BlockingMutex4LockEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13BlockingMutex6UnlockEv = Module["__ZN11__sanitizer13BlockingMutex6UnlockEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13BlockingMutex6UnlockEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry18GetMaxAliveThreadsEv = Module["__ZN11__sanitizer14ThreadRegistry18GetMaxAliveThreadsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry18GetMaxAliveThreadsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv = Module["__ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry12CreateThreadEmbjPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry13QuarantinePopEv = Module["__ZN11__sanitizer14ThreadRegistry13QuarantinePopEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry13QuarantinePopEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry30RunCallbackForEachThreadLockedEPFvPNS_17ThreadContextBaseEPvES3_ = Module["__ZN11__sanitizer14ThreadRegistry30RunCallbackForEachThreadLockedEPFvPNS_17ThreadContextBaseEPvES3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry30RunCallbackForEachThreadLockedEPFvPNS_17ThreadContextBaseEPvES3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13BlockingMutex11CheckLockedEv = Module["__ZN11__sanitizer13BlockingMutex11CheckLockedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13BlockingMutex11CheckLockedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_ = Module["__ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry10FindThreadEPFbPNS_17ThreadContextBaseEPvES3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_ = Module["__ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry23FindThreadContextLockedEPFbPNS_17ThreadContextBaseEPvES3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEy = Module["__ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry29FindThreadContextByOsIDLockedEy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc = Module["__ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry13SetThreadNameEjPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc = Module["__ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry21SetThreadNameByUserIdEmPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv = Module["__ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry12DetachThreadEjPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE = Module["__ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry14QuarantinePushEPNS_17ThreadContextBaseE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv = Module["__ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry10JoinThreadEjPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry12FinishThreadEj = Module["__ZN11__sanitizer14ThreadRegistry12FinishThreadEj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry12FinishThreadEj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry11StartThreadEjybPv = Module["__ZN11__sanitizer14ThreadRegistry11StartThreadEjybPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry11StartThreadEjybPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistry15SetThreadUserIdEjm = Module["__ZN11__sanitizer14ThreadRegistry15SetThreadUserIdEjm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistry15SetThreadUserIdEjm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase6OnDeadEv = Module["__ZN11__sanitizer17ThreadContextBase6OnDeadEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase6OnDeadEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase8OnJoinedEPv = Module["__ZN11__sanitizer17ThreadContextBase8OnJoinedEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase8OnJoinedEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase10OnFinishedEv = Module["__ZN11__sanitizer17ThreadContextBase10OnFinishedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase10OnFinishedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase9OnStartedEPv = Module["__ZN11__sanitizer17ThreadContextBase9OnStartedEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase9OnStartedEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase9OnCreatedEPv = Module["__ZN11__sanitizer17ThreadContextBase9OnCreatedEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase9OnCreatedEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase7OnResetEv = Module["__ZN11__sanitizer17ThreadContextBase7OnResetEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase7OnResetEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBase10OnDetachedEPv = Module["__ZN11__sanitizer17ThreadContextBase10OnDetachedEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBase10OnDetachedEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBaseC1Ej = Module["__ZN11__sanitizer17ThreadContextBaseC1Ej"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBaseC1Ej"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ThreadContextBaseD1Ev = Module["__ZN11__sanitizer17ThreadContextBaseD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ThreadContextBaseD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ThreadRegistryC1EPFPNS_17ThreadContextBaseEjEjjj = Module["__ZN11__sanitizer14ThreadRegistryC1EPFPNS_17ThreadContextBaseEjEjjj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ThreadRegistryC1EPFPNS_17ThreadContextBaseEjEjjj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_dump = Module["___sanitizer_cov_dump"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_dump"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer6AtexitEPFvvE = Module["__ZN11__sanitizer6AtexitEPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer6AtexitEPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14AddDieCallbackEPFvvE = Module["__ZN11__sanitizer14AddDieCallbackEPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14AddDieCallbackEPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_dump_coverage = Module["___sanitizer_dump_coverage"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_dump_coverage"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEEm = Module["__ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13InternalAllocEmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer4SortImNS_11CompareLessImEEEEvPT_mT0_ = Module["__ZN11__sanitizer4SortImNS_11CompareLessImEEEEvPT_mT0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer4SortImNS_11CompareLessImEEEEvPT_mT0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_get_module_and_offset_for_pc = Module["___sanitizer_get_module_and_offset_for_pc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_get_module_and_offset_for_pc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE = Module["__ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12InternalFreeEPvPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_pc_guard = Module["___sanitizer_cov_trace_pc_guard"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_pc_guard"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_pc_guard_init = Module["___sanitizer_cov_trace_pc_guard_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_pc_guard_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN8__sancov21InitializeSancovFlagsEv = Module["__ZN8__sancov21InitializeSancovFlagsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN8__sancov21InitializeSancovFlagsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorImE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorImE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorImE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_dump_trace_pc_guard_coverage = Module["___sanitizer_dump_trace_pc_guard_coverage"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_dump_trace_pc_guard_coverage"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_reset = Module["___sanitizer_cov_reset"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_reset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_cmp = Module["___sanitizer_cov_trace_cmp"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_cmp"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_cmp1 = Module["___sanitizer_cov_trace_cmp1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_cmp1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_cmp2 = Module["___sanitizer_cov_trace_cmp2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_cmp2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_cmp4 = Module["___sanitizer_cov_trace_cmp4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_cmp4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_cmp8 = Module["___sanitizer_cov_trace_cmp8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_cmp8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_const_cmp1 = Module["___sanitizer_cov_trace_const_cmp1"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_const_cmp1"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_const_cmp2 = Module["___sanitizer_cov_trace_const_cmp2"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_const_cmp2"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_const_cmp4 = Module["___sanitizer_cov_trace_const_cmp4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_const_cmp4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_const_cmp8 = Module["___sanitizer_cov_trace_const_cmp8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_const_cmp8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_switch = Module["___sanitizer_cov_trace_switch"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_switch"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_div4 = Module["___sanitizer_cov_trace_div4"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_div4"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_div8 = Module["___sanitizer_cov_trace_div8"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_div8"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_gep = Module["___sanitizer_cov_trace_gep"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_gep"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_trace_pc_indir = Module["___sanitizer_cov_trace_pc_indir"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_trace_pc_indir"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_8bit_counters_init = Module["___sanitizer_cov_8bit_counters_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_8bit_counters_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_cov_pcs_init = Module["___sanitizer_cov_pcs_init"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_cov_pcs_init"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_getpidEv = Module["__ZN11__sanitizer15internal_getpidEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_getpidEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sancov_default_options = Module["___sancov_default_options"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sancov_default_options"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN8__sancov11SancovFlags11SetDefaultsEv = Module["__ZN8__sancov11SancovFlags11SetDefaultsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN8__sancov11SancovFlags11SetDefaultsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18internal_allocatorEv = Module["__ZN11__sanitizer18internal_allocatorEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18internal_allocatorEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E8AllocateEPS5_mm = Module["__ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E8AllocateEPS5_mm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E8AllocateEPS5_mm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15InternalReallocEPvmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE = Module["__ZN11__sanitizer15InternalReallocEPvmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15InternalReallocEPvmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E10ReallocateEPS5_Pvmm = Module["__ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E10ReallocateEPS5_Pvmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E10ReallocateEPS5_Pvmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14InternalCallocEmmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE = Module["__ZN11__sanitizer14InternalCallocEmmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14InternalCallocEmmPNS_28SizeClassAllocatorLocalCacheINS_20SizeClassAllocator32INS_4AP32EEEEE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE10DeallocateEPS3_mPv = Module["__ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE10DeallocateEPS3_mPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE10DeallocateEPS3_mPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE10DeallocateEPNS_14AllocatorStatsEPv = Module["__ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE10DeallocateEPNS_14AllocatorStatsEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE10DeallocateEPNS_14AllocatorStatsEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer31SetLowLevelAllocateMinAlignmentEm = Module["__ZN11__sanitizer31SetLowLevelAllocateMinAlignmentEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer31SetLowLevelAllocateMinAlignmentEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer27SetLowLevelAllocateCallbackEPFvmmE = Module["__ZN11__sanitizer27SetLowLevelAllocateCallbackEPFvmmE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer27SetLowLevelAllocateCallbackEPFvmmE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22IsAllocatorOutOfMemoryEv = Module["__ZN11__sanitizer22IsAllocatorOutOfMemoryEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22IsAllocatorOutOfMemoryEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23SetAllocatorOutOfMemoryEv = Module["__ZN11__sanitizer23SetAllocatorOutOfMemoryEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23SetAllocatorOutOfMemoryEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22AllocatorMayReturnNullEv = Module["__ZN11__sanitizer22AllocatorMayReturnNullEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22AllocatorMayReturnNullEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer25SetAllocatorMayReturnNullEb = Module["__ZN11__sanitizer25SetAllocatorMayReturnNullEb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer25SetAllocatorMayReturnNullEb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer34PrintHintAllocatorCannotReturnNullEv = Module["__ZN11__sanitizer34PrintHintAllocatorCannotReturnNullEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer34PrintHintAllocatorCannotReturnNullEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE8AllocateEPS3_m = Module["__ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE8AllocateEPS3_m"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE8AllocateEPS3_m"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE8AllocateEPNS_14AllocatorStatsEmm = Module["__ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE8AllocateEPNS_14AllocatorStatsEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE8AllocateEPNS_14AllocatorStatsEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE6RefillEPNS4_8PerClassEPS3_m = Module["__ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE6RefillEPNS4_8PerClassEPS3_m"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE6RefillEPNS4_8PerClassEPS3_m"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE13AllocateBatchEPNS_14AllocatorStatsEPNS_30SizeClassAllocator32LocalCacheIS2_EEm = Module["__ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE13AllocateBatchEPNS_14AllocatorStatsEPNS_30SizeClassAllocator32LocalCacheIS2_EEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE13AllocateBatchEPNS_14AllocatorStatsEPNS_30SizeClassAllocator32LocalCacheIS2_EEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE16PopulateFreeListEPNS_14AllocatorStatsEPNS_30SizeClassAllocator32LocalCacheIS2_EEPNS2_13SizeClassInfoEm = Module["__ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE16PopulateFreeListEPNS_14AllocatorStatsEPNS_30SizeClassAllocator32LocalCacheIS2_EEPNS2_13SizeClassInfoEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE16PopulateFreeListEPNS_14AllocatorStatsEPNS_30SizeClassAllocator32LocalCacheIS2_EEPNS2_13SizeClassInfoEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE5DrainEPNS4_8PerClassEPS3_m = Module["__ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE5DrainEPNS4_8PerClassEPS3_m"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer30SizeClassAllocator32LocalCacheINS_20SizeClassAllocator32INS_4AP32EEEE5DrainEPNS4_8PerClassEPS3_m"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE = Module["__ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20SizeClassAllocator32INS_4AP32EE15DeallocateBatchEPNS_14AllocatorStatsEmPNS2_13TransferBatchE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE13GetBlockBeginEPKv = Module["__ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE13GetBlockBeginEPKv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEE13GetBlockBeginEPKv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E24GetActuallyAllocatedSizeEPv = Module["__ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E24GetActuallyAllocatedSizeEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17CombinedAllocatorINS_20SizeClassAllocator32INS_4AP32EEENS_28SizeClassAllocatorLocalCacheIS3_EENS_18LargeMmapAllocatorINS_20NoOpMapUnmapCallbackENS_32LargeMmapAllocatorPtrArrayStaticENS_21LocalAddressSpaceViewEEES9_E24GetActuallyAllocatedSizeEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24EmscriptenSymbolizerTool11SymbolizePCEmPNS_15SymbolizedStackE = Module["__ZN11__sanitizer24EmscriptenSymbolizerTool11SymbolizePCEmPNS_15SymbolizedStackE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24EmscriptenSymbolizerTool11SymbolizePCEmPNS_15SymbolizedStackE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer16PlatformDemangleEPKc = Module["__ZN11__sanitizer10Symbolizer16PlatformDemangleEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer16PlatformDemangleEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer12PlatformInitEv = Module["__ZN11__sanitizer10Symbolizer12PlatformInitEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer12PlatformInitEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10SymbolizerC1ENS_13IntrusiveListINS_14SymbolizerToolEEE = Module["__ZN11__sanitizer10SymbolizerC1ENS_13IntrusiveListINS_14SymbolizerToolEEE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10SymbolizerC1ENS_13IntrusiveListINS_14SymbolizerToolEEE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer14LateInitializeEv = Module["__ZN11__sanitizer10Symbolizer14LateInitializeEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer14LateInitializeEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24EmscriptenSymbolizerTool13SymbolizeDataEmPNS_8DataInfoE = Module["__ZN11__sanitizer24EmscriptenSymbolizerTool13SymbolizeDataEmPNS_8DataInfoE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24EmscriptenSymbolizerTool13SymbolizeDataEmPNS_8DataInfoE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14SymbolizerTool5FlushEv = Module["__ZN11__sanitizer14SymbolizerTool5FlushEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14SymbolizerTool5FlushEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24EmscriptenSymbolizerTool8DemangleEPKc = Module["__ZN11__sanitizer24EmscriptenSymbolizerTool8DemangleEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24EmscriptenSymbolizerTool8DemangleEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22LibbacktraceSymbolizer3getEPNS_17LowLevelAllocatorE = Module["__ZN11__sanitizer22LibbacktraceSymbolizer3getEPNS_17LowLevelAllocatorE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22LibbacktraceSymbolizer3getEPNS_17LowLevelAllocatorE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22LibbacktraceSymbolizer11SymbolizePCEmPNS_15SymbolizedStackE = Module["__ZN11__sanitizer22LibbacktraceSymbolizer11SymbolizePCEmPNS_15SymbolizedStackE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22LibbacktraceSymbolizer11SymbolizePCEmPNS_15SymbolizedStackE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22LibbacktraceSymbolizer13SymbolizeDataEmPNS_8DataInfoE = Module["__ZN11__sanitizer22LibbacktraceSymbolizer13SymbolizeDataEmPNS_8DataInfoE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22LibbacktraceSymbolizer13SymbolizeDataEmPNS_8DataInfoE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22LibbacktraceSymbolizer8DemangleEPKc = Module["__ZN11__sanitizer22LibbacktraceSymbolizer8DemangleEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22LibbacktraceSymbolizer8DemangleEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj = Module["__ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18BufferedStackTrace15FastUnwindStackEmmmmj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22__sanitizer_in_addr_szEi = Module["__ZN11__sanitizer22__sanitizer_in_addr_szEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22__sanitizer_in_addr_szEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_strstrEPKcS1_ = Module["__ZN11__sanitizer15internal_strstrEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_strstrEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strrchrEPKci = Module["__ZN11__sanitizer16internal_strrchrEPKci"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strrchrEPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_report_error_summary = Module["___sanitizer_report_error_summary"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_report_error_summary"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer35RemoveANSIEscapeSequencesFromStringEPc = Module["__ZN11__sanitizer35RemoveANSIEscapeSequencesFromStringEPc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer35RemoveANSIEscapeSequencesFromStringEPc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18internal_strchrnulEPKci = Module["__ZN11__sanitizer18internal_strchrnulEPKci"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18internal_strchrnulEPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12LoadedModule3setEPKcmNS_10ModuleArchEPhb = Module["__ZN11__sanitizer12LoadedModule3setEPKcmNS_10ModuleArchEPhb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12LoadedModule3setEPKcmNS_10ModuleArchEPhb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer12LoadedModule15containsAddressEm = Module["__ZNK11__sanitizer12LoadedModule15containsAddressEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer12LoadedModule15containsAddressEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13TemplateMatchEPKcS1_ = Module["__ZN11__sanitizer13TemplateMatchEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13TemplateMatchEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14GetProcessNameEv = Module["__ZN11__sanitizer14GetProcessNameEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14GetProcessNameEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17UpdateProcessNameEv = Module["__ZN11__sanitizer17UpdateProcessNameEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17UpdateProcessNameEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19ReadLongProcessNameEPcm = Module["__ZN11__sanitizer19ReadLongProcessNameEPcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19ReadLongProcessNameEPcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_memmoveEPvPKvm = Module["__ZN11__sanitizer16internal_memmoveEPvPKvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_memmoveEPvPKvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14ReadBinaryNameEPcm = Module["__ZN11__sanitizer14ReadBinaryNameEPcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14ReadBinaryNameEPcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20ReadBinaryNameCachedEPcm = Module["__ZN11__sanitizer20ReadBinaryNameCachedEPcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20ReadBinaryNameCachedEPcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12PrintCmdlineEv = Module["__ZN11__sanitizer12PrintCmdlineEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12PrintCmdlineEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14RunMallocHooksEPKvm = Module["__ZN11__sanitizer14RunMallocHooksEPKvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14RunMallocHooksEPKvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12RunFreeHooksEPKv = Module["__ZN11__sanitizer12RunFreeHooksEPKv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12RunFreeHooksEPKv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_acquire_crash_state = Module["___sanitizer_acquire_crash_state"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_acquire_crash_state"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_install_malloc_and_free_hooks = Module["___sanitizer_install_malloc_and_free_hooks"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_install_malloc_and_free_hooks"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer6GetUidEv = Module["__ZN11__sanitizer6GetUidEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer6GetUidEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22ReleaseMemoryPagesToOSEmm = Module["__ZN11__sanitizer22ReleaseMemoryPagesToOSEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22ReleaseMemoryPagesToOSEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19NoHugePagesInRegionEmm = Module["__ZN11__sanitizer19NoHugePagesInRegionEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19NoHugePagesInRegionEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20DontDumpShadowMemoryEmm = Module["__ZN11__sanitizer20DontDumpShadowMemoryEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20DontDumpShadowMemoryEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer28DisableCoreDumperIfNecessaryEv = Module["__ZN11__sanitizer28DisableCoreDumperIfNecessaryEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer28DisableCoreDumperIfNecessaryEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20StackSizeIsUnlimitedEv = Module["__ZN11__sanitizer20StackSizeIsUnlimitedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20StackSizeIsUnlimitedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24GetStackSizeLimitInBytesEv = Module["__ZN11__sanitizer24GetStackSizeLimitInBytesEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24GetStackSizeLimitInBytesEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24SetStackSizeLimitInBytesEm = Module["__ZN11__sanitizer24SetStackSizeLimitInBytesEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24SetStackSizeLimitInBytesEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23AddressSpaceIsUnlimitedEv = Module["__ZN11__sanitizer23AddressSpaceIsUnlimitedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23AddressSpaceIsUnlimitedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24SetAddressSpaceUnlimitedEv = Module["__ZN11__sanitizer24SetAddressSpaceUnlimitedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24SetAddressSpaceUnlimitedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15SleepForSecondsEi = Module["__ZN11__sanitizer15SleepForSecondsEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15SleepForSecondsEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14SleepForMillisEi = Module["__ZN11__sanitizer14SleepForMillisEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14SleepForMillisEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer5AbortEv = Module["__ZN11__sanitizer5AbortEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer5AbortEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19GetHandleSignalModeEi = Module["__ZN11__sanitizer19GetHandleSignalModeEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19GetHandleSignalModeEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21SupportsColoredOutputEi = Module["__ZN11__sanitizer21SupportsColoredOutputEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21SupportsColoredOutputEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23SetAlternateSignalStackEv = Module["__ZN11__sanitizer23SetAlternateSignalStackEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23SetAlternateSignalStackEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer25UnsetAlternateSignalStackEv = Module["__ZN11__sanitizer25UnsetAlternateSignalStackEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer25UnsetAlternateSignalStackEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer27InstallDeadlySignalHandlersEPFviPvS0_E = Module["__ZN11__sanitizer27InstallDeadlySignalHandlersEPFviPvS0_E"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer27InstallDeadlySignalHandlersEPFviPvS0_E"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17GetNamedMappingFdEPKcm = Module["__ZN11__sanitizer17GetNamedMappingFdEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17GetNamedMappingFdEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18internal_ftruncateEim = Module["__ZN11__sanitizer18internal_ftruncateEim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18internal_ftruncateEim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18MmapFixedNoReserveEmmPKc = Module["__ZN11__sanitizer18MmapFixedNoReserveEmmPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18MmapFixedNoReserveEmmPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20ReservedAddressRange4InitEmPKcm = Module["__ZN11__sanitizer20ReservedAddressRange4InitEmPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20ReservedAddressRange4InitEmPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17MmapFixedNoAccessEmmPKc = Module["__ZN11__sanitizer17MmapFixedNoAccessEmmPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17MmapFixedNoAccessEmmPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12MmapNoAccessEm = Module["__ZN11__sanitizer12MmapNoAccessEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12MmapNoAccessEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20ReservedAddressRange3MapEmm = Module["__ZN11__sanitizer20ReservedAddressRange3MapEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20ReservedAddressRange3MapEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20ReservedAddressRange8MapOrDieEmm = Module["__ZN11__sanitizer20ReservedAddressRange8MapOrDieEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20ReservedAddressRange8MapOrDieEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20ReservedAddressRange5UnmapEmm = Module["__ZN11__sanitizer20ReservedAddressRange5UnmapEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20ReservedAddressRange5UnmapEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24my_pthread_attr_getstackEPvPS0_Pm = Module["__ZN11__sanitizer24my_pthread_attr_getstackEPvPS0_Pm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24my_pthread_attr_getstackEPvPS0_Pm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15AdjustStackSizeEPv = Module["__ZN11__sanitizer15AdjustStackSizeEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15AdjustStackSizeEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15StartSubprocessEPKcPKS1_iii = Module["__ZN11__sanitizer15StartSubprocessEPKcPKS1_iii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15StartSubprocessEPKcPKS1_iii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13internal_forkEv = Module["__ZN11__sanitizer13internal_forkEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13internal_forkEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13internal_dup2Eii = Module["__ZN11__sanitizer13internal_dup2Eii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13internal_dup2Eii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16IsProcessRunningEi = Module["__ZN11__sanitizer16IsProcessRunningEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16IsProcessRunningEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_waitpidEiPii = Module["__ZN11__sanitizer16internal_waitpidEiPii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_waitpidEiPii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14WaitForProcessEi = Module["__ZN11__sanitizer14WaitForProcessEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14WaitForProcessEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15IsStateDetachedEi = Module["__ZN11__sanitizer15IsStateDetachedEi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15IsStateDetachedEi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18SuppressionContextC2EPPKci = Module["__ZN11__sanitizer18SuppressionContextC2EPPKci"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18SuppressionContextC2EPPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorINS_11SuppressionEE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorINS_11SuppressionEE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorINS_11SuppressionEE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FileExistsEPKc = Module["__ZN11__sanitizer10FileExistsEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FileExistsEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strncatEPcPKcm = Module["__ZN11__sanitizer16internal_strncatEPcPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strncatEPcPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi = Module["__ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16ReadFileToBufferEPKcPPcPmS4_mPi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18SuppressionContext5ParseEPKc = Module["__ZN11__sanitizer18SuppressionContext5ParseEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18SuppressionContext5ParseEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorINS_11SuppressionEE9push_backERKS1_ = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorINS_11SuppressionEE9push_backERKS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorINS_11SuppressionEE9push_backERKS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer18SuppressionContext16SuppressionCountEv = Module["__ZNK11__sanitizer18SuppressionContext16SuppressionCountEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer18SuppressionContext16SuppressionCountEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer18SuppressionContext13SuppressionAtEm = Module["__ZNK11__sanitizer18SuppressionContext13SuppressionAtEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer18SuppressionContext13SuppressionAtEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE = Module["__ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18SuppressionContext10GetMatchedEPNS_18InternalMmapVectorIPNS_11SuppressionEEE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorIPNS_11SuppressionEE9push_backERKS2_ = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorIPNS_11SuppressionEE9push_backERKS2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorIPNS_11SuppressionEE9push_backERKS2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorIPNS_11SuppressionEE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorIPNS_11SuppressionEE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorIPNS_11SuppressionEE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12ExtractTokenEPKcS1_PPc = Module["__ZN11__sanitizer12ExtractTokenEPKcS1_PPc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12ExtractTokenEPKcS1_PPc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strcspnEPKcS1_ = Module["__ZN11__sanitizer16internal_strcspnEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strcspnEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10ExtractIntEPKcS1_Pi = Module["__ZN11__sanitizer10ExtractIntEPKcS1_Pi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10ExtractIntEPKcS1_Pi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14internal_atollEPKc = Module["__ZN11__sanitizer14internal_atollEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14internal_atollEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11ExtractUptrEPKcS1_Pm = Module["__ZN11__sanitizer11ExtractUptrEPKcS1_Pm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11ExtractUptrEPKcS1_Pm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer25ExtractTokenUpToDelimiterEPKcS1_PPc = Module["__ZN11__sanitizer25ExtractTokenUpToDelimiterEPKcS1_PPc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer25ExtractTokenUpToDelimiterEPKcS1_PPc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15SymbolizedStack3NewEm = Module["__ZN11__sanitizer15SymbolizedStack3NewEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15SymbolizedStack3NewEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer20FindModuleForAddressEm = Module["__ZN11__sanitizer10Symbolizer20FindModuleForAddressEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer20FindModuleForAddressEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11AddressInfo14FillModuleInfoEPKcmNS_10ModuleArchE = Module["__ZN11__sanitizer11AddressInfo14FillModuleInfoEPKcmNS_10ModuleArchE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11AddressInfo14FillModuleInfoEPKcmNS_10ModuleArchE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer15SymbolizerScopeC1EPKS0_ = Module["__ZN11__sanitizer10Symbolizer15SymbolizerScopeC1EPKS0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer15SymbolizerScopeC1EPKS0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer15SymbolizerScopeD1Ev = Module["__ZN11__sanitizer10Symbolizer15SymbolizerScopeD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer15SymbolizerScopeD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer33FindModuleNameAndOffsetForAddressEmPPKcPmPNS_10ModuleArchE = Module["__ZN11__sanitizer10Symbolizer33FindModuleNameAndOffsetForAddressEmPPKcPmPNS_10ModuleArchE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer33FindModuleNameAndOffsetForAddressEmPPKcPmPNS_10ModuleArchE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer13SymbolizeDataEmPNS_8DataInfoE = Module["__ZN11__sanitizer10Symbolizer13SymbolizeDataEmPNS_8DataInfoE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer13SymbolizeDataEmPNS_8DataInfoE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer8DataInfo5ClearEv = Module["__ZN11__sanitizer8DataInfo5ClearEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer8DataInfo5ClearEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc = Module["__ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer15ModuleNameOwner12GetOwnedCopyEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer5FlushEv = Module["__ZN11__sanitizer10Symbolizer5FlushEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer5FlushEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer14RefreshModulesEv = Module["__ZN11__sanitizer10Symbolizer14RefreshModulesEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer14RefreshModulesEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14LLVMSymbolizerC2EPKcPNS_17LowLevelAllocatorE = Module["__ZN11__sanitizer14LLVMSymbolizerC2EPKcPNS_17LowLevelAllocatorE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14LLVMSymbolizerC2EPKcPNS_17LowLevelAllocatorE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22ParseSymbolizePCOutputEPKcPNS_15SymbolizedStackE = Module["__ZN11__sanitizer22ParseSymbolizePCOutputEPKcPNS_15SymbolizedStackE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22ParseSymbolizePCOutputEPKcPNS_15SymbolizedStackE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24ParseSymbolizeDataOutputEPKcPNS_8DataInfoE = Module["__ZN11__sanitizer24ParseSymbolizeDataOutputEPKcPNS_8DataInfoE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24ParseSymbolizeDataOutputEPKcPNS_8DataInfoE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14LLVMSymbolizer11SymbolizePCEmPNS_15SymbolizedStackE = Module["__ZN11__sanitizer14LLVMSymbolizer11SymbolizePCEmPNS_15SymbolizedStackE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14LLVMSymbolizer11SymbolizePCEmPNS_15SymbolizedStackE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14LLVMSymbolizer20FormatAndSendCommandEbPKcmNS_10ModuleArchE = Module["__ZN11__sanitizer14LLVMSymbolizer20FormatAndSendCommandEbPKcmNS_10ModuleArchE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14LLVMSymbolizer20FormatAndSendCommandEbPKcmNS_10ModuleArchE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17SymbolizerProcess11SendCommandEPKc = Module["__ZN11__sanitizer17SymbolizerProcess11SendCommandEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17SymbolizerProcess11SendCommandEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14LLVMSymbolizer13SymbolizeDataEmPNS_8DataInfoE = Module["__ZN11__sanitizer14LLVMSymbolizer13SymbolizeDataEmPNS_8DataInfoE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14LLVMSymbolizer13SymbolizeDataEmPNS_8DataInfoE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17SymbolizerProcessC2EPKcb = Module["__ZN11__sanitizer17SymbolizerProcessC2EPKcb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17SymbolizerProcessC2EPKcb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17SymbolizerProcess15SendCommandImplEPKc = Module["__ZN11__sanitizer17SymbolizerProcess15SendCommandImplEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17SymbolizerProcess15SendCommandImplEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17SymbolizerProcess7RestartEv = Module["__ZN11__sanitizer17SymbolizerProcess7RestartEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17SymbolizerProcess7RestartEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17SymbolizerProcess17WriteToSymbolizerEPKcm = Module["__ZN11__sanitizer17SymbolizerProcess17WriteToSymbolizerEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17SymbolizerProcess17WriteToSymbolizerEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17SymbolizerProcess18ReadFromSymbolizerEPcm = Module["__ZN11__sanitizer17SymbolizerProcess18ReadFromSymbolizerEPcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17SymbolizerProcess18ReadFromSymbolizerEPcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14SymbolizerTool8DemangleEPKc = Module["__ZN11__sanitizer14SymbolizerTool8DemangleEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14SymbolizerTool8DemangleEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer17SymbolizerProcess18ReachedEndOfOutputEPKcm = Module["__ZNK11__sanitizer17SymbolizerProcess18ReachedEndOfOutputEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer17SymbolizerProcess18ReachedEndOfOutputEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer17SymbolizerProcess7GetArgVEPKcRA6_S2_ = Module["__ZNK11__sanitizer17SymbolizerProcess7GetArgVEPKcRA6_S2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer17SymbolizerProcess7GetArgVEPKcRA6_S2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer21LLVMSymbolizerProcess18ReachedEndOfOutputEPKcm = Module["__ZNK11__sanitizer21LLVMSymbolizerProcess18ReachedEndOfOutputEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer21LLVMSymbolizerProcess18ReachedEndOfOutputEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer21LLVMSymbolizerProcess7GetArgVEPKcRA6_S2_ = Module["__ZNK11__sanitizer21LLVMSymbolizerProcess7GetArgVEPKcRA6_S2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer21LLVMSymbolizerProcess7GetArgVEPKcRA6_S2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14LLVMSymbolizerC1EPKcPNS_17LowLevelAllocatorE = Module["__ZN11__sanitizer14LLVMSymbolizerC1EPKcPNS_17LowLevelAllocatorE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14LLVMSymbolizerC1EPKcPNS_17LowLevelAllocatorE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17SymbolizerProcessC1EPKcb = Module["__ZN11__sanitizer17SymbolizerProcessC1EPKcb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17SymbolizerProcessC1EPKcb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11AddressInfoC2Ev = Module["__ZN11__sanitizer11AddressInfoC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11AddressInfoC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15SymbolizedStackC2Ev = Module["__ZN11__sanitizer15SymbolizedStackC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15SymbolizedStackC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer8DataInfoC2Ev = Module["__ZN11__sanitizer8DataInfoC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer8DataInfoC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer20InvalidateModuleListEv = Module["__ZN11__sanitizer10Symbolizer20InvalidateModuleListEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer20InvalidateModuleListEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer8AddHooksEPFvvES2_ = Module["__ZN11__sanitizer10Symbolizer8AddHooksEPFvvES2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer8AddHooksEPFvvES2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorIPKcE9push_backERKS2_ = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorIPKcE9push_backERKS2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorIPKcE9push_backERKS2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24InternalMmapVectorNoCtorIPKcE7ReallocEm = Module["__ZN11__sanitizer24InternalMmapVectorNoCtorIPKcE7ReallocEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24InternalMmapVectorNoCtorIPKcE7ReallocEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10SymbolizerC2ENS_13IntrusiveListINS_14SymbolizerToolEEE = Module["__ZN11__sanitizer10SymbolizerC2ENS_13IntrusiveListINS_14SymbolizerToolEEE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10SymbolizerC2ENS_13IntrusiveListINS_14SymbolizerToolEEE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer15SymbolizerScopeC2EPKS0_ = Module["__ZN11__sanitizer10Symbolizer15SymbolizerScopeC2EPKS0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer15SymbolizerScopeC2EPKS0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10Symbolizer15SymbolizerScopeD2Ev = Module["__ZN11__sanitizer10Symbolizer15SymbolizerScopeD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10Symbolizer15SymbolizerScopeD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15SymbolizedStackC1Ev = Module["__ZN11__sanitizer15SymbolizedStackC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15SymbolizedStackC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer8DataInfoC1Ev = Module["__ZN11__sanitizer8DataInfoC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer8DataInfoC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21DTLS_on_libc_memalignEPvm = Module["__ZN11__sanitizer21DTLS_on_libc_memalignEPvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21DTLS_on_libc_memalignEPvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm = Module["__ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20DTLS_on_tls_get_addrEPvS0_mm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer8DTLS_GetEv = Module["__ZN11__sanitizer8DTLS_GetEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer8DTLS_GetEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer12DTLS_DestroyEv = Module["__ZN11__sanitizer12DTLS_DestroyEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer12DTLS_DestroyEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17DTLSInDestructionEPNS_4DTLSE = Module["__ZN11__sanitizer17DTLSInDestructionEPNS_4DTLSE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17DTLSInDestructionEPNS_4DTLSE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer9VSNPrintfEPciPKcPv = Module["__ZN11__sanitizer9VSNPrintfEPciPKcPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer9VSNPrintfEPciPKcPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer26SetPrintfAndReportCallbackEPFvPKcE = Module["__ZN11__sanitizer26SetPrintfAndReportCallbackEPFvPKcE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer26SetPrintfAndReportCallbackEPFvPKcE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _OnPrint = Module["_OnPrint"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["OnPrint"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10ReportFile13SetReportPathEPKc = Module["__ZN11__sanitizer10ReportFile13SetReportPathEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10ReportFile13SetReportPathEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16ReadFileToVectorEPKcPNS_24InternalMmapVectorNoCtorIcEEmPi = Module["__ZN11__sanitizer16ReadFileToVectorEPKcPNS_24InternalMmapVectorNoCtorIcEEmPi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16ReadFileToVectorEPKcPNS_24InternalMmapVectorNoCtorIcEEmPi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16FindPathToBinaryEPKc = Module["__ZN11__sanitizer16FindPathToBinaryEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16FindPathToBinaryEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_set_report_fd = Module["___sanitizer_set_report_fd"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_set_report_fd"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17RemoveDieCallbackEPFvvE = Module["__ZN11__sanitizer17RemoveDieCallbackEPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17RemoveDieCallbackEPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18SetUserDieCallbackEPFvvE = Module["__ZN11__sanitizer18SetUserDieCallbackEPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18SetUserDieCallbackEPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22SetCheckFailedCallbackEPFvPKciS1_yyE = Module["__ZN11__sanitizer22SetCheckFailedCallbackEPFvPKciS1_yyE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22SetCheckFailedCallbackEPFvPKciS1_yyE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_set_death_callback = Module["___sanitizer_set_death_callback"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_set_death_callback"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser10ll_strndupEPKcm = Module["__ZN11__sanitizer10FlagParser10ll_strndupEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser10ll_strndupEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strnlenEPKcm = Module["__ZN11__sanitizer16internal_strnlenEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strnlenEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser11fatal_errorEPKc = Module["__ZN11__sanitizer10FlagParser11fatal_errorEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser11fatal_errorEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser8is_spaceEc = Module["__ZN11__sanitizer10FlagParser8is_spaceEc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser8is_spaceEc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser15skip_whitespaceEv = Module["__ZN11__sanitizer10FlagParser15skip_whitespaceEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser15skip_whitespaceEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser10parse_flagEv = Module["__ZN11__sanitizer10FlagParser10parse_flagEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser10parse_flagEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser11run_handlerEPKcS2_ = Module["__ZN11__sanitizer10FlagParser11run_handlerEPKcS2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser11run_handlerEPKcS2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser11parse_flagsEv = Module["__ZN11__sanitizer10FlagParser11parse_flagsEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser11parse_flagsEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParser9ParseFileEPKcb = Module["__ZN11__sanitizer10FlagParser9ParseFileEPKcb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParser9ParseFileEPKcb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10FlagParserC2Ev = Module["__ZN11__sanitizer10FlagParserC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10FlagParserC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer9DDetector6CreateEPKNS_7DDFlagsE = Module["__ZN11__sanitizer9DDetector6CreateEPKNS_7DDFlagsE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer9DDetector6CreateEPKNS_7DDFlagsE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DDC2EPKNS_7DDFlagsE = Module["__ZN11__sanitizer2DDC2EPKNS_7DDFlagsE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DDC2EPKNS_7DDFlagsE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD20CreatePhysicalThreadEv = Module["__ZN11__sanitizer2DD20CreatePhysicalThreadEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD20CreatePhysicalThreadEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD21DestroyPhysicalThreadEPNS_16DDPhysicalThreadE = Module["__ZN11__sanitizer2DD21DestroyPhysicalThreadEPNS_16DDPhysicalThreadE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD21DestroyPhysicalThreadEPNS_16DDPhysicalThreadE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD19CreateLogicalThreadEy = Module["__ZN11__sanitizer2DD19CreateLogicalThreadEy"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD19CreateLogicalThreadEy"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD20DestroyLogicalThreadEPNS_15DDLogicalThreadE = Module["__ZN11__sanitizer2DD20DestroyLogicalThreadEPNS_15DDLogicalThreadE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD20DestroyLogicalThreadEPNS_15DDLogicalThreadE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD9MutexInitEPNS_10DDCallbackEPNS_7DDMutexE = Module["__ZN11__sanitizer2DD9MutexInitEPNS_10DDCallbackEPNS_7DDMutexE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD9MutexInitEPNS_10DDCallbackEPNS_7DDMutexE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE = Module["__ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD13MutexEnsureIDEPNS_15DDLogicalThreadEPNS_7DDMutexE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE7newNodeEm = Module["__ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE7newNodeEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE7newNodeEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb = Module["__ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD15MutexBeforeLockEPNS_10DDCallbackEPNS_7DDMutexEb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE6isHeldEPNS_19DeadlockDetectorTLSIS4_EEm = Module["__ZNK11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE6isHeldEPNS_19DeadlockDetectorTLSIS4_EEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE6isHeldEPNS_19DeadlockDetectorTLSIS4_EEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE11isReachableEmRKS4_ = Module["__ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE11isReachableEmRKS4_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE11isReachableEmRKS4_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji = Module["__ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesEPNS_19DeadlockDetectorTLSIS4_EEmji"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE = Module["__ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD14ReportDeadlockEPNS_10DDCallbackEPNS_7DDMutexE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesERKS4_mPmm = Module["__ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesERKS4_mPmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8addEdgesERKS4_mPmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE14findPathToLockEPNS_19DeadlockDetectorTLSIS4_EEmPmm = Module["__ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE14findPathToLockEPNS_19DeadlockDetectorTLSIS4_EEmPmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE14findPathToLockEPNS_19DeadlockDetectorTLSIS4_EEmPmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm = Module["__ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer7BVGraphINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE8findPathEmRKS4_Pmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb = Module["__ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD14MutexAfterLockEPNS_10DDCallbackEPNS_7DDMutexEbb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19DeadlockDetectorTLSINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE7addLockEmmj = Module["__ZN11__sanitizer19DeadlockDetectorTLSINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE7addLockEmmj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19DeadlockDetectorTLSINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE7addLockEmmj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb = Module["__ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD17MutexBeforeUnlockEPNS_10DDCallbackEPNS_7DDMutexEb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19DeadlockDetectorTLSINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE10removeLockEm = Module["__ZN11__sanitizer19DeadlockDetectorTLSINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE10removeLockEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19DeadlockDetectorTLSINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE10removeLockEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE = Module["__ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD12MutexDestroyEPNS_10DDCallbackEPNS_7DDMutexE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE10removeNodeEm = Module["__ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE10removeNodeEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16DeadlockDetectorINS_17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEEEE10removeNodeEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DD9GetReportEPNS_10DDCallbackE = Module["__ZN11__sanitizer2DD9GetReportEPNS_10DDCallbackE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DD9GetReportEPNS_10DDCallbackE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEE8Iterator4nextEv = Module["__ZN11__sanitizer17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEE8Iterator4nextEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17TwoLevelBitVectorILm1ENS_14BasicBitVectorImEEE8Iterator4nextEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer2DDC1EPKNS_7DDFlagsE = Module["__ZN11__sanitizer2DDC1EPKNS_7DDFlagsE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer2DDC1EPKNS_7DDFlagsE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22SubstituteForFlagValueEPKcPcm = Module["__ZN11__sanitizer22SubstituteForFlagValueEPKcPcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22SubstituteForFlagValueEPKcPcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20RegisterIncludeFlagsEPNS_10FlagParserEPNS_11CommonFlagsE = Module["__ZN11__sanitizer20RegisterIncludeFlagsEPNS_10FlagParserEPNS_11CommonFlagsE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20RegisterIncludeFlagsEPNS_10FlagParserEPNS_11CommonFlagsE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18FlagHandlerInclude5ParseEPKc = Module["__ZN11__sanitizer18FlagHandlerInclude5ParseEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18FlagHandlerInclude5ParseEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11FlagHandlerIiE5ParseEPKc = Module["__ZN11__sanitizer11FlagHandlerIiE5ParseEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11FlagHandlerIiE5ParseEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23internal_simple_strtollEPKcPS1_i = Module["__ZN11__sanitizer23internal_simple_strtollEPKcPS1_i"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23internal_simple_strtollEPKcPS1_i"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11FlagHandlerINS_16HandleSignalModeEE5ParseEPKc = Module["__ZN11__sanitizer11FlagHandlerINS_16HandleSignalModeEE5ParseEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11FlagHandlerINS_16HandleSignalModeEE5ParseEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11FlagHandlerImE5ParseEPKc = Module["__ZN11__sanitizer11FlagHandlerImE5ParseEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11FlagHandlerImE5ParseEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer10StackTrace20GetNextInstructionPcEm = Module["__ZN11__sanitizer10StackTrace20GetNextInstructionPcEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer10StackTrace20GetNextInstructionPcEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18BufferedStackTrace4InitEPKmmm = Module["__ZN11__sanitizer18BufferedStackTrace4InitEPKmmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18BufferedStackTrace4InitEPKmmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18BufferedStackTrace14PopStackFramesEm = Module["__ZN11__sanitizer18BufferedStackTrace14PopStackFramesEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18BufferedStackTrace14PopStackFramesEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm = Module["__ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer18BufferedStackTrace15LocatePcInTraceEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_symbolize_pc = Module["___sanitizer_symbolize_pc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_symbolize_pc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___sanitizer_symbolize_global = Module["___sanitizer_symbolize_global"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__sanitizer_symbolize_global"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_memchrEPKvim = Module["__ZN11__sanitizer15internal_memchrEPKvim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_memchrEPKvim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_memrchrEPKvim = Module["__ZN11__sanitizer16internal_memrchrEPKvim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_memrchrEPKvim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_memcmpEPKvS1_m = Module["__ZN11__sanitizer15internal_memcmpEPKvS1_m"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_memcmpEPKvS1_m"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strlcatEPcPKcm = Module["__ZN11__sanitizer16internal_strlcatEPcPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strlcatEPcPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_strlcpyEPcPKcm = Module["__ZN11__sanitizer16internal_strlcpyEPcPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_strlcpyEPcPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11mem_is_zeroEPKcm = Module["__ZN11__sanitizer11mem_is_zeroEPKcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11mem_is_zeroEPKcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20ReportCallocOverflowEmmPKNS_10StackTraceE = Module["__ZN11__sanitizer20ReportCallocOverflowEmmPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20ReportCallocOverflowEmmPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer26ScopedAllocatorErrorReportC2EPKcPKNS_10StackTraceE = Module["__ZN11__sanitizer26ScopedAllocatorErrorReportC2EPKcPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer26ScopedAllocatorErrorReportC2EPKcPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer26ScopedAllocatorErrorReportD2Ev = Module["__ZN11__sanitizer26ScopedAllocatorErrorReportD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer26ScopedAllocatorErrorReportD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21ReportPvallocOverflowEmPKNS_10StackTraceE = Module["__ZN11__sanitizer21ReportPvallocOverflowEmPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21ReportPvallocOverflowEmPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17GetPageSizeCachedEv = Module["__ZN11__sanitizer17GetPageSizeCachedEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17GetPageSizeCachedEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer32ReportInvalidAllocationAlignmentEmPKNS_10StackTraceE = Module["__ZN11__sanitizer32ReportInvalidAllocationAlignmentEmPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer32ReportInvalidAllocationAlignmentEmPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer34ReportInvalidAlignedAllocAlignmentEmmPKNS_10StackTraceE = Module["__ZN11__sanitizer34ReportInvalidAlignedAllocAlignmentEmmPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer34ReportInvalidAlignedAllocAlignmentEmmPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer35ReportInvalidPosixMemalignAlignmentEmPKNS_10StackTraceE = Module["__ZN11__sanitizer35ReportInvalidPosixMemalignAlignmentEmPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer35ReportInvalidPosixMemalignAlignmentEmPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer26ReportAllocationSizeTooBigEmmPKNS_10StackTraceE = Module["__ZN11__sanitizer26ReportAllocationSizeTooBigEmmPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer26ReportAllocationSizeTooBigEmmPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17ReportOutOfMemoryEmPKNS_10StackTraceE = Module["__ZN11__sanitizer17ReportOutOfMemoryEmPKNS_10StackTraceE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17ReportOutOfMemoryEmPKNS_10StackTraceE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13internal_openEPKci = Module["__ZN11__sanitizer13internal_openEPKci"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13internal_openEPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13internal_statEPKcPv = Module["__ZN11__sanitizer13internal_statEPKcPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13internal_statEPKcPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14internal_lstatEPKcPv = Module["__ZN11__sanitizer14internal_lstatEPKcPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14internal_lstatEPKcPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14internal_fstatEiPv = Module["__ZN11__sanitizer14internal_fstatEiPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14internal_fstatEiPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17internal_readlinkEPKcPcm = Module["__ZN11__sanitizer17internal_readlinkEPKcPcm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17internal_readlinkEPKcPcm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_unlinkEPKc = Module["__ZN11__sanitizer15internal_unlinkEPKc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_unlinkEPKc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15internal_renameEPKcS1_ = Module["__ZN11__sanitizer15internal_renameEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15internal_renameEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer6GetTidEv = Module["__ZN11__sanitizer6GetTidEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer6GetTidEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer22internal_clock_gettimeEiPv = Module["__ZN11__sanitizer22internal_clock_gettimeEiPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer22internal_clock_gettimeEiPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13BlockingMutexC2Ev = Module["__ZN11__sanitizer13BlockingMutexC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13BlockingMutexC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer16internal_getppidEv = Module["__ZN11__sanitizer16internal_getppidEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer16internal_getppidEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer17internal_getdentsEiPNS_12linux_direntEj = Module["__ZN11__sanitizer17internal_getdentsEiPNS_12linux_direntEj"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer17internal_getdentsEiPNS_12linux_direntEj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14internal_lseekEimi = Module["__ZN11__sanitizer14internal_lseekEimi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14internal_lseekEimi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20internal_sigprocmaskEiPmS0_ = Module["__ZN11__sanitizer20internal_sigprocmaskEiPmS0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20internal_sigprocmaskEiPmS0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19internal_sigfillsetEPm = Module["__ZN11__sanitizer19internal_sigfillsetEPm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19internal_sigfillsetEPm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20internal_sigemptysetEPm = Module["__ZN11__sanitizer20internal_sigemptysetEPm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20internal_sigemptysetEPm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20GetMaxVirtualAddressEv = Module["__ZN11__sanitizer20GetMaxVirtualAddressEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20GetMaxVirtualAddressEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24GetMaxUserVirtualAddressEv = Module["__ZN11__sanitizer24GetMaxUserVirtualAddressEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24GetMaxUserVirtualAddressEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13LibraryNameIsEPKcS1_ = Module["__ZN11__sanitizer13LibraryNameIsEPKcS1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13LibraryNameIsEPKcS1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE = Module["__ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer19ForEachMappedRegionEP8link_mapPFvPKvmE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer21internal_start_threadEPFvPvES0_ = Module["__ZN11__sanitizer21internal_start_threadEPFvPvES0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer21internal_start_threadEPFvPvES0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer20internal_join_threadEPv = Module["__ZN11__sanitizer20internal_join_threadEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer20internal_join_threadEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer23InitializePlatformEarlyEv = Module["__ZN11__sanitizer23InitializePlatformEarlyEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer23InitializePlatformEarlyEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer11MaybeReexecEv = Module["__ZN11__sanitizer11MaybeReexecEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer11MaybeReexecEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer9CheckASLREv = Module["__ZN11__sanitizer9CheckASLREv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer9CheckASLREv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer13CheckMPROTECTEv = Module["__ZN11__sanitizer13CheckMPROTECTEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer13CheckMPROTECTEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer14PrintModuleMapEv = Module["__ZN11__sanitizer14PrintModuleMapEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer14PrintModuleMapEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer15CheckNoDeepBindEPKci = Module["__ZN11__sanitizer15CheckNoDeepBindEPKci"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer15CheckNoDeepBindEPKci"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer24FindAvailableMemoryRangeEmmmPmS0_ = Module["__ZN11__sanitizer24FindAvailableMemoryRangeEmmmPmS0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer24FindAvailableMemoryRangeEmmmPmS0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN11__sanitizer9GetRandomEPvmb = Module["__ZN11__sanitizer9GetRandomEPvmb"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN11__sanitizer9GetRandomEPvmb"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _abort_message = Module["_abort_message"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["abort_message"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_bad_cast = Module["___cxa_bad_cast"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_bad_cast"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt9terminatev = Module["__ZSt9terminatev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt9terminatev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_bad_typeid = Module["___cxa_bad_typeid"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_bad_typeid"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_throw_bad_array_new_length = Module["___cxa_throw_bad_array_new_length"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_throw_bad_array_new_length"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt14set_unexpectedPFvvE = Module["__ZSt14set_unexpectedPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt14set_unexpectedPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt13set_terminatePFvvE = Module["__ZSt13set_terminatePFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt13set_terminatePFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_demangle = Module["___cxa_demangle"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_demangle"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__214numeric_limitsIjE3maxEv = Module["__ZNSt3__214numeric_limitsIjE3maxEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__214numeric_limitsIjE3maxEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__223__libcpp_numeric_limitsIjLb1EE3maxEv = Module["__ZNSt3__223__libcpp_numeric_limitsIjLb1EE3maxEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__223__libcpp_numeric_limitsIjLb1EE3maxEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA34_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA34_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA34_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__25equalIPKcS2_EEbT_S3_T0_ = Module["__ZNSt3__25equalIPKcS2_EEbT_S3_T0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__25equalIPKcS2_EEbT_S3_T0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__25equalIPKcS2_NS_10__equal_toIccEEEEbT_S5_T0_T1_ = Module["__ZNSt3__25equalIPKcS2_NS_10__equal_toIccEEEEbT_S5_T0_T1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__25equalIPKcS2_NS_10__equal_toIccEEEEbT_S5_T0_T1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt3__210__equal_toIccEclERKcS3_ = Module["__ZNKSt3__210__equal_toIccEclERKcS3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt3__210__equal_toIccEclERKcS3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA12_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA12_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA12_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA9_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA9_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA9_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA14_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA14_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA14_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA19_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA19_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA19_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA27_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA27_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA27_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA41_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA41_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA41_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA18_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA18_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA18_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA22_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA22_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA22_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA20_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA20_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA20_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA25_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA25_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA25_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdlPv = Module["__ZdlPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdlPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA4_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA4_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA4_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRmEEOT_RNS_16remove_referenceIS2_E4typeE = Module["__ZNSt3__27forwardIRmEEOT_RNS_16remove_referenceIS2_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRmEEOT_RNS_16remove_referenceIS2_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA5_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA5_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA5_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__24moveIRbEEONS_16remove_referenceIT_E4typeEOS3_ = Module["__ZNSt3__24moveIRbEEONS_16remove_referenceIT_E4typeEOS3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__24moveIRbEEONS_16remove_referenceIT_E4typeEOS3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA10_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA10_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA10_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA2_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA2_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA2_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA11_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA11_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA11_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRbEEOT_RNS_16remove_referenceIS2_E4typeE = Module["__ZNSt3__27forwardIRbEEOT_RNS_16remove_referenceIS2_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRbEEOT_RNS_16remove_referenceIS2_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIbEEOT_RNS_16remove_referenceIS1_E4typeE = Module["__ZNSt3__27forwardIbEEOT_RNS_16remove_referenceIS1_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIbEEOT_RNS_16remove_referenceIS1_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA13_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA13_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA13_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA3_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA3_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA3_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIDnEEOT_RNS_16remove_referenceIS1_E4typeE = Module["__ZNSt3__27forwardIDnEEOT_RNS_16remove_referenceIS1_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIDnEEOT_RNS_16remove_referenceIS1_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA17_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA17_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA17_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA6_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA6_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA6_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIiEEOT_RNS_16remove_referenceIS1_E4typeE = Module["__ZNSt3__27forwardIiEEOT_RNS_16remove_referenceIS1_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIiEEOT_RNS_16remove_referenceIS1_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA8_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA8_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA8_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27reverseIPcEEvT_S2_ = Module["__ZNSt3__27reverseIPcEEvT_S2_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27reverseIPcEEvT_S2_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__29__reverseIPcEEvT_S2_NS_26random_access_iterator_tagE = Module["__ZNSt3__29__reverseIPcEEvT_S2_NS_26random_access_iterator_tagE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__29__reverseIPcEEvT_S2_NS_26random_access_iterator_tagE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__29iter_swapIPcS1_EEvT_T0_ = Module["__ZNSt3__29iter_swapIPcS1_EEvT_T0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__29iter_swapIPcS1_EEvT_T0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__24swapIcEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS2_EE5valueEvE4typeERS2_S5_ = Module["__ZNSt3__24swapIcEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS2_EE5valueEvE4typeERS2_S5_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__24swapIcEENS_9enable_ifIXaasr21is_move_constructibleIT_EE5valuesr18is_move_assignableIS2_EE5valueEvE4typeERS2_S5_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__24moveIRcEEONS_16remove_referenceIT_E4typeEOS3_ = Module["__ZNSt3__24moveIRcEEONS_16remove_referenceIT_E4typeEOS3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__24moveIRcEEONS_16remove_referenceIT_E4typeEOS3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__24moveIRmEEONS_16remove_referenceIT_E4typeEOS3_ = Module["__ZNSt3__24moveIRmEEONS_16remove_referenceIT_E4typeEOS3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__24moveIRmEEONS_16remove_referenceIT_E4typeEOS3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__23minImEERKT_S3_S3_ = Module["__ZNSt3__23minImEERKT_S3_S3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__23minImEERKT_S3_S3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __Z6memchrUa9enable_ifIXLb1EEEPKvim = Module["__Z6memchrUa9enable_ifIXLb1EEEPKvim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_Z6memchrUa9enable_ifIXLb1EEEPKvim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA16_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA16_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA16_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__23minImNS_6__lessImmEEEERKT_S5_S5_T0_ = Module["__ZNSt3__23minImNS_6__lessImmEEEERKT_S5_S5_T0_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__23minImNS_6__lessImmEEEERKT_S5_S5_T0_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __Z15__libcpp_memchrPKvim = Module["__Z15__libcpp_memchrPKvim"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_Z15__libcpp_memchrPKvim"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt3__26__lessImmEclERKmS3_ = Module["__ZNKSt3__26__lessImmEclERKmS3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt3__26__lessImmEclERKmS3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRjEEOT_RNS_16remove_referenceIS2_E4typeE = Module["__ZNSt3__27forwardIRjEEOT_RNS_16remove_referenceIS2_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRjEEOT_RNS_16remove_referenceIS2_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__23endIcLm21EEEPT_RAT0__S1_ = Module["__ZNSt3__23endIcLm21EEEPT_RAT0__S1_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__23endIcLm21EEEPT_RAT0__S1_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__24moveIRjEEONS_16remove_referenceIT_E4typeEOS3_ = Module["__ZNSt3__24moveIRjEEONS_16remove_referenceIT_E4typeEOS3_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__24moveIRjEEONS_16remove_referenceIT_E4typeEOS3_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA15_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA15_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA15_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRiEEOT_RNS_16remove_referenceIS2_E4typeE = Module["__ZNSt3__27forwardIRiEEOT_RNS_16remove_referenceIS2_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRiEEOT_RNS_16remove_referenceIS2_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__27forwardIRA7_KcEEOT_RNS_16remove_referenceIS4_E4typeE = Module["__ZNSt3__27forwardIRA7_KcEEOT_RNS_16remove_referenceIS4_E4typeE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__27forwardIRA7_KcEEOT_RNS_16remove_referenceIS4_E4typeE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__24moveIRPKcEEONS_16remove_referenceIT_E4typeEOS5_ = Module["__ZNSt3__24moveIRPKcEEONS_16remove_referenceIT_E4typeEOS5_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__24moveIRPKcEEONS_16remove_referenceIT_E4typeEOS5_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_pure_virtual = Module["___cxa_pure_virtual"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_pure_virtual"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_get_globals = Module["___cxa_get_globals"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_get_globals"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_get_globals_fast = Module["___cxa_get_globals_fast"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_get_globals_fast"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_guard_acquire = Module["___cxa_guard_acquire"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_guard_acquire"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_guard_release = Module["___cxa_guard_release"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_guard_release"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_guard_abort = Module["___cxa_guard_abort"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_guard_abort"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt14get_unexpectedv = Module["__ZSt14get_unexpectedv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt14get_unexpectedv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt12__unexpectedPFvvE = Module["__ZSt12__unexpectedPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt12__unexpectedPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt10unexpectedv = Module["__ZSt10unexpectedv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt10unexpectedv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt13get_terminatev = Module["__ZSt13get_terminatev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt13get_terminatev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt11__terminatePFvvE = Module["__ZSt11__terminatePFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt11__terminatePFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt15set_new_handlerPFvvE = Module["__ZSt15set_new_handlerPFvvE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt15set_new_handlerPFvvE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZSt15get_new_handlerv = Module["__ZSt15get_new_handlerv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZSt15get_new_handlerv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_deleted_virtual = Module["___cxa_deleted_virtual"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_deleted_virtual"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv130__aligned_malloc_with_fallbackEm = Module["__ZN10__cxxabiv130__aligned_malloc_with_fallbackEm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv130__aligned_malloc_with_fallbackEm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv122__calloc_with_fallbackEmm = Module["__ZN10__cxxabiv122__calloc_with_fallbackEmm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv122__calloc_with_fallbackEmm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv128__aligned_free_with_fallbackEPv = Module["__ZN10__cxxabiv128__aligned_free_with_fallbackEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv128__aligned_free_with_fallbackEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv120__free_with_fallbackEPv = Module["__ZN10__cxxabiv120__free_with_fallbackEPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv120__free_with_fallbackEPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __Znwm = Module["__Znwm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_Znwm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZnwmRKSt9nothrow_t = Module["__ZnwmRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZnwmRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __Znam = Module["__Znam"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_Znam"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZnamRKSt9nothrow_t = Module["__ZnamRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZnamRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdlPvRKSt9nothrow_t = Module["__ZdlPvRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdlPvRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdlPvm = Module["__ZdlPvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdlPvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdaPv = Module["__ZdaPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdaPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdaPvRKSt9nothrow_t = Module["__ZdaPvRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdaPvRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdaPvm = Module["__ZdaPvm"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdaPvm"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZnwmSt11align_val_t = Module["__ZnwmSt11align_val_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZnwmSt11align_val_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZnwmSt11align_val_tRKSt9nothrow_t = Module["__ZnwmSt11align_val_tRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZnwmSt11align_val_tRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZnamSt11align_val_t = Module["__ZnamSt11align_val_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZnamSt11align_val_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZnamSt11align_val_tRKSt9nothrow_t = Module["__ZnamSt11align_val_tRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZnamSt11align_val_tRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdlPvSt11align_val_t = Module["__ZdlPvSt11align_val_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdlPvSt11align_val_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdlPvSt11align_val_tRKSt9nothrow_t = Module["__ZdlPvSt11align_val_tRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdlPvSt11align_val_tRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdlPvmSt11align_val_t = Module["__ZdlPvmSt11align_val_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdlPvmSt11align_val_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdaPvSt11align_val_t = Module["__ZdaPvSt11align_val_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdaPvSt11align_val_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdaPvSt11align_val_tRKSt9nothrow_t = Module["__ZdaPvSt11align_val_tRKSt9nothrow_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdaPvSt11align_val_tRKSt9nothrow_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZdaPvmSt11align_val_t = Module["__ZdaPvmSt11align_val_t"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZdaPvmSt11align_val_t"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9exceptionD2Ev = Module["__ZNSt9exceptionD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9exceptionD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9exceptionD0Ev = Module["__ZNSt9exceptionD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9exceptionD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt9exception4whatEv = Module["__ZNKSt9exception4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt9exception4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt13bad_exceptionD0Ev = Module["__ZNSt13bad_exceptionD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt13bad_exceptionD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt13bad_exception4whatEv = Module["__ZNKSt13bad_exception4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt13bad_exception4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9bad_allocC2Ev = Module["__ZNSt9bad_allocC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9bad_allocC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9exceptionC2Ev = Module["__ZNSt9exceptionC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9exceptionC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9bad_allocD0Ev = Module["__ZNSt9bad_allocD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9bad_allocD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt9bad_alloc4whatEv = Module["__ZNKSt9bad_alloc4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt9bad_alloc4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt20bad_array_new_lengthC2Ev = Module["__ZNSt20bad_array_new_lengthC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt20bad_array_new_lengthC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt20bad_array_new_lengthD0Ev = Module["__ZNSt20bad_array_new_lengthD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt20bad_array_new_lengthD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt20bad_array_new_length4whatEv = Module["__ZNKSt20bad_array_new_length4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt20bad_array_new_length4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9exceptionD1Ev = Module["__ZNSt9exceptionD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9exceptionD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt13bad_exceptionD2Ev = Module["__ZNSt13bad_exceptionD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt13bad_exceptionD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt13bad_exceptionD1Ev = Module["__ZNSt13bad_exceptionD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt13bad_exceptionD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9bad_allocC1Ev = Module["__ZNSt9bad_allocC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9bad_allocC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9bad_allocD2Ev = Module["__ZNSt9bad_allocD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9bad_allocD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9bad_allocD1Ev = Module["__ZNSt9bad_allocD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9bad_allocD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt20bad_array_new_lengthC1Ev = Module["__ZNSt20bad_array_new_lengthC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt20bad_array_new_lengthC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt20bad_array_new_lengthD2Ev = Module["__ZNSt20bad_array_new_lengthD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt20bad_array_new_lengthD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt20bad_array_new_lengthD1Ev = Module["__ZNSt20bad_array_new_lengthD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt20bad_array_new_lengthD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt11logic_errorD2Ev = Module["__ZNSt11logic_errorD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt11logic_errorD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt3__218__libcpp_refstringD2Ev = Module["__ZNSt3__218__libcpp_refstringD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt3__218__libcpp_refstringD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt3__218__libcpp_refstring15__uses_refcountEv = Module["__ZNKSt3__218__libcpp_refstring15__uses_refcountEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt3__218__libcpp_refstring15__uses_refcountEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt11logic_errorD0Ev = Module["__ZNSt11logic_errorD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt11logic_errorD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt11logic_error4whatEv = Module["__ZNKSt11logic_error4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt11logic_error4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt3__218__libcpp_refstring5c_strEv = Module["__ZNKSt3__218__libcpp_refstring5c_strEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt3__218__libcpp_refstring5c_strEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt13runtime_errorD2Ev = Module["__ZNSt13runtime_errorD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt13runtime_errorD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt13runtime_errorD0Ev = Module["__ZNSt13runtime_errorD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt13runtime_errorD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt13runtime_error4whatEv = Module["__ZNKSt13runtime_error4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt13runtime_error4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12domain_errorD0Ev = Module["__ZNSt12domain_errorD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12domain_errorD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt16invalid_argumentD0Ev = Module["__ZNSt16invalid_argumentD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt16invalid_argumentD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12length_errorD0Ev = Module["__ZNSt12length_errorD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12length_errorD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12out_of_rangeD0Ev = Module["__ZNSt12out_of_rangeD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12out_of_rangeD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt11range_errorD0Ev = Module["__ZNSt11range_errorD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt11range_errorD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt14overflow_errorD0Ev = Module["__ZNSt14overflow_errorD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt14overflow_errorD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt15underflow_errorD0Ev = Module["__ZNSt15underflow_errorD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt15underflow_errorD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt11logic_errorD1Ev = Module["__ZNSt11logic_errorD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt11logic_errorD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt13runtime_errorD1Ev = Module["__ZNSt13runtime_errorD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt13runtime_errorD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12domain_errorD2Ev = Module["__ZNSt12domain_errorD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12domain_errorD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12domain_errorD1Ev = Module["__ZNSt12domain_errorD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12domain_errorD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt16invalid_argumentD2Ev = Module["__ZNSt16invalid_argumentD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt16invalid_argumentD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt16invalid_argumentD1Ev = Module["__ZNSt16invalid_argumentD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt16invalid_argumentD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12length_errorD2Ev = Module["__ZNSt12length_errorD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12length_errorD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12length_errorD1Ev = Module["__ZNSt12length_errorD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12length_errorD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12out_of_rangeD2Ev = Module["__ZNSt12out_of_rangeD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12out_of_rangeD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt12out_of_rangeD1Ev = Module["__ZNSt12out_of_rangeD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt12out_of_rangeD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt11range_errorD2Ev = Module["__ZNSt11range_errorD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt11range_errorD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt11range_errorD1Ev = Module["__ZNSt11range_errorD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt11range_errorD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt14overflow_errorD2Ev = Module["__ZNSt14overflow_errorD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt14overflow_errorD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt14overflow_errorD1Ev = Module["__ZNSt14overflow_errorD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt14overflow_errorD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt15underflow_errorD2Ev = Module["__ZNSt15underflow_errorD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt15underflow_errorD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt15underflow_errorD1Ev = Module["__ZNSt15underflow_errorD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt15underflow_errorD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9type_infoD2Ev = Module["__ZNSt9type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9type_infoD0Ev = Module["__ZNSt9type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt8bad_castC2Ev = Module["__ZNSt8bad_castC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt8bad_castC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt8bad_castD2Ev = Module["__ZNSt8bad_castD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt8bad_castD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt8bad_castD0Ev = Module["__ZNSt8bad_castD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt8bad_castD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt8bad_cast4whatEv = Module["__ZNKSt8bad_cast4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt8bad_cast4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt10bad_typeidC2Ev = Module["__ZNSt10bad_typeidC2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt10bad_typeidC2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt10bad_typeidD2Ev = Module["__ZNSt10bad_typeidD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt10bad_typeidD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt10bad_typeidD0Ev = Module["__ZNSt10bad_typeidD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt10bad_typeidD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt10bad_typeid4whatEv = Module["__ZNKSt10bad_typeid4whatEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt10bad_typeid4whatEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt9type_infoD1Ev = Module["__ZNSt9type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt9type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt8bad_castC1Ev = Module["__ZNSt8bad_castC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt8bad_castC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt8bad_castD1Ev = Module["__ZNSt8bad_castD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt8bad_castD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt10bad_typeidC1Ev = Module["__ZNSt10bad_typeidC1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt10bad_typeidC1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNSt10bad_typeidD1Ev = Module["__ZNSt10bad_typeidD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNSt10bad_typeidD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv116__shim_type_infoD2Ev = Module["__ZN10__cxxabiv116__shim_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv116__shim_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv116__shim_type_infoD0Ev = Module["__ZN10__cxxabiv116__shim_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv116__shim_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv116__shim_type_info5noop1Ev = Module["__ZNK10__cxxabiv116__shim_type_info5noop1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv116__shim_type_info5noop1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv116__shim_type_info5noop2Ev = Module["__ZNK10__cxxabiv116__shim_type_info5noop2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv116__shim_type_info5noop2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv123__fundamental_type_infoD0Ev = Module["__ZN10__cxxabiv123__fundamental_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv123__fundamental_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__array_type_infoD0Ev = Module["__ZN10__cxxabiv117__array_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__array_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv120__function_type_infoD0Ev = Module["__ZN10__cxxabiv120__function_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv120__function_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv116__enum_type_infoD0Ev = Module["__ZN10__cxxabiv116__enum_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv116__enum_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__class_type_infoD0Ev = Module["__ZN10__cxxabiv117__class_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__class_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv120__si_class_type_infoD0Ev = Module["__ZN10__cxxabiv120__si_class_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv120__si_class_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv121__vmi_class_type_infoD0Ev = Module["__ZN10__cxxabiv121__vmi_class_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv121__vmi_class_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__pbase_type_infoD0Ev = Module["__ZN10__cxxabiv117__pbase_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__pbase_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv119__pointer_type_infoD0Ev = Module["__ZN10__cxxabiv119__pointer_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv119__pointer_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv129__pointer_to_member_type_infoD0Ev = Module["__ZN10__cxxabiv129__pointer_to_member_type_infoD0Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv129__pointer_to_member_type_infoD0Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt9type_infoeqERKS_ = Module["__ZNKSt9type_infoeqERKS_"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt9type_infoeqERKS_"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNKSt9type_info4nameEv = Module["__ZNKSt9type_info4nameEv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNKSt9type_info4nameEv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__array_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv117__array_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__array_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv120__function_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv120__function_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv120__function_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv116__enum_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv116__enum_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv116__enum_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi = Module["__ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv119__pointer_type_info16can_catch_nestedEPKNS_16__shim_type_infoE = Module["__ZNK10__cxxabiv119__pointer_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv119__pointer_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv129__pointer_to_member_type_info16can_catch_nestedEPKNS_16__shim_type_infoE = Module["__ZNK10__cxxabiv129__pointer_to_member_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv129__pointer_to_member_type_info16can_catch_nestedEPKNS_16__shim_type_infoE"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv129__pointer_to_member_type_info9can_catchEPKNS_16__shim_type_infoERPv = Module["__ZNK10__cxxabiv129__pointer_to_member_type_info9can_catchEPKNS_16__shim_type_infoERPv"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv129__pointer_to_member_type_info9can_catchEPKNS_16__shim_type_infoERPv"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i = Module["__ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi = Module["__ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib = Module["__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib = Module["__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv116__shim_type_infoD1Ev = Module["__ZN10__cxxabiv116__shim_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv116__shim_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv123__fundamental_type_infoD2Ev = Module["__ZN10__cxxabiv123__fundamental_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv123__fundamental_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv123__fundamental_type_infoD1Ev = Module["__ZN10__cxxabiv123__fundamental_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv123__fundamental_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__array_type_infoD2Ev = Module["__ZN10__cxxabiv117__array_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__array_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__array_type_infoD1Ev = Module["__ZN10__cxxabiv117__array_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__array_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv120__function_type_infoD2Ev = Module["__ZN10__cxxabiv120__function_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv120__function_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv120__function_type_infoD1Ev = Module["__ZN10__cxxabiv120__function_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv120__function_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv116__enum_type_infoD2Ev = Module["__ZN10__cxxabiv116__enum_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv116__enum_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv116__enum_type_infoD1Ev = Module["__ZN10__cxxabiv116__enum_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv116__enum_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__class_type_infoD2Ev = Module["__ZN10__cxxabiv117__class_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__class_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__class_type_infoD1Ev = Module["__ZN10__cxxabiv117__class_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__class_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv120__si_class_type_infoD2Ev = Module["__ZN10__cxxabiv120__si_class_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv120__si_class_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv120__si_class_type_infoD1Ev = Module["__ZN10__cxxabiv120__si_class_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv120__si_class_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv121__vmi_class_type_infoD2Ev = Module["__ZN10__cxxabiv121__vmi_class_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv121__vmi_class_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv121__vmi_class_type_infoD1Ev = Module["__ZN10__cxxabiv121__vmi_class_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv121__vmi_class_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__pbase_type_infoD2Ev = Module["__ZN10__cxxabiv117__pbase_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__pbase_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv117__pbase_type_infoD1Ev = Module["__ZN10__cxxabiv117__pbase_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv117__pbase_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv119__pointer_type_infoD2Ev = Module["__ZN10__cxxabiv119__pointer_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv119__pointer_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv119__pointer_type_infoD1Ev = Module["__ZN10__cxxabiv119__pointer_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv119__pointer_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv129__pointer_to_member_type_infoD2Ev = Module["__ZN10__cxxabiv129__pointer_to_member_type_infoD2Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv129__pointer_to_member_type_infoD2Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv129__pointer_to_member_type_infoD1Ev = Module["__ZN10__cxxabiv129__pointer_to_member_type_infoD1Ev"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv129__pointer_to_member_type_infoD1Ev"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_increment_exception_refcount = Module["___cxa_increment_exception_refcount"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_increment_exception_refcount"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_decrement_exception_refcount = Module["___cxa_decrement_exception_refcount"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_decrement_exception_refcount"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_current_primary_exception = Module["___cxa_current_primary_exception"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_current_primary_exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_rethrow_primary_exception = Module["___cxa_rethrow_primary_exception"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_rethrow_primary_exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_uncaught_exception = Module["___cxa_uncaught_exception"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_uncaught_exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_uncaught_exceptions = Module["___cxa_uncaught_exceptions"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_uncaught_exceptions"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv119__getExceptionClassEPK17_Unwind_Exception = Module["__ZN10__cxxabiv119__getExceptionClassEPK17_Unwind_Exception"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv119__getExceptionClassEPK17_Unwind_Exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv119__setExceptionClassEP17_Unwind_Exceptiony = Module["__ZN10__cxxabiv119__setExceptionClassEP17_Unwind_Exceptiony"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv119__setExceptionClassEP17_Unwind_Exceptiony"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __ZN10__cxxabiv121__isOurExceptionClassEPK17_Unwind_Exception = Module["__ZN10__cxxabiv121__isOurExceptionClassEPK17_Unwind_Exception"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_ZN10__cxxabiv121__isOurExceptionClassEPK17_Unwind_Exception"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _socketpair = Module["_socketpair"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["socketpair"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _shutdown = Module["_shutdown"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["shutdown"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _listen = Module["_listen"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["listen"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getpeername = Module["_getpeername"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getpeername"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _sendmsg = Module["_sendmsg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["sendmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _recvmsg = Module["_recvmsg"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["recvmsg"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _getsockopt = Module["_getsockopt"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getsockopt"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _freeaddrinfo = Module["_freeaddrinfo"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["freeaddrinfo"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___set_stack_limit = Module["___set_stack_limit"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__set_stack_limit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackSave"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackAlloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackRestore"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __growWasmMemory = Module["__growWasmMemory"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__growWasmMemory"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiii = Module["dynCall_iiii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_jijii = Module["dynCall_jijii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_jijii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iii = Module["dynCall_iii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_vi = Module["dynCall_vi"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiii = Module["dynCall_iiiiii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_jiji"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_ii = Module["dynCall_ii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iidiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_vii = Module["dynCall_vii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiii = Module["dynCall_iiiii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_jii = Module["dynCall_jii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_jii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_v = Module["dynCall_v"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_v"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viii = Module["dynCall_viii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iij = Module["dynCall_iij"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iij"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiii = Module["dynCall_viiii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiiii = Module["dynCall_viiiii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiiiii = Module["dynCall_viiiiii"] = function () {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiiii"].apply(null, arguments)
};

Module['___memory_base'] = 0;
Module['___table_base'] = 1;
Module['_stderr'] = 140456;
Module['_common'] = 328896;
Module['_input_dense'] = 319296;
Module['_vad_gru'] = 319316;
Module['_vad_output'] = 319408;
Module['_noise_gru'] = 319340;
Module['_denoise_gru'] = 319364;
Module['_denoise_output'] = 319388;
Module['___progname'] = 332760;
Module['___progname_full'] = 332764;
Module['___libc'] = 332768;
Module['___hwcap'] = 332832;
Module['___sysinfo'] = 332836;
Module['_program_invocation_short_name'] = 332760;
Module['_program_invocation_name'] = 332764;
Module['_optind'] = 319440;
Module['___optreset'] = 333176;
Module['___optpos'] = 333180;
Module['_optarg'] = 333184;
Module['_optopt'] = 333188;
Module['_opterr'] = 319444;
Module['_optreset'] = 333176;
Module['_in6addr_loopback'] = 113988;
Module['_h_errno'] = 333268;
Module['_in6addr_any'] = 114240;
Module['__ns_flagdata'] = 114272;
Module['___fsmu8'] = 128080;
Module['___pio2_hi'] = 130896;
Module['___pio2_lo'] = 130912;
Module['___signgam'] = 334212;
Module['_signgam'] = 334212;
Module['___seed48'] = 319824;
Module['___stdin_used'] = 320288;
Module['___stdout_used'] = 319984;
Module['___stderr_used'] = 320136;
Module['_stdin'] = 141008;
Module['_stdout'] = 140452;
Module['___c_dot_utf8_locale'] = 141752;
Module['___c_locale'] = 141728;
Module['___c_dot_utf8'] = 141700;
Module['___environ'] = 336544;
Module['____environ'] = 336544;
Module['__environ'] = 336544;
Module['_environ'] = 336544;
Module['___env_map'] = 336552;
Module['_tzname'] = 336556;
Module['_daylight'] = 336564;
Module['_timezone'] = 336568;
Module['___THREW__'] = 340672;
Module['___threwValue'] = 340676;
Module['_atanlo'] = 267296;
Module['_atanhi'] = 267232;
Module['_aT'] = 267360;
Module['__ZN11__sanitizer17SanitizerToolNameE'] = 320628;
Module['__ZN11__sanitizer21common_flags_dont_useE'] = 4974476;
Module['__ZN7__ubsan14TypeCheckKindsE'] = 320432;
Module['__ZN11__sanitizer14PageSizeCachedE'] = 4966048;
Module['___ubsan_vptr_type_cache'] = 603344;
Module['__ZTISt9type_info'] = 316992;
Module['__ZTIN10__cxxabiv117__class_type_infoE'] = 317136;
Module['__ZTIN10__cxxabiv120__si_class_type_infoE'] = 319096;
Module['__ZTIN10__cxxabiv121__vmi_class_type_infoE'] = 319188;
Module['__ZN7__ubsan11ubsan_flagsE'] = 603960;
Module['__ZN11__sanitizer10FlagParser5AllocE'] = 4974384;
Module['__ZTVN11__sanitizer11FlagHandlerIbEE'] = 279100;
Module['__ZTVN11__sanitizer11FlagHandlerIPKcEE'] = 279268;
Module['__ZN20__em_asm_sig_builderI19__em_asm_type_tupleIJEEE6bufferE'] = 279097;
Module['__ZN11__sanitizer17current_verbosityE'] = 4966044;
Module['__ZTIN11__sanitizer11FlagHandlerIbEE'] = 279188;
Module['__ZTSN11__sanitizer11FlagHandlerIbEE'] = 279112;
Module['__ZTSN11__sanitizer15FlagHandlerBaseE'] = 279144;
Module['__ZTIN11__sanitizer15FlagHandlerBaseE'] = 279180;
Module['__ZTVN10__cxxabiv117__class_type_infoE'] = 318976;
Module['__ZTVN10__cxxabiv120__si_class_type_infoE'] = 319016;
Module['__ZTIN11__sanitizer11FlagHandlerIPKcEE'] = 279316;
Module['__ZTSN11__sanitizer11FlagHandlerIPKcEE'] = 279280;
Module['__ZN11__sanitizer9fake_argvE'] = 603972;
Module['__ZN11__sanitizer9fake_envpE'] = 603976;
Module['__ZTVN11__sanitizer20SuspendedThreadsListE'] = 279524;
Module['__ZTIN11__sanitizer20SuspendedThreadsListE'] = 279588;
Module['__ZTSN11__sanitizer20SuspendedThreadsListE'] = 279548;
Module['__ZN11__sanitizer22thePersistentAllocatorE'] = 603988;
Module['__ZN11__sanitizer20__em_asm_sig_builderINS_19__em_asm_type_tupleIJEEEE6bufferE'] = 280708;
Module['__ZTVN11__sanitizer17ThreadContextBaseE'] = 282932;
Module['__ZTIN11__sanitizer17ThreadContextBaseE'] = 283956;
Module['__ZN11__sanitizer14ThreadRegistry11kUnknownTidE'] = 283232;
Module['__ZTSN11__sanitizer17ThreadContextBaseE'] = 283921;
Module['___sancov_lowest_stack'] = 4799364;
Module['__ZN8__sancov30sancov_flags_dont_use_directlyE'] = 4799368;
Module['__ZN11__sanitizer22SecondaryAllocatorNameE'] = 320484;
Module['__ZN11__sanitizer20PrimaryAllocatorNameE'] = 320480;
Module['__ZN11__sanitizer10Symbolizer21symbolizer_allocator_E'] = 4974324;
Module['__ZTVN11__sanitizer24EmscriptenSymbolizerToolE'] = 286964;
Module['__ZTIN11__sanitizer24EmscriptenSymbolizerToolE'] = 287072;
Module['__ZTSN11__sanitizer24EmscriptenSymbolizerToolE'] = 286988;
Module['__ZTSN11__sanitizer14SymbolizerToolE'] = 287030;
Module['__ZTIN11__sanitizer14SymbolizerToolE'] = 287064;
Module['__ZTVN11__sanitizer22LibbacktraceSymbolizerE'] = 287112;
Module['__ZTIN11__sanitizer22LibbacktraceSymbolizerE'] = 287176;
Module['__ZTSN11__sanitizer22LibbacktraceSymbolizerE'] = 287136;
Module['__ZN11__sanitizer10StackTrace14snapshot_stackE'] = 320492;
Module['__ZN11__sanitizer17struct_utsname_szE'] = 320496;
Module['__ZN11__sanitizer14struct_stat_szE'] = 320500;
Module['__ZN11__sanitizer16struct_stat64_szE'] = 320504;
Module['__ZN11__sanitizer16struct_rusage_szE'] = 320508;
Module['__ZN11__sanitizer12struct_tm_szE'] = 320512;
Module['__ZN11__sanitizer16struct_passwd_szE'] = 320516;
Module['__ZN11__sanitizer15struct_group_szE'] = 320520;
Module['__ZN11__sanitizer12siginfo_t_szE'] = 320524;
Module['__ZN11__sanitizer19struct_sigaction_szE'] = 320528;
Module['__ZN11__sanitizer19struct_itimerval_szE'] = 320532;
Module['__ZN11__sanitizer12pthread_t_szE'] = 320536;
Module['__ZN11__sanitizer18pthread_mutex_t_szE'] = 320540;
Module['__ZN11__sanitizer17pthread_cond_t_szE'] = 320544;
Module['__ZN11__sanitizer8pid_t_szE'] = 320548;
Module['__ZN11__sanitizer10timeval_szE'] = 320552;
Module['__ZN11__sanitizer8uid_t_szE'] = 320556;
Module['__ZN11__sanitizer8gid_t_szE'] = 320560;
Module['__ZN11__sanitizer12mbstate_t_szE'] = 320564;
Module['__ZN11__sanitizer11sigset_t_szE'] = 320568;
Module['__ZN11__sanitizer18struct_timezone_szE'] = 320572;
Module['__ZN11__sanitizer13struct_tms_szE'] = 320576;
Module['__ZN11__sanitizer18struct_sigevent_szE'] = 320580;
Module['__ZN11__sanitizer21struct_sched_param_szE'] = 320584;
Module['__ZN11__sanitizer15struct_regex_szE'] = 320588;
Module['__ZN11__sanitizer18struct_regmatch_szE'] = 320592;
Module['__ZN11__sanitizer7sig_ignE'] = 287188;
Module['__ZN11__sanitizer7sig_dflE'] = 287192;
Module['__ZN11__sanitizer7sig_errE'] = 287196;
Module['__ZN11__sanitizer10sa_siginfoE'] = 287200;
Module['__ZN11__sanitizer14struct_utmp_szE'] = 320596;
Module['__ZN11__sanitizer15struct_utmpx_szE'] = 320600;
Module['__ZN11__sanitizer9map_fixedE'] = 320604;
Module['__ZN11__sanitizer7af_inetE'] = 320608;
Module['__ZN11__sanitizer8af_inet6E'] = 320612;
Module['__ZN11__sanitizer8path_maxE'] = 320616;
Module['__ZN11__sanitizer15struct_ifreq_szE'] = 320620;
Module['__ZN11__sanitizer17struct_termios_szE'] = 320624;
Module['__ZN11__sanitizer17IOCTL_NOT_PRESENTE'] = 287204;
Module['__ZN11__sanitizer14si_SEGV_MAPERRE'] = 287208;
Module['__ZN11__sanitizer14si_SEGV_ACCERRE'] = 287212;
Module['__ZN11__sanitizer18NumberOfCPUsCachedE'] = 4966052;
Module['__ZN11__sanitizer23stoptheworld_tracer_pidE'] = 4966056;
Module['__ZN11__sanitizer24stoptheworld_tracer_ppidE'] = 4966060;
Module['__ZN11__sanitizer10Symbolizer8init_mu_E'] = 4974320;
Module['__ZN11__sanitizer10Symbolizer11symbolizer_E'] = 4974316;
Module['__ZTVN11__sanitizer14LLVMSymbolizerE'] = 289440;
Module['__ZTVN11__sanitizer17SymbolizerProcessE'] = 289592;
Module['__ZTVN11__sanitizer21LLVMSymbolizerProcessE'] = 290260;
Module['__ZTIN11__sanitizer14LLVMSymbolizerE'] = 289928;
Module['__ZTIN11__sanitizer17SymbolizerProcessE'] = 289976;
Module['__ZTSN11__sanitizer14LLVMSymbolizerE'] = 289895;
Module['__ZTSN11__sanitizer17SymbolizerProcessE'] = 289940;
Module['__ZTIN11__sanitizer21LLVMSymbolizerProcessE'] = 290320;
Module['__ZTSN11__sanitizer21LLVMSymbolizerProcessE'] = 290280;
Module['__ZN11__sanitizer16errno_EOWNERDEADE'] = 291140;
Module['__ZN11__sanitizer11report_fileE'] = 320632;
Module['__ZN11__sanitizer14report_file_muE'] = 4974336;
Module['__ZN11__sanitizer13unknown_flagsE'] = 4974392;
Module['__ZTVN11__sanitizer2DDE'] = 292696;
Module['__ZTIN11__sanitizer2DDE'] = 293012;
Module['__ZTSN11__sanitizer2DDE'] = 292957;
Module['__ZTSN11__sanitizer9DDetectorE'] = 292976;
Module['__ZTIN11__sanitizer9DDetectorE'] = 293004;
Module['__ZTVN11__sanitizer18FlagHandlerIncludeE'] = 302556;
Module['__ZTVN11__sanitizer11FlagHandlerIiEE'] = 302660;
Module['__ZTVN11__sanitizer11FlagHandlerINS_16HandleSignalModeEEE'] = 302760;
Module['__ZTVN11__sanitizer11FlagHandlerImEE'] = 302908;
Module['__ZTIN11__sanitizer18FlagHandlerIncludeE'] = 302604;
Module['__ZTSN11__sanitizer18FlagHandlerIncludeE'] = 302568;
Module['__ZTIN11__sanitizer11FlagHandlerIiEE'] = 302704;
Module['__ZTSN11__sanitizer11FlagHandlerIiEE'] = 302672;
Module['__ZTIN11__sanitizer11FlagHandlerINS_16HandleSignalModeEEE'] = 302828;
Module['__ZTSN11__sanitizer11FlagHandlerINS_16HandleSignalModeEEE'] = 302772;
Module['__ZTIN11__sanitizer11FlagHandlerImEE'] = 302952;
Module['__ZTSN11__sanitizer11FlagHandlerImEE'] = 302920;
Module['__ZN11__sanitizer9true_type5valueE'] = 305032;
Module['__ZN11__sanitizer10false_type5valueE'] = 305033;
Module['___cxa_unexpected_handler'] = 328840;
Module['___cxa_terminate_handler'] = 328836;
Module['___cxa_new_handler'] = 4974652;
Module['__ZTVSt9bad_alloc'] = 316180;
Module['__ZTVSt9exception'] = 316260;
Module['__ZTVSt20bad_array_new_length'] = 316216;
Module['__ZTISt9bad_alloc'] = 316372;
Module['__ZTISt20bad_array_new_length'] = 316412;
Module['__ZTISt9exception'] = 316296;
Module['__ZTSSt9exception'] = 316280;
Module['__ZTVSt13bad_exception'] = 316304;
Module['__ZTISt13bad_exception'] = 316344;
Module['__ZTSSt13bad_exception'] = 316324;
Module['__ZTSSt9bad_alloc'] = 316356;
Module['__ZTSSt20bad_array_new_length'] = 316384;
Module['__ZTVSt11logic_error'] = 316424;
Module['__ZTVSt13runtime_error'] = 316444;
Module['__ZTISt11logic_error'] = 316520;
Module['__ZTISt13runtime_error'] = 316760;
Module['__ZTVSt12domain_error'] = 316464;
Module['__ZTISt12domain_error'] = 316532;
Module['__ZTSSt12domain_error'] = 316484;
Module['__ZTSSt11logic_error'] = 316501;
Module['__ZTVSt16invalid_argument'] = 316544;
Module['__ZTISt16invalid_argument'] = 316588;
Module['__ZTSSt16invalid_argument'] = 316564;
Module['__ZTVSt12length_error'] = 316600;
Module['__ZTISt12length_error'] = 316640;
Module['__ZTSSt12length_error'] = 316620;
Module['__ZTVSt12out_of_range'] = 316652;
Module['__ZTISt12out_of_range'] = 316692;
Module['__ZTSSt12out_of_range'] = 316672;
Module['__ZTVSt11range_error'] = 316704;
Module['__ZTISt11range_error'] = 316772;
Module['__ZTSSt11range_error'] = 316724;
Module['__ZTSSt13runtime_error'] = 316740;
Module['__ZTVSt14overflow_error'] = 316784;
Module['__ZTISt14overflow_error'] = 316824;
Module['__ZTSSt14overflow_error'] = 316804;
Module['__ZTVSt15underflow_error'] = 316836;
Module['__ZTISt15underflow_error'] = 316876;
Module['__ZTSSt15underflow_error'] = 316856;
Module['__ZTVSt8bad_cast'] = 316888;
Module['__ZTVSt10bad_typeid'] = 316924;
Module['__ZTISt8bad_cast'] = 317012;
Module['__ZTISt10bad_typeid'] = 317040;
Module['__ZTVSt9type_info'] = 316960;
Module['__ZTSSt9type_info'] = 316976;
Module['__ZTSSt8bad_cast'] = 317000;
Module['__ZTSSt10bad_typeid'] = 317024;
Module['__ZTIN10__cxxabiv116__shim_type_infoE'] = 317088;
Module['__ZTIN10__cxxabiv117__pbase_type_infoE'] = 317184;
Module['__ZTIDn'] = 317532;
Module['__ZTIN10__cxxabiv119__pointer_type_infoE'] = 317232;
Module['__ZTIv'] = 317480;
Module['__ZTIN10__cxxabiv120__function_type_infoE'] = 317284;
Module['__ZTIN10__cxxabiv129__pointer_to_member_type_infoE'] = 317344;
Module['__ZTSN10__cxxabiv116__shim_type_infoE'] = 317052;
Module['__ZTSN10__cxxabiv117__class_type_infoE'] = 317100;
Module['__ZTSN10__cxxabiv117__pbase_type_infoE'] = 317148;
Module['__ZTSN10__cxxabiv119__pointer_type_infoE'] = 317196;
Module['__ZTSN10__cxxabiv120__function_type_infoE'] = 317244;
Module['__ZTSN10__cxxabiv129__pointer_to_member_type_infoE'] = 317296;
Module['__ZTVN10__cxxabiv116__shim_type_infoE'] = 317368;
Module['__ZTVN10__cxxabiv123__fundamental_type_infoE'] = 317396;
Module['__ZTIN10__cxxabiv123__fundamental_type_infoE'] = 317464;
Module['__ZTSN10__cxxabiv123__fundamental_type_infoE'] = 317424;
Module['__ZTSv'] = 317476;
Module['__ZTSPv'] = 317488;
Module['__ZTIPv'] = 317492;
Module['__ZTVN10__cxxabiv119__pointer_type_infoE'] = 319228;
Module['__ZTSPKv'] = 317508;
Module['__ZTIPKv'] = 317512;
Module['__ZTSDn'] = 317528;
Module['__ZTSPDn'] = 317540;
Module['__ZTIPDn'] = 317544;
Module['__ZTSPKDn'] = 317560;
Module['__ZTIPKDn'] = 317568;
Module['__ZTSb'] = 317584;
Module['__ZTIb'] = 317588;
Module['__ZTSPb'] = 317596;
Module['__ZTIPb'] = 317600;
Module['__ZTSPKb'] = 317616;
Module['__ZTIPKb'] = 317620;
Module['__ZTSw'] = 317636;
Module['__ZTIw'] = 317640;
Module['__ZTSPw'] = 317648;
Module['__ZTIPw'] = 317652;
Module['__ZTSPKw'] = 317668;
Module['__ZTIPKw'] = 317672;
Module['__ZTSc'] = 317688;
Module['__ZTIc'] = 317692;
Module['__ZTSPc'] = 317700;
Module['__ZTIPc'] = 317704;
Module['__ZTSPKc'] = 317720;
Module['__ZTIPKc'] = 317724;
Module['__ZTSh'] = 317740;
Module['__ZTIh'] = 317744;
Module['__ZTSPh'] = 317752;
Module['__ZTIPh'] = 317756;
Module['__ZTSPKh'] = 317772;
Module['__ZTIPKh'] = 317776;
Module['__ZTSa'] = 317792;
Module['__ZTIa'] = 317796;
Module['__ZTSPa'] = 317804;
Module['__ZTIPa'] = 317808;
Module['__ZTSPKa'] = 317824;
Module['__ZTIPKa'] = 317828;
Module['__ZTSs'] = 317844;
Module['__ZTIs'] = 317848;
Module['__ZTSPs'] = 317856;
Module['__ZTIPs'] = 317860;
Module['__ZTSPKs'] = 317876;
Module['__ZTIPKs'] = 317880;
Module['__ZTSt'] = 317896;
Module['__ZTIt'] = 317900;
Module['__ZTSPt'] = 317908;
Module['__ZTIPt'] = 317912;
Module['__ZTSPKt'] = 317928;
Module['__ZTIPKt'] = 317932;
Module['__ZTSi'] = 317948;
Module['__ZTIi'] = 317952;
Module['__ZTSPi'] = 317960;
Module['__ZTIPi'] = 317964;
Module['__ZTSPKi'] = 317980;
Module['__ZTIPKi'] = 317984;
Module['__ZTSj'] = 318000;
Module['__ZTIj'] = 318004;
Module['__ZTSPj'] = 318012;
Module['__ZTIPj'] = 318016;
Module['__ZTSPKj'] = 318032;
Module['__ZTIPKj'] = 318036;
Module['__ZTSl'] = 318052;
Module['__ZTIl'] = 318056;
Module['__ZTSPl'] = 318064;
Module['__ZTIPl'] = 318068;
Module['__ZTSPKl'] = 318084;
Module['__ZTIPKl'] = 318088;
Module['__ZTSm'] = 318104;
Module['__ZTIm'] = 318108;
Module['__ZTSPm'] = 318116;
Module['__ZTIPm'] = 318120;
Module['__ZTSPKm'] = 318136;
Module['__ZTIPKm'] = 318140;
Module['__ZTSx'] = 318156;
Module['__ZTIx'] = 318160;
Module['__ZTSPx'] = 318168;
Module['__ZTIPx'] = 318172;
Module['__ZTSPKx'] = 318188;
Module['__ZTIPKx'] = 318192;
Module['__ZTSy'] = 318208;
Module['__ZTIy'] = 318212;
Module['__ZTSPy'] = 318220;
Module['__ZTIPy'] = 318224;
Module['__ZTSPKy'] = 318240;
Module['__ZTIPKy'] = 318244;
Module['__ZTSn'] = 318260;
Module['__ZTIn'] = 318264;
Module['__ZTSPn'] = 318272;
Module['__ZTIPn'] = 318276;
Module['__ZTSPKn'] = 318292;
Module['__ZTIPKn'] = 318296;
Module['__ZTSo'] = 318312;
Module['__ZTIo'] = 318316;
Module['__ZTSPo'] = 318324;
Module['__ZTIPo'] = 318328;
Module['__ZTSPKo'] = 318344;
Module['__ZTIPKo'] = 318348;
Module['__ZTSDh'] = 318364;
Module['__ZTIDh'] = 318368;
Module['__ZTSPDh'] = 318376;
Module['__ZTIPDh'] = 318380;
Module['__ZTSPKDh'] = 318396;
Module['__ZTIPKDh'] = 318404;
Module['__ZTSf'] = 318420;
Module['__ZTIf'] = 318424;
Module['__ZTSPf'] = 318432;
Module['__ZTIPf'] = 318436;
Module['__ZTSPKf'] = 318452;
Module['__ZTIPKf'] = 318456;
Module['__ZTSd'] = 318472;
Module['__ZTId'] = 318476;
Module['__ZTSPd'] = 318484;
Module['__ZTIPd'] = 318488;
Module['__ZTSPKd'] = 318504;
Module['__ZTIPKd'] = 318508;
Module['__ZTSe'] = 318524;
Module['__ZTIe'] = 318528;
Module['__ZTSPe'] = 318536;
Module['__ZTIPe'] = 318540;
Module['__ZTSPKe'] = 318556;
Module['__ZTIPKe'] = 318560;
Module['__ZTSg'] = 318576;
Module['__ZTIg'] = 318580;
Module['__ZTSPg'] = 318588;
Module['__ZTIPg'] = 318592;
Module['__ZTSPKg'] = 318608;
Module['__ZTIPKg'] = 318612;
Module['__ZTSDu'] = 318628;
Module['__ZTIDu'] = 318632;
Module['__ZTSPDu'] = 318640;
Module['__ZTIPDu'] = 318644;
Module['__ZTSPKDu'] = 318660;
Module['__ZTIPKDu'] = 318668;
Module['__ZTSDs'] = 318684;
Module['__ZTIDs'] = 318688;
Module['__ZTSPDs'] = 318696;
Module['__ZTIPDs'] = 318700;
Module['__ZTSPKDs'] = 318716;
Module['__ZTIPKDs'] = 318724;
Module['__ZTSDi'] = 318740;
Module['__ZTIDi'] = 318744;
Module['__ZTSPDi'] = 318752;
Module['__ZTIPDi'] = 318756;
Module['__ZTSPKDi'] = 318772;
Module['__ZTIPKDi'] = 318780;
Module['__ZTVN10__cxxabiv117__array_type_infoE'] = 318796;
Module['__ZTIN10__cxxabiv117__array_type_infoE'] = 318860;
Module['__ZTSN10__cxxabiv117__array_type_infoE'] = 318824;
Module['__ZTVN10__cxxabiv120__function_type_infoE'] = 318872;
Module['__ZTVN10__cxxabiv116__enum_type_infoE'] = 318900;
Module['__ZTIN10__cxxabiv116__enum_type_infoE'] = 318964;
Module['__ZTSN10__cxxabiv116__enum_type_infoE'] = 318928;
Module['__ZTSN10__cxxabiv120__si_class_type_infoE'] = 319056;
Module['__ZTVN10__cxxabiv121__vmi_class_type_infoE'] = 319108;
Module['__ZTSN10__cxxabiv121__vmi_class_type_infoE'] = 319148;
Module['__ZTVN10__cxxabiv117__pbase_type_infoE'] = 319200;
Module['__ZTVN10__cxxabiv129__pointer_to_member_type_infoE'] = 319256;
Module['___dso_handle'] = 1024;
Module['___global_base'] = 1024;
Module['___heap_base'] = 10218064;

/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;

if (!Object.getOwnPropertyDescriptor(Module, "intArrayFromString")) Module["intArrayFromString"] = function () { abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "intArrayToString")) Module["intArrayToString"] = function () { abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ccall")) Module["ccall"] = function () { abort("'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["cwrap"] = cwrap;
if (!Object.getOwnPropertyDescriptor(Module, "setValue")) Module["setValue"] = function () { abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getValue")) Module["getValue"] = function () { abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocate")) Module["allocate"] = function () { abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getMemory")) Module["getMemory"] = function () { abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ArrayToString")) Module["UTF8ArrayToString"] = function () { abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ToString")) Module["UTF8ToString"] = function () { abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8Array")) Module["stringToUTF8Array"] = function () { abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8")) Module["stringToUTF8"] = function () { abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF8")) Module["lengthBytesUTF8"] = function () { abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = function () { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreRun")) Module["addOnPreRun"] = function () { abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnInit")) Module["addOnInit"] = function () { abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreMain")) Module["addOnPreMain"] = function () { abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnExit")) Module["addOnExit"] = function () { abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPostRun")) Module["addOnPostRun"] = function () { abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeStringToMemory")) Module["writeStringToMemory"] = function () { abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeArrayToMemory")) Module["writeArrayToMemory"] = function () { abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeAsciiToMemory")) Module["writeAsciiToMemory"] = function () { abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addRunDependency")) Module["addRunDependency"] = function () { abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "removeRunDependency")) Module["removeRunDependency"] = function () { abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createFolder")) Module["FS_createFolder"] = function () { abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createPath")) Module["FS_createPath"] = function () { abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createDataFile")) Module["FS_createDataFile"] = function () { abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createPreloadedFile")) Module["FS_createPreloadedFile"] = function () { abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createLazyFile")) Module["FS_createLazyFile"] = function () { abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createLink")) Module["FS_createLink"] = function () { abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createDevice")) Module["FS_createDevice"] = function () { abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_unlink")) Module["FS_unlink"] = function () { abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "dynamicAlloc")) Module["dynamicAlloc"] = function () { abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadDynamicLibrary")) Module["loadDynamicLibrary"] = function () { abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadWebAssemblyModule")) Module["loadWebAssemblyModule"] = function () { abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getLEB")) Module["getLEB"] = function () { abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFunctionTables")) Module["getFunctionTables"] = function () { abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "alignFunctionTables")) Module["alignFunctionTables"] = function () { abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registerFunctions")) Module["registerFunctions"] = function () { abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addFunction")) Module["addFunction"] = function () { abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "removeFunction")) Module["removeFunction"] = function () { abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFuncWrapper")) Module["getFuncWrapper"] = function () { abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "prettyPrint")) Module["prettyPrint"] = function () { abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "makeBigInt")) Module["makeBigInt"] = function () { abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "dynCall")) Module["dynCall"] = function () { abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getCompilerSetting")) Module["getCompilerSetting"] = function () { abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "print")) Module["print"] = function () { abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "printErr")) Module["printErr"] = function () { abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getTempRet0")) Module["getTempRet0"] = function () { abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setTempRet0")) Module["setTempRet0"] = function () { abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "callMain")) Module["callMain"] = function () { abort("'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "abort")) Module["abort"] = function () { abort("'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToNewUTF8")) Module["stringToNewUTF8"] = function () { abort("'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscripten_realloc_buffer")) Module["emscripten_realloc_buffer"] = function () { abort("'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ENV")) Module["ENV"] = function () { abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setjmpId")) Module["setjmpId"] = function () { abort("'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ERRNO_CODES")) Module["ERRNO_CODES"] = function () { abort("'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ERRNO_MESSAGES")) Module["ERRNO_MESSAGES"] = function () { abort("'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setErrNo")) Module["setErrNo"] = function () { abort("'setErrNo' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "DNS")) Module["DNS"] = function () { abort("'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GAI_ERRNO_MESSAGES")) Module["GAI_ERRNO_MESSAGES"] = function () { abort("'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Protocols")) Module["Protocols"] = function () { abort("'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Sockets")) Module["Sockets"] = function () { abort("'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UNWIND_CACHE")) Module["UNWIND_CACHE"] = function () { abort("'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readAsmConstArgs")) Module["readAsmConstArgs"] = function () { abort("'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jstoi_q")) Module["jstoi_q"] = function () { abort("'jstoi_q' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jstoi_s")) Module["jstoi_s"] = function () { abort("'jstoi_s' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "reallyNegative")) Module["reallyNegative"] = function () { abort("'reallyNegative' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "formatString")) Module["formatString"] = function () { abort("'formatString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PATH")) Module["PATH"] = function () { abort("'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PATH_FS")) Module["PATH_FS"] = function () { abort("'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SYSCALLS")) Module["SYSCALLS"] = function () { abort("'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "syscallMmap2")) Module["syscallMmap2"] = function () { abort("'syscallMmap2' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "syscallMunmap")) Module["syscallMunmap"] = function () { abort("'syscallMunmap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "JSEvents")) Module["JSEvents"] = function () { abort("'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "specialHTMLTargets")) Module["specialHTMLTargets"] = function () { abort("'specialHTMLTargets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "demangle")) Module["demangle"] = function () { abort("'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "demangleAll")) Module["demangleAll"] = function () { abort("'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jsStackTrace")) Module["jsStackTrace"] = function () { abort("'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = function () { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getEnvStrings")) Module["getEnvStrings"] = function () { abort("'getEnvStrings' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64")) Module["writeI53ToI64"] = function () { abort("'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64Clamped")) Module["writeI53ToI64Clamped"] = function () { abort("'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64Signaling")) Module["writeI53ToI64Signaling"] = function () { abort("'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToU64Clamped")) Module["writeI53ToU64Clamped"] = function () { abort("'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToU64Signaling")) Module["writeI53ToU64Signaling"] = function () { abort("'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readI53FromI64")) Module["readI53FromI64"] = function () { abort("'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readI53FromU64")) Module["readI53FromU64"] = function () { abort("'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "convertI32PairToI53")) Module["convertI32PairToI53"] = function () { abort("'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "convertU32PairToI53")) Module["convertU32PairToI53"] = function () { abort("'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Browser")) Module["Browser"] = function () { abort("'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "FS")) Module["FS"] = function () { abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "MEMFS")) Module["MEMFS"] = function () { abort("'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "TTY")) Module["TTY"] = function () { abort("'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PIPEFS")) Module["PIPEFS"] = function () { abort("'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SOCKFS")) Module["SOCKFS"] = function () { abort("'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GL")) Module["GL"] = function () { abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGet")) Module["emscriptenWebGLGet"] = function () { abort("'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetTexPixelData")) Module["emscriptenWebGLGetTexPixelData"] = function () { abort("'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetUniform")) Module["emscriptenWebGLGetUniform"] = function () { abort("'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetVertexAttrib")) Module["emscriptenWebGLGetVertexAttrib"] = function () { abort("'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "AL")) Module["AL"] = function () { abort("'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_unicode")) Module["SDL_unicode"] = function () { abort("'SDL_unicode' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_ttfContext")) Module["SDL_ttfContext"] = function () { abort("'SDL_ttfContext' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_audio")) Module["SDL_audio"] = function () { abort("'SDL_audio' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL")) Module["SDL"] = function () { abort("'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_gfx")) Module["SDL_gfx"] = function () { abort("'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLUT")) Module["GLUT"] = function () { abort("'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "EGL")) Module["EGL"] = function () { abort("'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLFW_Window")) Module["GLFW_Window"] = function () { abort("'GLFW_Window' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLFW")) Module["GLFW"] = function () { abort("'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLEW")) Module["GLEW"] = function () { abort("'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "IDBStore")) Module["IDBStore"] = function () { abort("'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "runAndAbortIfError")) Module["runAndAbortIfError"] = function () { abort("'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "warnOnce")) Module["warnOnce"] = function () { abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackSave")) Module["stackSave"] = function () { abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackRestore")) Module["stackRestore"] = function () { abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackAlloc")) Module["stackAlloc"] = function () { abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "AsciiToString")) Module["AsciiToString"] = function () { abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToAscii")) Module["stringToAscii"] = function () { abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF16ToString")) Module["UTF16ToString"] = function () { abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF16")) Module["stringToUTF16"] = function () { abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF16")) Module["lengthBytesUTF16"] = function () { abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF32ToString")) Module["UTF32ToString"] = function () { abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF32")) Module["stringToUTF32"] = function () { abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF32")) Module["lengthBytesUTF32"] = function () { abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8")) Module["allocateUTF8"] = function () { abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8OnStack")) Module["allocateUTF8OnStack"] = function () { abort("'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
Module["abortStackOverflow"] = abortStackOverflow; if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NORMAL")) Object.defineProperty(Module, "ALLOC_NORMAL", { configurable: true, get: function () { abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_STACK")) Object.defineProperty(Module, "ALLOC_STACK", { configurable: true, get: function () { abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_DYNAMIC")) Object.defineProperty(Module, "ALLOC_DYNAMIC", { configurable: true, get: function () { abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NONE")) Object.defineProperty(Module, "ALLOC_NONE", { configurable: true, get: function () { abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });



var calledRun;


/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;


dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  var entryFunction = Module['_main'];


  var argc = 0;
  var argv = 0;


  try {

    Module['___set_stack_limit'](STACK_MAX);

    var ret;


    // function wasm_noise_cancel(buffer)
    // {
    //   let wasmMemInP = Module._malloc(buffer.length);

    //   let wasmMemIn = new Float32Array(wasmMemory.buffer, wasmMemInP, buffer.length);
    //   wasmMemIn.set(buffer.getChannelData(0));

    //   // rn_noise_cancel = Module.cwrap('rn_noise_cancel', 'number', ['number', 'number', 'number']);
    //   // let x= rn_noise_cancel(wasmMemInP, wasmMemInP, buffer.length);

    //   denoise_proc = Module.cwrap('denoise_proc', '', ['number', 'number', 'number', 'number']);
    //   let memOutP = denoise_proc(wasmMemInP, buffer.sampleRate, buffer.numberOfChannels, buffer.length)

    //   let wasmMemOut = new Float32Array(wasmMemory.buffer, wasmMemInP, buffer.length);
    //   buffer.copyToChannel(wasmMemOut, 0, 0)
    // /*
    //   let myJSArray = new Float32Array();
    //   let myWasmArrayPtr = Module._malloc(buffer.length);
    //   let myWASMArray = new Float32Array(wasmMemory.buffer, myWasmArrayPtr, buffer.length);
    //   myWASMArray.set(buffer.getChannelData(0));
    //   denoise_proc = Module.cwrap('denoise_proc', '', ['number', 'number', 'number', 'number']);
    //   let memOutP = denoise_proc(myWasmArrayPtr, buffer.length, buffer.sampleRate, buffer.numberOfChannels)s
    //   let myWASMOutArray = new Float32Array(wasmMemory.buffer, memOutP, buffer.length);
    //   myJSArray.set(myWASMOutArray);
    //   buffer.copyToChannel(myJSArray, 0, 0)
    // */
    // }
    // var ret = entryFunction(argc, argv);


    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed
    // off to a pthread.
    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
  }
  catch (e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'unwind') {
      // running an evented main loop, don't immediately exit
      noExitRuntime = true;
      return;
    } else {
      var toLog = e;
      if (e && typeof e === 'object' && e.stack) {
        toLog = [e, e.stack];
      }
      err('exception thrown: ' + toLog);
      quit_(1, e);
    }
  } finally {
    calledMain = true;
  }
}




/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  writeStackCookie();

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function () {
      setTimeout(function () {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var print = out;
  var printErr = err;
  var has = false;
  out = err = function (x) {
    has = true;
  }
  try { // it doesn't matter if it fails
    var flush = Module['_fflush'];
    if (flush) flush(0);
    // also flush in the JS FS layer
    ['stdout', 'stderr'].forEach(function (name) {
      var info = FS.analyzePath('/dev/' + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty && tty.output && tty.output.length) {
        has = true;
      }
    });
  } catch (e) { }
  out = print;
  err = printErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
  }
}

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  checkUnflushedContent();

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && noExitRuntime && status === 0) {
    return;
  }

  if (noExitRuntime) {
    // if exit() was called, we may warn the user if the runtime isn't actually being shut down
    if (!implicit) {
      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');
    }
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;


noExitRuntime = true;

run();





// {{MODULE_ADDITIONS}}



var startRecordingButton = document.getElementById("startRecordingButton");
var stopRecordingButton = document.getElementById("stopRecordingButton");
var playButtonR = document.getElementById("playButtonR");
var playButtonD = document.getElementById("playButtonD");
var downloadButton = document.getElementById("downloadButton");


var leftchannel = [];
var rightchannel = [];
var denoisedchannel = [];

var recorder = null;
var recordingLength = 0;
var volume = null;
var mediaStream = null;
var sampleRate = 44100;
var context = null;

var blobIn = null;
var blobOut = null;


startRecordingButton.addEventListener("click", function () {
  // Initialize recorder
  navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
  navigator.getUserMedia(
    {
      audio: true
    },
    function (e) {
      console.log("user consent");

      // creates the audio context
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      context = new AudioContext();

      // creates an audio node from the microphone incoming stream
      mediaStream = context.createMediaStreamSource(e);

      // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor
      // bufferSize: the onaudioprocess event is called when the buffer is full
      var bufferSize = 2048;
      var numberOfInputChannels = 1;
      var numberOfOutputChannels = 1;
      if (context.createScriptProcessor) {
        recorder = context.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
      } else {
        recorder = context.createJavaScriptNode(bufferSize, numberOfInputChannels, numberOfOutputChannels);
      }

      recorder.onaudioprocess = function (e) {
        leftchannel.push(new Float32Array(e.inputBuffer.getChannelData(0)));
        console.log(e.inputBuffer.getChannelData(0));

        // rightchannel.push(new Float32Array(e.inputBuffer.getChannelData(1)));
        let denoisedBuffer = wasm_noise_cancel(e.inputBuffer);
        
        console.log(denoisedBuffer.getChannelData(0));
        denoisedchannel.push(new Float32Array(denoisedBuffer.getChannelData(0)));

        recordingLength += bufferSize;
      }

      // we connect the recorder
      mediaStream.connect(recorder);
      recorder.connect(context.destination);
    },
    function (e) {
      console.error(e);
    });
});


function wasm_noise_cancel(buffer) {
  let wasmMemInP = Module._malloc(buffer.length);

  let wasmMemIn = new Float32Array(wasmMemory.buffer, wasmMemInP, buffer.length);
  wasmMemIn.set(buffer.getChannelData(0));

  // rn_noise_cancel = Module.cwrap('rn_noise_cancel', 'number', ['number', 'number', 'number']);
  // let x= rn_noise_cancel(wasmMemInP, wasmMemInP, buffer.length);

  denoise_proc = Module.cwrap('denoise_proc', '', ['number', 'number', 'number', 'number']);
  let memOutP = denoise_proc(wasmMemInP, buffer.sampleRate, buffer.numberOfChannels, buffer.length)

  let wasmMemOut = new Float32Array(wasmMemory.buffer, wasmMemInP, buffer.length);
  buffer.copyToChannel(wasmMemOut, 0, 0)
  /*
    let myJSArray = new Float32Array();
    let myWasmArrayPtr = Module._malloc(buffer.length);
    let myWASMArray = new Float32Array(wasmMemory.buffer, myWasmArrayPtr, buffer.length);
    myWASMArray.set(buffer.getChannelData(0));
    denoise_proc = Module.cwrap('denoise_proc', '', ['number', 'number', 'number', 'number']);
    let memOutP = denoise_proc(myWasmArrayPtr, buffer.length, buffer.sampleRate, buffer.numberOfChannels)s
    let myWASMOutArray = new Float32Array(wasmMemory.buffer, memOutP, buffer.length);
    myJSArray.set(myWASMOutArray);
    buffer.copyToChannel(myJSArray, 0, 0)
  */
}



stopRecordingButton.addEventListener("click", function () {

  // stop recording
  recorder.disconnect(context.destination);
  mediaStream.disconnect(recorder);
  blobIn = writeWAV(leftchannel, rightchannel);

});

function writeWAV(left, right) {
  // we flat the left and right channels down
  // Float32Array[] => Float32Array
  var leftBuffer = flattenArray(left, recordingLength);
  var rightBuffer = flattenArray(right, recordingLength);
  // we interleave both channels together
  // [left[0],right[0],left[1],right[1],...]
  var interleaved = interleave(leftBuffer, rightBuffer);

  // we create our wav file
  var buffer = new ArrayBuffer(44 + interleaved.length * 2);
  var view = new DataView(buffer);

  // RIFF chunk descriptor
  writeUTFBytes(view, 0, 'RIFF');
  view.setUint32(4, 44 + interleaved.length * 2, true);
  writeUTFBytes(view, 8, 'WAVE');
  // FMT sub-chunk
  writeUTFBytes(view, 12, 'fmt ');
  view.setUint32(16, 16, true); // chunkSize
  view.setUint16(20, 1, true); // wFormatTag
  view.setUint16(22, 2, true); // wChannels: stereo (2 channels)
  view.setUint32(24, sampleRate, true); // dwSamplesPerSec
  view.setUint32(28, sampleRate * 4, true); // dwAvgBytesPerSec
  view.setUint16(32, 4, true); // wBlockAlign
  view.setUint16(34, 16, true); // wBitsPerSample
  // data sub-chunk
  writeUTFBytes(view, 36, 'data');
  view.setUint32(40, interleaved.length * 2, true);

  // write the PCM samples
  var index = 44;
  var volume = 1;
  for (var i = 0; i < interleaved.length; i++) {
    view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
    index += 2;
  }

  // our final blob
  return new Blob([view], { type: 'audio/wav' });
}

playButtonR.addEventListener("click", function () {
  if (blobIn == null) {
    return;
  }

  var url = window.URL.createObjectURL(blobIn);
  var audio = new Audio(url);
  audio.play();
});

playButtonD.addEventListener("click", function () {
  if (blobOut == null) {
    return;
  }

  var url = window.URL.createObjectURL(blobOut);
  var audio = new Audio(url);
  audio.play();
});

downloadButton.addEventListener("click", function (inBlob) {
  if (inBlob == null) {
    return;
  }

  var url = URL.createObjectURL(inBlob);

  var a = document.createElement("a");
  document.body.appendChild(a);
  a.style = "display: none";
  a.href = url;
  a.download = "sample.wav";
  a.click();
  window.URL.revokeObjectURL(url);
});

function flattenArray(channelBuffer, recordingLength) {
  var result = new Float32Array(recordingLength);
  var offset = 0;
  for (var i = 0; i < channelBuffer.length; i++) {
    var buffer = channelBuffer[i];
    result.set(buffer, offset);
    offset += buffer.length;
  }
  return result;
}

function interleave(leftChannel, rightChannel) {
  var length = leftChannel.length + rightChannel.length;
  var result = new Float32Array(length);

  var inputIndex = 0;

  for (var index = 0; index < length;) {
    result[index++] = leftChannel[inputIndex]
    result[index++] = rightChannel[inputIndex];
    inputIndex++;
  }
  return result;
}

function writeUTFBytes(view, offset, string) {
  for (var i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}
